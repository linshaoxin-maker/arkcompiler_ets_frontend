// Copyright (c) 2021 Huawei Device Co., Ltd.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

% def get_node_kind(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}"
% end

// Autogenerated file -- DO NOT EDIT!
import { PandaGen } from "./pandagen";
import * as ts from "typescript";
import * as jshelpers from "./jshelpers";
import {
  DebugInfo,
  DebugPosInfo,
  NodeKind
} from "./debuginfo";
import { LOGE } from "./log"

export enum IRNodeKind {
  VREG,
  IMM,
  LABEL,
  LD_NAN,
  LD_INFINITY,
  LD_GLOBALTHIS,
  LD_UNDEFINED,
  LD_BOOLEAN,
  LD_NUMBER,
  LD_STRING,
  LD_BIGINT,
  LD_SYMBOL,
  LD_REGEXP,
  LD_NULL,
  LD_OBJECT,
  LD_FUNCTION,
  LD_GLOBAL,
  LD_True,
  LD_False,
  ADD2_DYN,
  SUB2_DYN,
  MUL2_DYN,
  DIV2_DYN,
  MOD2_DYN,
  EQ_DYN,
  NOTEQ_DYN,  
  LESS_DYN,
  LESSEQ_DYN,
  GREATER_DYN,
  GREATEREQ_DYN,
  LDGLOBAL_DYN,
  TONUMBER,
  SHL2_DYN,
  SHR2_DYN,
  ASHR2_DYN,
  AND2_DYN,
  OR2_DYN,
  XOR2_DYN,
  NEG_DYN,
  NOT_DYN,
  INC_DYN,
  DEC_DYN,
  THROW_DYN,
  DEFINE_GLOBAL_VAR,
  DEFINE_LOCAL_VAR,
  DEFINEFUNC_DYN,
  DEFINE_NCFUNC_DYN,
  STRICTEQ_DYN,
  STRICTNOTEQ_DYN,
  EXP_DYN,
  TYPEOF_DYN,
  GET_PROP_ITERATOR,
  DEL_OBJ_PROP,
  IS_IN_DYN,
  INSTANCE_OF_DYN,
  DEBUGGER,
  CALL_SPREAD,
  NEWOBJ_SPREAD,
  NEWLEXENV_DYN,
  LDLEXENV_DYN,
  STLEXVARDYN,
  LDLEXVARDYN,
  VIRTUALINS_DYN,
  TOBOOLEAN,
  GETUNMAPPEDARGS,
  THROWUNDEFINEDIFHOLE,
  THROWCONSTASSIGNMENT,
  THROWTHROWNOTEXISTS,
  THROWDELETESUPERPROPERTY,
  DEFINE_GENERATOR_FUNC,
  CREATE_GENERATOR_OBJ,
  CREATE_ITERRESULT_OBJ,
  SUSPEND_GENERATOR,
  RESUME_GENERATOR,
  GET_RESUME_MODE,
  DEFINE_ASYNC_FUNC,
  ASYNC_FUNCTION_ENTER,
  ASYNC_FUNCTION_AWAIT_UNCAUGHT,
  ASYNC_FUNCTION_RESOLVE,
  ASYNC_FUNCTION_REJECT,
  LDHOLE,
  GET_TEMPLATE_OBJECT,
  COPY_REST_ARGS,
  TRYLDGLOBALBYNAME,
  TRYSTGLOBALBYNAME,
  TRYLDGLOBALBYVALUE,
  TRYSTGLOBALBYVALUE,
  LDGLOBALVAR,
  STGLOBALVAR,
  LDOBJBYNAME,
  STOBJBYNAME,
  LDOBJBYINDEX,
  STOBJBYINDEX,
  LDOBJBYVALUE,
  STOBJBYVALUE,
  STOWNBYNAME,
  STOWNBYINDEX,
  STOWNBYVALUE,
  CALL0DYN,
  CALL1DYN,
  CALL2DYN,
  CALL3DYN,
  CALLIRANGEDYN,
  CALLITHISRANGEDYN,
  NEWOBJDYNRANGE,
  GETNEXTPROPNAME,
  RETURNUNDEFINED,
  CREATEEMPTYOBJECT,
  CREATEOBJECTHAVINGMETHOD,
  CREATEOBJECTWITHBUFFER,
  DEFINECLASSWITHBUFFER,
  SETOBJECTWITHPROTO,
  CREATEOBJECTWITHEXCLUDEDKEYS,
  COPYDATAPROPERTIES,
  DEFINEGETTERSETTERBYVALUE,
  CREATEEMPTYARRAY,
  CREATEARRAYWITHBUFFER,
  STARRAYSPREAD,
  THROWIFNOTOBJECT,
  THROWPATTERNNONCOERCIBLE,
  GETITERATOR,
  GETITERATORNEXT,
  CLOSEITERATOR,
  SUPERCALL,
  SUPERCALLSPREAD,
  DEFINEMETHOD,
  LDSUPERBYNAME,
  STSUPERBYNAME,
  LDSUPERBYVALUE,
  STSUPERBYVALUE,
  IMPORTMODULE,
  LDMODVARBYNAME,
  STMODULEVAR,
  COPYMODULE,
  THROWIFSUPERNOTCORRECTCALL,
  LDHOMEOBJECT,
  POPLEXENVDYN,
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
  <%= get_node_kind(mnemonic) %>,
% end
}

export function getInstructionSize(opcode: IRNodeKind) {
  switch(opcode) {
% Panda::instructions.each do |insn|
% node_kind = get_node_kind(insn.mnemonic)
% kind = "IRNodeKind." + node_kind
    case <%= kind %>:
      return <%= insn.format.size %>;
% end
    default:
      // LOGE("getInstructionSize: Unknown opcode:" + opcode);
      return 0;
  }
}

export enum ResultType {
  None,
  Unknown,
  Int,
  Long,
  Float,
  Obj,
  Boolean
}

export enum ResultDst {
  None,
  Acc,
  VReg
}

export enum BuiltIns {
  NaN,
  Infinity,
  globalThis,
  undefined,
  Boolean,
  Number,
  String,
  BigInt,
  Symbol,
  Null,
  Object,
  Function,
  Global,
  True,
  False,
  LexEnv,
  MAX_BUILTIN,
}

export type OperandType = VReg | Imm | Label | string | number

export enum OperandKind {
  // the least significant bit indicates vreg
  // the second bit indicates src or dst
  SrcVReg, DstVReg, SrcDstVReg, Imm, Id, StringId, Label
}

export namespace OperandKind {
  function isVReg(kind: OperandKind): boolean {
    return kind === OperandKind.SrcVReg || kind === OperandKind.DstVReg || kind === OperandKind.SrcDstVReg;
  }
}

export class FormatItem {
  constructor(
    readonly kind: OperandKind,
    readonly bitwidth: number,
  ) {}
}

export type Format = FormatItem[]

export abstract class IRNode {
  private node: ts.Node | NodeKind = NodeKind.Normal;
  constructor(
    readonly kind: IRNodeKind,
    readonly mnemonic: string,
    readonly operands: OperandType[],
    readonly formats: Format[]
  ) {}
  // for debuginfo
  public debugPosInfo: DebugPosInfo = new DebugPosInfo();

  abstract resultType(): ResultType;
  abstract resultIn(): ResultDst;

  toString(): string {
    let out = this.mnemonic + "\t";
    if (this.mnemonic.length < 8) {
      out += "\t";
    }

    this.operands.forEach((element) => {
      out = out + element.toString() + ", ";
    });

    return out;
  }

  setNode(node: ts.Node | NodeKind) {
    this.node = node;
  }

  getNodeName() {
    if (this.node != NodeKind.Invalid &&
        this.node != NodeKind.FirstNodeOfFunction &&
        this.node != NodeKind.Normal) {
      return ts.SyntaxKind[(<ts.Node>this.node).kind];
    }

    return "undefined";
  }
}

export abstract class Intrinsic extends IRNode {
  slotSize: number = 0;
  constructor(
    readonly kind: IRNodeKind,
    readonly mnemonic: string,
    readonly operands: OperandType[],
    readonly formats: Format[]
  ) {
    super(kind, mnemonic, operands, formats);
  }

  toString(): string {
    return super.toString() + " [i]";
  }

  hasIC(): boolean {
    return this.slotSize > 0;
  }

  updateICOffset(base: number): number {return 0};

  validateIC(offset: number, slotSize: number): number {
    let end = offset + slotSize;
    if (end > 0xFFFF) {
      return 0xFFFF;
    } else {
      return offset;
    }
  }
}

export class VReg {
  private static global_id = 0;
  readonly id: number; // used for debug purpose to distinguish one instance from another
  num: number = -1;
  
  // for debug purposes
  private stacktrace: (undefined | string);
  
  toString(): string {
    if (this.num != -1) {
      return "V" + this.num;
    } else {
      return "L" + this.id;
    }
  }

  constructor() {
    this.id = VReg.global_id++;
    
    // for debug purposes
    this.setStackTrace(null);
  }
  
  // for debug purposes
  getStackTrace(): (undefined | string) {
    return this.stacktrace;
  }
  
  setStackTrace(stack?: null): void {
    if (stack === undefined) {
      let error = new Error();
      let trace = error.stack;
      
      this.stacktrace = trace;
      return;
    }
    
    if (stack === null) {
      this.stacktrace = undefined;
      return;
    }
  }
}

export class Imm extends IRNode {
  private type: ResultType;
  readonly value: number;

  constructor(type: ResultType, value: number) {
    super(IRNodeKind.IMM, "", [], []);
    this.type = type;
    this.value = value;
  }

  static zero(): Imm {
    return new Imm(ResultType.Int, 0);
  }

  static one(): Imm {
    return new Imm(ResultType.Int, 1);
  }

  resultType(): ResultType {
    return this.type;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }

  toString(): string {
    return "#" + this.value;
  }
}

export class Label extends IRNode {
  private static global_id = 0;
  readonly id: number; // used for debug purpose to distinguish one instance from another

  constructor() {
    super(IRNodeKind.LABEL, "", [], []);
    this.id = Label.global_id++;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }

  toString(): string {
    return "LABEL_" + this.id;
  }
}

export class DebugInsPlaceHolder extends IRNode {
  constructor() {
    super(IRNodeKind.VIRTUALINS_DYN, "", [], []);
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdNaN extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_NAN,
      "ldnan",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdInfinity extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_INFINITY,
      "ldinfinity",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdGlobalThis extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_GLOBALTHIS,
      "ldglobalthis",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdUndefined extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_UNDEFINED,
      "ldundefined",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdBoolean extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_BOOLEAN,
      "ldboolean",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdNumber extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_NUMBER,
      "ldnumber",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdString extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_STRING,
      "ldstring",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdBigInt extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_BIGINT,
      "ldbigint",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdSymbol extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_SYMBOL,
      "ldsymbol",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdRegExp extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_REGEXP,
      "ldRegExp",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdNull extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_NULL,
      "ldnull",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdObject extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_OBJECT,
      "ldobject",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdFunction extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_FUNCTION,
      "ldfunction",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdGlobal extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_GLOBAL,
      "ldglobal",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdTrue extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_True,
      "ldtrue",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdFalse extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LD_False,
      "ldfalse",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Add2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.ADD2_DYN,
      "add2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Sub2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.SUB2_DYN,
      "sub2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Mul2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.MUL2_DYN,
      "mul2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Div2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.DIV2_DYN,
      "div2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Mod2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.MOD2_DYN,
      "mod2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class EqDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.EQ_DYN,
      "eqDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class NotEqDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.NOTEQ_DYN,
      "noteqDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LessDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.LESS_DYN,
      "lessDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LessEqDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.LESSEQ_DYN,
      "lesseqDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class GreaterDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.GREATER_DYN,
      "greaterDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class GreaterEqDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.GREATEREQ_DYN,
      "greatereqDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Shl2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.SHL2_DYN,
      "shl2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Shr2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.SHR2_DYN,
      "shr2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Ashr2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.ASHR2_DYN,
      "ashr2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class And2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.AND2_DYN,
      "and2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Or2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.OR2_DYN,
      "or2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Xor2Dyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.XOR2_DYN,
      "xor2Dyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
* Tonumber instruction convert object to number
*/
export class Tonumber extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.TONUMBER,
      "tonumber",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Float;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class NegDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.NEG_DYN,
      "negDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Float;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class NotDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.NOT_DYN,
      "notDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class IncDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.INC_DYN,
      "incDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Float;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class DecDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.DEC_DYN,
      "decDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Float;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class ThrowDyn extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.THROW_DYN,
      "throwDyn",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

/**
 * The instruction removes the property from Object
 * v1 stores the obj and v2 stores the prop before calling it
 * the result is a boolean value which stored in acc in the end
 */
export class DelObjProp extends Intrinsic {
  constructor(v1: VReg, v2: VReg) {
    super(
      IRNodeKind.DEL_OBJ_PROP,
      "delobjprop",
      [v1, v2],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Boolean;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction is used to hoist the global variables
 */
export class DefineGlobalVar extends Intrinsic {
  constructor(id: string) {
    super(
      IRNodeKind.DEFINE_GLOBAL_VAR,
      "defineglobalvar",
      [id],
      [
        [new FormatItem(OperandKind.Id, 32)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

/**
 * The pseudo instruction is used to hoist the global variables
 */
export class DefineLocalVar extends Intrinsic {
  constructor(vreg: VReg) {
    super(
      IRNodeKind.DEFINE_LOCAL_VAR,
      "definelocalvar",
      [vreg],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.VReg;
  }
}

/**
 * The pseudo instruction is defined the arrow function
 */
export class DefineNCFuncDyn extends Intrinsic {
  constructor(id: string, env: VReg) {
    super(
      IRNodeKind.DEFINE_NCFUNC_DYN,
      "defineNCFuncDyn",
      [id, env],
      [
        [new FormatItem(OperandKind.Id, 32), new FormatItem(OperandKind.SrcVReg, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction calls the runtime to create a Function
 * instance and bind it with code. The resulting instance will
 * be stored into the accumulator.
 */
export class DefinefuncDyn extends Intrinsic {
  constructor(id: string, env: VReg) {
    super(
      IRNodeKind.DEFINEFUNC_DYN,
      "definefuncDyn",
      [id, env],
      [
        [new FormatItem(OperandKind.Id, 32), new FormatItem(OperandKind.SrcVReg, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The following two instructions implement strict comparison operator '===' and '!=='
 * It writes '1' to the accumulator if the it is true.
 * In another case it writes '0' to the accumulator.
 */

export class StrictEqDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.STRICTEQ_DYN,
      "strictEqDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StrictNotEqDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.STRICTNOTEQ_DYN,
      "strictNotEqDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class ExpDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.EXP_DYN,
      "expDyn",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    )
  }

  resultType(): ResultType {
    return ResultType.Int;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The instruction returns the type of object.
 * return string value:"undefined","boolean","number","bigint", "string"
 * "symbol","function","object"
 */
export class TypeOfDyn extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.TYPEOF_DYN,
      "typeofDyn",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 *The instruction calls a function getPropertiesIterator() to transform
 *the obj(in Acc) to an iterator that has the next() method to iterate the obj .
 */
export class GetPropertiesIterator extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.GET_PROP_ITERATOR,
      "getPropIterator",
      [],
      [
        []
      ]
    );
  }
  
  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  } 
}

/**
 * The instruction returns true if the specified property is in the specified object or its prototype chain
 */
export class IsInDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.IS_IN_DYN,
      "isinDyn",
      [v],
      [[new FormatItem(OperandKind.SrcVReg, 8)]]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/** 
 * The instruction tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. 
 */
export class InstanceOfDyn extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.INSTANCE_OF_DYN,
      "instanceofDyn",
      [v],
      [[new FormatItem(OperandKind.SrcVReg, 8)]]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}
    
export class Debugger extends Intrinsic {
  constructor() {
    super(IRNodeKind.DEBUGGER, "debugger", [], []);
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}


/**
 * The instruction is used, when the input parameters of the Call operation are contained the SpreadElement.
 */
export class CallSpread extends Intrinsic {
  constructor(vs1: VReg, vs2: VReg, v3: VReg) {
    super(
      IRNodeKind.CALL_SPREAD,
      "callspreadDyn",
      [vs1, vs2, v3],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }
  
  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The instruction is used, when the input parameters of the New operation are contained the SpreadElement.
 */
export class NewobjSpread extends Intrinsic {
  constructor(vs1: VReg, vs2: VReg) {
    super(
      IRNodeKind.NEWOBJ_SPREAD,
      "newobjspreadDyn",
      [vs1, vs2],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The instruction is used, create one lexical environment, return one lexical env to acc.
 */
export class NewLexEnv extends Intrinsic {
  constructor(numVars: Imm) {
    super(
      IRNodeKind.NEWLEXENV_DYN,
      "newlexenvDyn",
      [numVars],
      [
        [new FormatItem(OperandKind.Imm, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The instruction is used, load env of current execute context to acc.
 */
export class LdLexEnv extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LDLEXENV_DYN,
      "ldlexenvDyn",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The instruction is used, store one variable to lexenv, no return.
 */
export class StLexVar extends Intrinsic {
  constructor(scopeId: Imm, slotId: Imm, value: VReg) {
    super(
      IRNodeKind.STLEXVARDYN,
      "StLexVarDyn",
      [scopeId, slotId, value],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

/**
 * The instruction is used to get unmapped arguments of the current function.
 */
export class GetUnmappedArgs extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.GETUNMAPPEDARGS,
      "getUnmappedArgs",
      [],
      [[]]
    );
  }
    resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The instruction is used, store one variable ref to lexenv.
 */
export class LdLexVar extends Intrinsic {
  constructor(level: Imm, slotId: Imm) {
    super(
      IRNodeKind.LDLEXVARDYN,
      "LdLexVarDyn",
      [level, slotId],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.Imm, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Toboolean extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.TOBOOLEAN,
      "toboolean",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * the pseudo instruction throw reference error if vs1 == hole
 */
export class ThrowUndefinedIfHole extends Intrinsic {
  constructor(vs1: VReg, vs2: VReg) {
    super(
      IRNodeKind.THROWUNDEFINEDIFHOLE,
      "throwUndefinedIfHole",
      [vs1, vs2],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class ThrowConstAssignment extends Intrinsic {
  constructor(vs1: VReg) {
    super(
      IRNodeKind.THROWCONSTASSIGNMENT,
      "throwConstAssignment",
      [vs1],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class ThrowThrowNotExists extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.THROWTHROWNOTEXISTS,
      "ThrowThrowNotExists",
      [],
      [
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class ThrowDeleteSuperProperty extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.THROWDELETESUPERPROPERTY,
      "ThrowDeleteSuperProperty",
      [],
      [
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

/**
 * The pseudo instruction calls the runtime to create a GeneratorFunction instance.
 * instance and bind it with code. The resulting instance will
 * be stored into the accumulator.
 */
export class DefineGeneratorfuncDyn extends Intrinsic {
  constructor(id: string, env: VReg) {
    super(
      IRNodeKind.DEFINE_GENERATOR_FUNC,
      "defineGeneratorFunc",
      [id, env],
      [
        [new FormatItem(OperandKind.Id, 32), new FormatItem(OperandKind.SrcVReg, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction calls the runtime to create a GeneratorObj instance.
 */
export class CreateGeneratorObjDyn extends Intrinsic {
  constructor(funcObj: VReg) {
    super(
      IRNodeKind.CREATE_GENERATOR_OBJ,
      "createGeneratorObj",
      [funcObj],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction calls the runtime to create a iterator instance instance by input para.
 */
export class CreateIterResultObjectDyn extends Intrinsic {
  constructor(value: VReg, done: VReg) {
    super(
      IRNodeKind.CREATE_ITERRESULT_OBJ,
      "createIterResultObj",
      [value, done],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction suspends execution of current generator function and returns the value yield expression created.
 */
export class SuspendGeneratorDyn extends Intrinsic {
  constructor(genObj: VReg, iterRslt: VReg) {
    super(
      IRNodeKind.SUSPEND_GENERATOR,
      "suspendGenerator",
      [genObj, iterRslt],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction resumes execution of current generator function when the consumer called .next.
 */
export class ResumeGeneratorDyn extends Intrinsic {
  constructor(genObj: VReg) {
    super(
      IRNodeKind.RESUME_GENERATOR,
      "resumeGenerator",
      [genObj],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction get resume mode, 0:return, 1:throw, 2: next.
 */
export class GetResumeModeDyn extends Intrinsic {
  constructor(genObj: VReg) {
    super(
      IRNodeKind.GET_RESUME_MODE,
      "getResumeMode",
      [genObj],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction defines the async function and returns the AsyncFunction instance.
 */
export class DefineAsyncFuncDyn extends Intrinsic {
  constructor(id: string, env: VReg) {
    super(
      IRNodeKind.DEFINE_ASYNC_FUNC,
      "defineAsyncFunc",
      [id, env],
      [
        [new FormatItem(OperandKind.Id, 32), new FormatItem(OperandKind.SrcVReg, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction inits execution environment and returns the AsyncFunctionObj instance.
 */
export class AsyncFunctionEnterDyn extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.ASYNC_FUNCTION_ENTER,
      "asyncFunctionEnter",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction waits the state of promise which the await expression returns
 * is changed to fulfilled.
 */
export class AsyncFunctionAwaitUncaughtDyn extends Intrinsic {
  constructor(asynFuncObj: VReg, value: VReg) {
    super(
      IRNodeKind.ASYNC_FUNCTION_AWAIT_UNCAUGHT,
      "asyncFunctionAwaitUncaught",
      [asynFuncObj, value],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction returns a resovled promise instance.
 */
export class AsyncFunctionResolveDyn extends Intrinsic {
  constructor(asynFuncObj: VReg, value: VReg, canSuspend: VReg) {
    super(
      IRNodeKind.ASYNC_FUNCTION_RESOLVE,
      "asyncFunctionResolve",
      [asynFuncObj, value, canSuspend],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction returns a rejected promise instance.
 */
export class AsyncFunctionRejectDyn extends Intrinsic {
  constructor(asynFuncObj: VReg, value: VReg, canSuspend: VReg) {
    super(
      IRNodeKind.ASYNC_FUNCTION_REJECT,
      "asyncFunctionReject",
      [asynFuncObj, value, canSuspend],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * This pseudo instruction load hole to acc.
 */
export class LdHole extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LDHOLE,
      "ldHole",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

/**
 * The pseudo instruction returns a template object.
 */
export class GetTemplateObject extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.GET_TEMPLATE_OBJECT,
      "getTemplateObject",
      [v],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
      );
    }
  
    resultType(): ResultType {
      return ResultType.Obj;
    }
  
    resultIn(): ResultDst {
      return ResultDst.Acc;
    }
}

/**
 * The pseudo instruction will create an Array by rest parameters.
 */
export class CopyRestArgs extends Intrinsic {
  constructor(index: Imm) {
    super(
      IRNodeKind.COPY_REST_ARGS,
      "copyrestargs",
      [index],
      [
        [new FormatItem(OperandKind.Imm, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class TryLdGlobalByName extends Intrinsic {
  constructor(name: string) {
    super(
      IRNodeKind.TRYLDGLOBALBYNAME,
      "TryLdGlobalByName",
      [name, new Imm(ResultType.Int, 0)],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16)]
      ]
    );
    this.slotSize = 1;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class TryStGlobalByName extends Intrinsic {
  constructor(key: string) {
    super(
      IRNodeKind.TRYSTGLOBALBYNAME,
      "TryStGlobalByName",
      [key, new Imm(ResultType.Int, 0)],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16)]
      ]
    );
    this.slotSize = 1;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class TryLdGlobalByValue extends Intrinsic {
  constructor(key: VReg) {
    super(
      IRNodeKind.TRYLDGLOBALBYVALUE,
      "tryLdGlobalByValue",
      [new Imm(ResultType.Int, 0), key],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 1;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class TryStGlobalByValue extends Intrinsic {
  constructor(key: VReg) {
    super(
      IRNodeKind.TRYSTGLOBALBYVALUE,
      "tryStGlobalByValue",
      [new Imm(ResultType.Int, 0), key],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 1;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdGlobalVar extends Intrinsic {
  constructor(key: string) {
    super(
      IRNodeKind.LDGLOBALVAR,
      "LdGlobalVar",
      [key, new Imm(ResultType.Int, 0)],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16)]
      ]
    );
    this.slotSize = 1;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StGlobalVar extends Intrinsic {
  constructor(key: string) {
    super(
      IRNodeKind.STGLOBALVAR,
      "StGlobalVar",
      [key, new Imm(ResultType.Int, 0)],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16)]
      ]
    );
    this.slotSize = 1;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdObjByName extends Intrinsic {
  constructor(key: string, obj: VReg) {
    super(
      IRNodeKind.LDOBJBYNAME,
      "LdObjByName",
      [key, new Imm(ResultType.Int, 0), obj],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StObjByName extends Intrinsic {
  constructor(key: string, obj: VReg) {
    super(
      IRNodeKind.STOBJBYNAME,
      "StObjByName",
      [key, new Imm(ResultType.Int, 0), obj],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdObjByIndex extends Intrinsic {
  constructor(obj: VReg, index: VReg) {
    super(
      IRNodeKind.LDOBJBYINDEX,
      "LdObjByIndex",
      [new Imm(ResultType.Int, 0), obj, index],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 32), new FormatItem(OperandKind.SrcVReg, 32)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }
  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StObjByIndex extends Intrinsic {
  constructor(obj: VReg, index: VReg) {
    super(
      IRNodeKind.STOBJBYINDEX,
      "StObjByIndex",
      [new Imm(ResultType.Int, 0), obj, index],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8),new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdObjByValue extends Intrinsic {
  constructor(v1: VReg, v2: VReg) {
    super(
      IRNodeKind.LDOBJBYVALUE,
      "ldObjByValue",
      [new Imm(ResultType.Int, 0), v1, v2],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StObjByValue extends Intrinsic {
  constructor(v1: VReg, v2: VReg) {
    super(
      IRNodeKind.STOBJBYVALUE,
      "stObjByValue",
      [new Imm(ResultType.Int, 0), v1, v2],
      [
        [new FormatItem(OperandKind.Imm, 16),new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class StOwnByName extends Intrinsic {
  constructor(key: string, obj: VReg) {
    super(
      IRNodeKind.STOWNBYNAME,
      "StOwnByName",
      [key, new Imm(ResultType.Int, 0), obj],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class StOwnByIndex extends Intrinsic {
  constructor(obj: VReg, index: VReg) {
    super(
      IRNodeKind.STOWNBYINDEX,
      "StOwnByIndex",
      [new Imm(ResultType.Int, 0), obj, index],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class StOwnByValue extends Intrinsic {
  constructor(obj: VReg, value: VReg) {
    super(
      IRNodeKind.STOWNBYVALUE,
      "StOwnByValue",
      [new Imm(ResultType.Int, 0), obj, value],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class Call0Dyn extends Intrinsic {
  constructor(func: VReg) {
    super(
      IRNodeKind.CALL0DYN,
      "Call0Dyn",
      [func],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Call1Dyn extends Intrinsic {
  constructor(func: VReg, arg: VReg) {
    super(
      IRNodeKind.CALL1DYN,
      "Call1Dyn",
      [func, arg],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Call2Dyn extends Intrinsic {
  constructor(func: VReg, arg0: VReg, arg1: VReg) {
    super(
      IRNodeKind.CALL2DYN,
      "Call2Dyn",
      [func, arg0, arg1],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class Call3Dyn extends Intrinsic {
  constructor(func: VReg, arg0: VReg, arg1: VReg, arg2: VReg) {
    super(
      IRNodeKind.CALL3DYN,
      "Call3Dyn",
      [func, arg0, arg1, arg2],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class CalliRangeDyn extends Intrinsic {
  constructor(length: Imm, args: VReg[]) {
    var ctors = [length, ...args];
    var operands:OperandType[] = [length];
    ctors.shift();
    while (!!(ctors && ctors.length)){
      let ctor = ctors.shift()
      if (ctor != undefined) {
        operands.push(ctor)
      }
    }
    super(
      IRNodeKind.CALLIRANGEDYN,
      "CalliRangeDyn",
      operands,
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class CalliThisRangeDyn extends Intrinsic {
  constructor(length: Imm, args: VReg[]) {
    var ctors = [length, ...args];
    var operands:OperandType[] = [length];
    ctors.shift();
    while (!!(ctors && ctors.length)){
      let ctor = ctors.shift()
      if (ctor != undefined) {
        operands.push(ctor)
      }
    }
    super(
      IRNodeKind.CALLITHISRANGEDYN,
      "CalliThisRangeDyn",
      operands,
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class NewObjDynRange extends Intrinsic {
  constructor(argNum: Imm, v: VReg[]) {
    var ctors = [argNum, ...v];
    var operands: OperandType[] = [argNum];
    ctors.shift();
    while (!!(ctors && ctors.length)) {
      let ctor = ctors.shift();
      if (ctor != undefined) {
        operands.push(ctor);
      }
    }
    super(
      IRNodeKind.NEWOBJDYNRANGE,
      "newobjDynrange",
      operands,
      [
        [new FormatItem(OperandKind.Imm, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    )
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class GetNextPropName extends Intrinsic {
  constructor(iter: VReg) {
    super(
      IRNodeKind.GETNEXTPROPNAME,
      "getnextpropname",
      [iter],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class ReturnUndefined extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.RETURNUNDEFINED,
      "ReturnUndefined",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class CreateEmptyObject extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.CREATEEMPTYOBJECT,
      "createemptyobject",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

// this pseudo uses ACC as one argument which stores Lexical Env
export class CreateObjectHavingMethod extends Intrinsic {
  constructor(index: Imm) {
    super(
      IRNodeKind.CREATEOBJECTHAVINGMETHOD,
      "createobjecthavingmethod",
      [index],
      [
        [new FormatItem(OperandKind.Imm, 32)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class CreateObjectWithBuffer extends Intrinsic {
  constructor(index: Imm) {
    super(
      IRNodeKind.CREATEOBJECTWITHBUFFER,
      "createobjectwithbuffer",
      [index],
      [
        [new FormatItem(OperandKind.Imm, 32)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class SetObjectWithProto extends Intrinsic {
  constructor(proto: VReg, obj: VReg) {
    super(
      IRNodeKind.SETOBJECTWITHPROTO,
      "setobjectwithproto",
      [proto, obj],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class CopyDataProperties extends Intrinsic {
  constructor(dstObj: VReg, srcObj: VReg) {
    super(
      IRNodeKind.COPYDATAPROPERTIES,
      "copydataproperties",
      [dstObj, srcObj],
      [
        [new FormatItem(OperandKind.SrcDstVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class DefineGetterSetterByValue extends Intrinsic {
  constructor(obj: VReg, name: VReg, getter: VReg, setter: VReg) {
    super(
      IRNodeKind.DEFINEGETTERSETTERBYVALUE,
      "definegettersetterbyvalue",
      [obj, name, getter, setter],
      [
        [new FormatItem(OperandKind.SrcDstVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    )
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class CreateEmptyArray extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.CREATEEMPTYARRAY,
      "createemptyarray",
      [],
      [
        []
      ]
    )
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class CreateArrayWithBuffer extends Intrinsic {
  constructor(index: Imm) {
    super(
      IRNodeKind.CREATEARRAYWITHBUFFER,
      "createarraywithbuffer",
      [index],
      [
        [new FormatItem(OperandKind.Imm, 32)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StArraySpread extends Intrinsic {
  constructor(array: VReg, index: VReg) {
    super(
      IRNodeKind.STARRAYSPREAD,
      "starrayspread",
      [array, index],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class ThrowIfNotObject extends Intrinsic {
  constructor(value: VReg) {
    super(
      IRNodeKind.THROWIFNOTOBJECT,
      "ThrowIfNotObject",
      [value],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class CreateObjectWithExcludedKeys extends Intrinsic {
  constructor(index: Imm, obj: VReg, args: VReg[]) {
    var ctors = [index, obj, ...args];
    var operands: OperandType[] = [index, obj];
    ctors.shift();
    ctors.shift();
    while (!!(ctors && ctors.length)) {
      let ctor = ctors.shift();
      if (ctor != undefined) {
        operands.push(ctor);
      }
    }
    super(
      IRNodeKind.CREATEOBJECTWITHEXCLUDEDKEYS,
      "CreateObjectWithExcludedKeys",
      operands,
      [
        [new FormatItem(OperandKind.Imm, 8), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class ThrowPatternNonCoercible extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.THROWPATTERNNONCOERCIBLE,
      "ThrowPatternNonCoercible",
      [],
      [[]]
    );
  }

  resultType(): ResultType {
    return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class GetIterator extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.GETITERATOR,
      "GetIterator",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class GetIteratorNext extends Intrinsic {
  constructor(iter: VReg, nextMethod: VReg) {
    super(
      IRNodeKind.GETITERATORNEXT,
      "GetIteratorNext",
      [iter, nextMethod],
      [
        [new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class DefineClassWithBuffer extends Intrinsic {
  constructor(id:string, idx:Imm, env: VReg, base:VReg) {
    super(
      IRNodeKind.DEFINECLASSWITHBUFFER,
      "DefineClassWithBuffer",
      [id, idx, env, base],
      [
        [new FormatItem(OperandKind.Id, 16), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }
  
  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class SuperCall extends Intrinsic {
  constructor(num:Imm, start:VReg) {
    super(
      IRNodeKind.SUPERCALL,
      "SuperCall",
      [num, start],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }
  
  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class SuperCallSpread extends Intrinsic {
  constructor(vs: VReg) {
    super(
      IRNodeKind.SUPERCALLSPREAD,
      "SuperCallSpread",
      [vs],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}
        
export class CloseIterator extends Intrinsic {
  constructor(iter: VReg) {
    super(
      IRNodeKind.CLOSEITERATOR,
      "CloseIterator",
      [iter],
      [
        [new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class DefineMethod extends Intrinsic {
  constructor(id: string, realname: VReg) {
    super(
      IRNodeKind.DEFINEMETHOD,
      "defineMethod",
      [id, realname],
      [
        [new FormatItem(OperandKind.Id, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
  }
  
  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdSuperByName extends Intrinsic {
  constructor(key: string, obj: VReg) {
    super(
      IRNodeKind.LDSUPERBYNAME,
      "LdSuperByName",
      [key, new Imm(ResultType.Int, 0), obj],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StSuperByName extends Intrinsic {
  constructor(key: string, obj: VReg) {
    super(
      IRNodeKind.STSUPERBYNAME,
      "StSuperByName",
      [key, new Imm(ResultType.Int, 0), obj],
      [
        [new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdSuperByValue extends Intrinsic {
  constructor(v1: VReg, v2: VReg) {
    super(
      IRNodeKind.LDSUPERBYVALUE,
      "LdSuperByValue",
      [new Imm(ResultType.Int, 0), v1, v2],
      [
        [new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StSuperByValue extends Intrinsic {
  constructor(v1: VReg, v2: VReg) {
    super(
      IRNodeKind.STSUPERBYVALUE,
      "StSuperByValue",
      [new Imm(ResultType.Int, 0), v1, v2],
      [
        [new FormatItem(OperandKind.Imm, 16),new FormatItem(OperandKind.SrcVReg, 8), new FormatItem(OperandKind.SrcVReg, 8)]
      ]
    );
    this.slotSize = 2;
  }

  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[0] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class ImportModule extends Intrinsic {
  constructor(name: string) {
    super(
      IRNodeKind.IMPORTMODULE,
      "ImportModule",
      [name],
      [[new FormatItem(OperandKind.StringId, 32)]]
    );
  }

  resultType(): ResultType {
      return ResultType.Obj;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class LdModvarByName extends Intrinsic {
  constructor(varName: string, module: VReg) {
    super(
      IRNodeKind.LDMODVARBYNAME,
      "LdModvarByName",
      [varName, new Imm(ResultType.Int, 0), module],
      [[new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16), new FormatItem(OperandKind.SrcVReg, 8)]]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class StModuleVar extends Intrinsic {
  constructor(varName: string) {
    super(
      IRNodeKind.STMODULEVAR,
      "StModuleVar",
      [varName, new Imm(ResultType.Int, 0)],
      [[new FormatItem(OperandKind.StringId, 32), new FormatItem(OperandKind.Imm, 16)]]
    );
    this.slotSize = 2;
  }

  // set slot offset, 0xff represent overflow, dont use ic for this instruction
  updateICOffset(base: number): number {
    let offset = this.validateIC(base, this.slotSize);
    this.operands[1] = new Imm(ResultType.Int, offset);
    return base + this.slotSize;
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class CopyModule extends Intrinsic {
  constructor(v: VReg) {
    super(
      IRNodeKind.COPYMODULE,
      "CopyModule",
      [v],
      [[new FormatItem(OperandKind.SrcVReg, 8)]]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class ThrowIfSuperNotCorrectCall extends Intrinsic {
  constructor(num: Imm) {
    super(
      IRNodeKind.THROWIFSUPERNOTCORRECTCALL,
      "ThrowIfSuperNotCorrectCall",
      [num],
      [
        [new FormatItem(OperandKind.Imm, 16)]
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.None;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

export class LdHomeObject extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.LDHOMEOBJECT,
      "LdHomeObject",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.Acc;
  }
}

export class PopLexEnv extends Intrinsic {
  constructor() {
    super(
      IRNodeKind.POPLEXENVDYN,
      "popLexenvDyn",
      [],
      [
        []
      ]
    );
  }

  resultType(): ResultType {
    return ResultType.Unknown;
  }

  resultIn(): ResultDst {
    return ResultDst.None;
  }
}

% def insn2node(insn)
%   mnemonic = insn.mnemonic.split('.')
%   return mnemonic.map{|el| el == '64' ? 'Wide' : el.capitalize}.join()
% end
%
% def get_result_type(insn)
%   if insn.mnemonic.start_with? "call"
%     return "ResultType.Unknown"
%   end
%   case insn.dtype
%   when 'i32'
%     return "ResultType.Int"
%   when 'i64', 'b64'
%     return "ResultType.Long"
%   when 'f64'
%     return "ResultType.Float"
%   when 'obj'
%     return "ResultType.Obj"
%   else
%     return "ResultType.None"
%   end
% end
%
% def get_result_dst(insn)
%   if insn.properties.include? "acc_write"
%     return "ResultDst.Acc"
%   end
%   dst_operands = insn.operands.select { |op| op.dst? }
%   if dst_operands.length > 0 and dst_operands[0].reg?
%     return "ResultDst.VReg"
%   end
%   return "ResultDst.None"
% end
%
% def is_VReg(name)
%     if name ==  :v
%        return true
%     end
% end
% 
% def is_Acc(name)
%    if name ==  :acc
%        return true
%     end
% end
% 
% def is_Imm(name)
%    if name ==  :imm
%        return true
%     end
% end
% 
% def is_Id(name)
%     if %i[method_id type_id field_id string_id literalarray_id callsite_id].include?(name)
%        return true
%     end
% end
%
% def is_Call(insn)
%   if insn.mnemonic.start_with? "call"
%      return true
%   end
%   return false
% end
%
% def is_CallRange(insn)
%   if insn.mnemonic == "call.range" or insn.mnemonic == "calli.dyn.range"
%      return true
%   end
%   return false
% end
%
% def get_operand_type(name, insn)
%   if is_VReg(name)
%     return "VReg"
%   elsif is_Imm(name)
%     is_jump = insn.properties.include? 'jump'
%     return is_jump ? "Label" : "Imm"
%   elsif is_Id(name)
%     return "string"
%   else
%     return nil
%   end
% end
%
% def get_operands(sig)
%     return [] unless sig.include? ' '
%     _, operands = sig.match(/(\S+) (.+)/).captures
%     operands = operands.split(', ')
%     end
%     
% def get_ctor_args(insn)
%     operands = get_operands(insn.sig)
%     ops = Array.new
%     ctor_args = Array.new
%     operands.map do |operand|
%     operand_parts = operand.split(':')
%       case operand_parts.size
%       when 1
%         name = operand_parts[0]
%       when 2
%         name, _ = operand_parts
%       when 3
%         name, _, _ = operand_parts
%       else
%         raise 'Unexpected operand string'
%       end 
%       ops.push(name)
%       name_tmp = name.to_s.gsub(/[0-9]/, '').to_sym
%       type = get_operand_type(name_tmp,insn)
%       if is_Call(insn) and !is_CallRange(insn) and is_VReg(name_tmp) and !insn.mnemonic.include?('acc')
%          ctor_args.push("#{name}?: #{type}")
%       else
%          ctor_args.push("#{name}: #{type}")
%       end
%     end
%     return ops,ctor_args
% end
%
% def get_operand_kind(op, insn)
%   if op.reg?
%     if op.src? and op.dst?
%       return "OperandKind.SrcDstVReg"
%     elsif op.src?
%       return "OperandKind.SrcVReg"
%     elsif op.dst?
%       return "OperandKind.DstVReg"
%     end
%     return nil
%   elsif op.imm?
%     is_jump = insn.properties.include? 'jump'
%     return is_jump ? "OperandKind.Label" : "OperandKind.Imm"
%  elsif op.id?
%    is_string_id = insn.properties.include? 'string_id'
%    return is_string_id ? "OperandKind.StringId" : "OperandKind.Id"
%  else
%    return nil
%  end
% end
%
% def make_format(fmt, insn)
%   operands = fmt.operands.map {|op| "new FormatItem(#{get_operand_kind(op, insn)}, #{op.width})"}
%   return "[" + operands.join(", ") + "]"
% end
%
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
% insn = group.first
% jump = insn.properties.include? 'jump'
% node_kind = get_node_kind(mnemonic)
% kind = "IRNodeKind." + node_kind
% ops_list,ctor_arg_list = get_ctor_args(insn)
% ctor_args = ctor_arg_list.map {|arg| "#{arg}"}.join(", ")
% ops = ops_list.map { |op| "#{op}"}.join(", ")
% formats = group.map {|i| make_format(i,insn) }
% result_type = get_result_type(insn)
% result_dst = get_result_dst(insn);
% is_call_op = is_Call(insn)
% is_callrange_op = is_CallRange(insn)
export class <%= insn2node(insn) %> extends IRNode {
% if is_callrange_op
  constructor(<%= ctor_arg_list[0] %>, <%= ctor_arg_list[1] %>[]) {
    var ctors = [<%=ops_list[0] %>, ...<%=ops_list[1] %>]
    var operands:OperandType[] = [<%=ops_list[0] %>]
    ctors.shift()
    while (!!(ctors && ctors.length)){
      let ctor = ctors.shift()
      if (ctor != undefined) {
        operands.push(ctor)
      }
    }
% elsif insn2node(insn) == "BuiltinR2i"
  constructor(<%= ctor_arg_list[0] %>, <%= ctor_arg_list[1] %>, <%= ctor_arg_list[2] %>[]) {
    var operands:OperandType[] = [<%=ops_list[0] %>, <%=ops_list[1] %>, ...<%=ops_list[2] %>]
% else
  constructor(<%= ctor_args %>) {
% if is_call_op and ops.length() != 0
    var ctors = [<%= ops %>]
    var operands:OperandType[] = [<%=ops_list[0] %>]
    ctors.shift()
    while (!!(ctors && ctors.length)){
      let ctor = ctors.shift()
      if (ctor != undefined) {
        operands.push(ctor)
      }
    }
% end
% end
    super(
      <%= kind %>,
      "<%= insn.mnemonic %>",
% if is_call_op or insn2node(insn) == "BuiltinR2i"
      operands,
% else
      [<%= ops %>],
% end
      [
        <%= formats.join(",\n        ") %>
      ]
    );
  }
  resultType(): ResultType {
    return <%= result_type %>;
  }
  resultIn(): ResultDst {
    return <%= result_dst %>;
  }
% if jump
% target_index = insn.operands.index {|op| op.imm? }
  getTarget(): Label {
    return <Label> this.operands[<%= target_index %>];
  }
% end
}
% end
