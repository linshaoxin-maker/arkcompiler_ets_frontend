/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import assert from 'assert';
export type callback<T> = () => T;
export type CallbackArray<T extends callback<T>> = () => T;
type t = () => t;
let a: CallbackArray<() => t>;
a = () => a;
assert(a() === a);
let h: number = 1;
typeof h;
type i = typeof h;
let j: i = 1;
assert(j === 1);
let c: [
    string,
    number,
    boolean
] = ["", 1, false];
assert(c[0] === "");
assert(c[1] === 1);
assert(c[2] === false);
type a = [
    number,
    string,
    ...number[]
];
let k: number | string = 1;
assert(k === 1);
let l: number & (string | number) = 1;
assert(l === 1);
type m = number;
type o = string;
function g<a3>(b3: a3 extends m ? m : o) { return b3; }
assert(g<number>(1) === 1);
type p<T> = T extends {
    a: infer U;
    b: infer U;
} ? U : never;
let x: p<{
    a: number;
    b: number;
}> = 1;
assert(x === 1);
let q: (string | number)[] = [1, 2];
assert(q[0] === 1);
assert(q[1] === 2);
interface u {
    name: string;
    a3: number;
}
type v = keyof u;
let b: v = "name";
assert(b === "name");
// Different grammar scenarios of indexedAccessType
type a1 = {
    b3: number;
    c3: string;
    d3: boolean;
};
type b1 = {
    e3: a1;
};
let c1: b1["e3"]["b3"] = 2;
assert(c1 === 2);
let m: a1["b3"] = 3;
let o: a1["c3"] = "test";
let d1: a1["d3"] = false;
assert(m === 3);
assert(o === "test");
assert(d1 === false);
let e1: a1["b3" | "c3"] = 4;
let f1: a1["b3" | "c3"] = "test";
assert(e1 === 4);
assert(f1 === "test");
let g1: b1["e3"]["b3" | "c3"] = 5;
let h1: b1["e3"]["b3" | "c3"] = "test";
assert(g1 === 5);
assert(h1 === "test");
let i1: a1[keyof b1["e3"]] = 6;
assert(i1 === 6);
const j1 = [
    { f3: "Alice", g3: 15 },
    { f3: "Bob", g3: 23 },
    { f3: "Eve", g3: 38 },
];
type l1 = (typeof j1)[1]["g3"];
let m1: l1 = 7;
assert(m1 === 7);
type n1 = [
    string,
    number
];
let o1: n1[0] = "test";
let q1: n1[1] = 9;
assert(o1 === "test");
assert(q1 === 9);
type s1<T extends any[]> = {
    [P in keyof T]: T[P];
};
let d: s1<number[]> = [1];
assert(d[0] === 1);
let t1: "cc" = "cc";
assert(t1 === "cc");
let u1: [
    prop1: string,
    prop2: number
] = ["1", 2];
assert(u1[0] === "1");
assert(u1[1] === 2);
// Defination of unionType
type v1 = "123" | "321";
type w1 = 1234 | 4321;
type z1 = "3124" | 4123;
type a2 = "U1234" | 2143;
type b2 = "U4213" | "U4132";
type c2 = "U3412" | "3421";
let d2: v1["1234"] = "1";
assert(d2 === "1");
let e2: v1[4321] = "2";
assert(e2 === "2");
let f2: b2[4321] = "3";
assert(f2 === "3");
let g2: b2["1234"] = "4";
assert(g2 === "4");
let h2: c2[4321] = "5";
assert(h2 === "5");
let i2: c2["1234"] = "6";
assert(i2 === "6");
// Define properties in type individually
type j2 = {
    "h3": number;
    i3: number;
    "j3": number;
    1324: number;
    [2143]: number;
    ["2314"]: number;
};
// Define properties in type and access them using indexedAccessType
type l2 = {
    "n3": number;
    o3: number;
    "q3": number;
    1243: number;
    [2134]: number;
    ["t3"]: number;
    // need to add in whitelist
    "3142": number;
    1432: number;
    [1423]: number;
    ["2314"]: number;
};
let m2: l2["n3"] = 1;
assert(m2 === 1);
let n2: l2["o3"] = 2;
assert(n2 === 2);
let o2: l2["q3"] = 3;
assert(o2 === 3);
let q2: l2[1243] = 4;
assert(q2 === 4);
let s2: l2[2134] = 5;
assert(s2 === 5);
let t2: l2["t3"] = 6;
assert(t2 === 6);
// need to add in whitelist
let u2: l2[3142] = 7;
assert(u2 === 7);
let v2: l2["1432"] = 8;
assert(v2 === 8);
let w2: l2["1423"] = 9;
assert(w2 === 9);
let z2: l2[2314] = 10;
assert(z2 === 10);
