/*
 * Copyright (c) 2024 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface es2panda_Impl {

    int version(); // I am not sure

    es2panda_Config_ptr CreateConfig(int argc, char_const_ptr_ptr argv);
    void DestroyConfig(es2panda_Config_ptr config);

    es2panda_Context_ptr CreateContextFromFile(es2panda_Config_ptr config, char_const_ptr source_file_name);
    es2panda_Context_ptr CreateContextFromString(es2panda_Config_ptr config, char_const_ptr source, char_const_ptr file_name);
    es2panda_Context_ptr ProceedToState(es2panda_Context_ptr context, es2panda_ContextState state);  // context is consumed
    void DestroyContext(es2panda_Context_ptr context);

    es2panda_ContextState ContextState(es2panda_Context_ptr context);
    char_const_ptr ContextErrorMessage(es2panda_Context_ptr context);

    es2panda_Program_ptr ContextProgram(es2panda_Context_ptr context);
    es2panda_AstNode_ptr ProgramAst(es2panda_Program_ptr program);
    es2panda_ExternalSource_ptr_ptr ProgramExternalSources(es2panda_Program_ptr program, size_t_ptr len_p);
    char_const_ptr ExternalSourceName(es2panda_ExternalSource_ptr e_source);
    es2panda_Program_ptr_ptr ExternalSourcePrograms(es2panda_ExternalSource_ptr e_source, size_t_ptr len_p);

    void AstNodeForEach(es2panda_AstNode_ptr ast, AstNodeForEachFunction func, void_ptr arg);

    bool SetNumberLiteralInt(es2panda_AstNode_ptr node, int32_t new_value);
    bool SetNumberLiteralLong(es2panda_AstNode_ptr node, int64_t new_value);
    bool SetNumberLiteralDouble(es2panda_AstNode_ptr node, double new_value);
    bool SetNumberLiteralFloat(es2panda_AstNode_ptr node, float new_value);


    void_ptr AllocMemory(es2panda_Context_ptr context, size_t numberOfElements, size_t sizeOfElement);



% Es2pandaLibApi::ast_nodes&.each do |ast_node|
% if ast_node != "AstNode" && ast_node != "TypeNode"
    bool Is<%= ast_node %>(es2panda_AstNode_ptr ast);
% end
% end

% Es2pandaLibApi::scopes&.each do |scope|
% if scope != "Scope"
    bool ScopeIs<%= scope %>(es2panda_Scope_ptr scope);
% end
% end

% Es2pandaLibApi::ast_types&.each do |type|
% if type != "Type"
    bool TypeIs<%= type %>(es2panda_Type_ptr type);
% end
% end

% Es2pandaLibApi::ast_variables&.each do |variable|
% if variable[1] != "Variable"
    bool VariableIs<%= variable[1] %>(es2panda_Variable_ptr variable);
% end
% end

    char_const_ptr AstNodeName(es2panda_AstNode_ptr ast);


% Es2pandaLibApi::classes&.each do |namespaceName, namespaceClasses|

% namespaceClasses&.each do |className, classData|
% classData.class_constructors&.each_with_index do |constructor, index|
    <%=
    Es2pandaLibApi::Arg.type_to_idl_str(classData.constructor_type().lib_type)
%>Create<%=
    className + constructor["overload"]
%>(es2panda_Context_ptr context<%=
    constructor["args"]&.map { |arg| if arg.lib_args_to_str.strip() != ""
     then ", " + arg.lib_args_to_idl_str end}&.join("")
%>);

% if classData.updater_allowed()
    <%=
    Es2pandaLibApi::Arg.type_to_idl_str(classData.constructor_type().lib_type)
%>Update<%=
    className + constructor["overload"]
%>(es2panda_Context_ptr context, es2panda_AstNode_ptr original<%=
    constructor["args"]&.map { |arg| if arg.lib_args_to_str.strip() != ""
     then ", " + arg.lib_args_to_idl_str end}&.join("")
%>);
% end   # Updater end
% end


% classData.class_methods&.each_with_index do |method_info, index|
    <%=
    Es2pandaLibApi::Arg.type_to_idl_str(method_info["return_type"].lib_type)
%> <%=
    className + method_info["overload_name"]
%>(es2panda_Context_ptr context<%=
    if classData.call_cast["call_var_str"]
        ", " + Es2pandaLibApi::Arg.arg_to_idl_str(classData.call_cast["call_var"])
    end
%><%=
    method_info["args"]&.map { |arg| if arg.lib_args_to_str.strip() != "" && arg.lib_args_to_str.strip() != "const"
    then ", " + arg.lib_args_to_idl_str end}&.join("")
%><%=
    method_info["return_arg_to_idl_str"]
%>);
% end

% end
% end

% Es2pandaLibApi::structs&.each do |structName, structData|
% structData.struct_getters&.each_with_index do |method_info, index|
    <%=
    method_info["return_type"].lib_type_to_idl_str
%><%=
    structName + method_info["name"]
%>(es2panda_Context_ptr context<%=
    if structData.call_cast["call_var_str"]
        Es2pandaLibApi::Arg.arg_to_idl_str(structData.call_cast["call"])
    end
%><%=
    method_info["return_type"].return_args_to_idl_str
%>);
% end   # getters end
% end   # structs end

};