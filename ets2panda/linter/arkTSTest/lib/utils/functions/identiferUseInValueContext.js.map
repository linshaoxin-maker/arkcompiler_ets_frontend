{"version":3,"file":"identiferUseInValueContext.js","names":["ts","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","isInstanceofContext","tsIdentStart","isBinaryExpression","parent","operatorToken","kind","SyntaxKind","InstanceOfKeyword","isNewExpressionContext","isNewExpression","expression","isQualifiedNameContext","tsIdentifier","isQualifiedName","right","isPropertyAccessContext","isPropertyAccessExpression","name","getQualifiedStart","ident","qualifiedStart","isEnumPropAccess","tsSym","context","isElementAccessExpression","flags","SymbolFlags","Enum","isValidParent","isTypeNode","isTypeOfExpression","isExpressionWithTypeArguments","isExportAssignment","isExportSpecifier","isMetaProperty","isImportClause","isClassLike","isInterfaceDeclaration","isModuleDeclaration","isEnumDeclaration","isNamespaceImport","isImportSpecifier","isImportEqualsDeclaration","identiferUseInValueContext","isValidUse"],"sources":["../../../../lib/utils/functions/identiferUseInValueContext.ts"],"sourcesContent":["/*\n * Copyright (c) 2022-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as ts from 'typescript';\n\nfunction isInstanceofContext(tsIdentStart: ts.Node): boolean {\n  return (\n    ts.isBinaryExpression(tsIdentStart.parent) &&\n    tsIdentStart.parent.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword\n  );\n}\n\nfunction isNewExpressionContext(tsIdentStart: ts.Node): boolean {\n  return ts.isNewExpression(tsIdentStart.parent) && tsIdentStart === tsIdentStart.parent.expression;\n}\n\n/*\n * If identifier is the right-most name of Property Access chain or Qualified name,\n * or it's a separate identifier expression, then identifier is being referenced as an value.\n */\nfunction isQualifiedNameContext(tsIdentStart: ts.Node, tsIdentifier: ts.Identifier): boolean {\n  // rightmost in AST is rightmost in qualified name chain\n  return ts.isQualifiedName(tsIdentStart) && tsIdentifier !== tsIdentStart.right;\n}\n\nfunction isPropertyAccessContext(tsIdentStart: ts.Node, tsIdentifier: ts.Identifier): boolean {\n  // rightmost in AST is rightmost in qualified name chain\n  return ts.isPropertyAccessExpression(tsIdentStart) && tsIdentifier !== tsIdentStart.name;\n}\n\nfunction getQualifiedStart(ident: ts.Node): ts.Node {\n  let qualifiedStart: ts.Node = ident;\n  while (ts.isPropertyAccessExpression(qualifiedStart.parent) || ts.isQualifiedName(qualifiedStart.parent)) {\n    qualifiedStart = qualifiedStart.parent;\n  }\n  return qualifiedStart;\n}\n\nfunction isEnumPropAccess(ident: ts.Identifier, tsSym: ts.Symbol, context: ts.Node): boolean {\n  return (\n    ts.isElementAccessExpression(context) &&\n    !!(tsSym.flags & ts.SymbolFlags.Enum) &&\n    (context.expression === ident ||\n      ts.isPropertyAccessExpression(context.expression) && context.expression.name === ident)\n  );\n}\n\nfunction isValidParent(parent: ts.Node): boolean {\n  // treat TypeQuery as valid because it's already forbidden (FaultID.TypeQuery)\n  return (\n    ts.isTypeNode(parent) && !ts.isTypeOfExpression(parent) ||\n    ts.isExpressionWithTypeArguments(parent) ||\n    ts.isExportAssignment(parent) ||\n    ts.isExportSpecifier(parent) ||\n    ts.isMetaProperty(parent) ||\n    ts.isImportClause(parent) ||\n    ts.isClassLike(parent) ||\n    ts.isInterfaceDeclaration(parent) ||\n    ts.isModuleDeclaration(parent) ||\n    ts.isEnumDeclaration(parent) ||\n    ts.isNamespaceImport(parent) ||\n    ts.isImportSpecifier(parent) ||\n    ts.isImportEqualsDeclaration(parent)\n  );\n}\n\nexport function identiferUseInValueContext(ident: ts.Identifier, tsSym: ts.Symbol): boolean {\n  const qualifiedStart = getQualifiedStart(ident);\n  const parent = qualifiedStart.parent;\n  const isValidUse =\n    isValidParent(parent) ||\n    isEnumPropAccess(ident, tsSym, parent) ||\n    isQualifiedNameContext(qualifiedStart, ident) ||\n    isPropertyAccessContext(qualifiedStart, ident) ||\n    isNewExpressionContext(qualifiedStart) ||\n    isInstanceofContext(qualifiedStart);\n  return !isValidUse;\n}\n"],"mappings":"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","ignoreList":[]}