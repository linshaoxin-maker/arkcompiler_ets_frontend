{"version":3,"file":"TsUtils.js","names":["path","_interopRequireWildcard","require","ts","_Problems","_ArktsIgnorePaths","_ESObject","_SendableAPI","_SharedModuleAPI","_StandardLibraries","_SupportedDetsIndexableTypes","_TypedArrays","_ForEachNodeInSubtree","_GetScriptKind","_IsStdLibrary","_IsStruct","_PathHelper","_isAssignmentOperator","_isIntrinsicObjectType","_TsUtils","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_newArrowCheck","TypeError","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","String","Number","SYMBOL","exports","SYMBOL_CONSTRUCTOR","ITERATOR","TsUtils","constructor","tsTypeChecker","testMode","advancedClassChecks","useRtLogic","Map","entityNameToString","name","isIdentifier","escapedText","toString","left","right","isNumberLikeType","tsType","isUnion","tsCompType","types","flags","TypeFlags","NumberLike","getFlags","isBooleanLikeType","BooleanLike","isDestructuringAssignmentLHS","tsExpr","tsParent","parent","tsCurrentExpr","isBinaryExpression","isAssignmentOperator","operatorToken","isForStatement","isForInStatement","isForOfStatement","initializer","isEnumType","isEnumSymbol","symbol","isEnum","Enum","EnumLiteral","tsSymbol","SymbolFlags","hasModifier","tsModifiers","tsModifierKind","tsModifier","kind","unwrapParenthesized","unwrappedExpr","isParenthesizedExpression","expression","followIfAliased","sym","Alias","getAliasedSymbol","trueSymbolAtLocation","node","cache","trueSymbolAtLocationCache","val","undefined","getSymbolAtLocation","isTypeDeclSyntaxKind","isStructDeclarationKind","SyntaxKind","EnumDeclaration","ClassDeclaration","InterfaceDeclaration","TypeAliasDeclaration","symbolHasDuplicateName","tsDeclKind","symbolDecls","getDeclarations","symDecl","declKind","isNamespaceTypeCollision","ModuleDeclaration","Identifier","isPrimitiveType","type","f","Boolean","BooleanLiteral","NumberLiteral","isTypeSymbol","Class","Interface","isGenericArrayType","isTypeReference","typeArguments","length","target","typeParameters","getSymbol","getName","isReadonlyArrayType","isTypedArray","getFullyQualifiedName","isGlobalSymbol","TYPED_ARRAYS","includes","isArray","isTuple","objectFlags","ObjectFlags","Tuple","isOrDerivedFrom","checkType","checkedBaseTypes","reduceReference","declarations","Set","add","tsTypeDecl","isClassOrInterfaceDecl","isClassDeclaration","isInterfaceDeclaration","isDerived","heritageClauses","heritageClause","processParentTypesCheck","Reference","isPrototypeSymbol","Prototype","isFunctionSymbol","Function","isInterfaceType","isAnyType","Any","isUnknownType","Unknown","isUnsupportedType","Intersection","isNullableUnionType","Undefined","Null","isMethodAssignment","Method","Assignment","getDeclaration","isVarDeclaration","tsDecl","isVariableDeclaration","isVariableDeclarationList","isValidEnumMemberInit","isNumberConstantValue","isStringConstantValue","isCompileTimeExpression","isCompileTimeExpressionHandlePropertyAccess","isPropertyAccessExpression","propertyAccess","leftHandSymbol","decls","isEnumDeclaration","isAsExpression","NumberKeyword","PrefixUnaryExpression","isPrefixUnaryExprValidEnumMemberInit","ParenthesizedExpression","BinaryExpression","isBinaryExprValidEnumMemberInit","ConditionalExpression","isConditionalExprValidEnumMemberInit","isIdentifierValidEnumMemberInit","NumericLiteral","StringLiteral","PropertyAccessExpression","isUnaryOpAllowedForEnumMemberInit","operator","operand","isBinaryOpAllowedForEnumMemberInit","whenTrue","whenFalse","isConst","EnumMember","tsPrefixUnaryOp","PlusToken","MinusToken","TildeToken","tsBinaryOp","AsteriskToken","SlashToken","PercentToken","LessThanLessThanToken","GreaterThanGreaterThanToken","BarBarToken","GreaterThanGreaterThanGreaterThanToken","AmpersandToken","CaretToken","BarToken","AmpersandAmpersandToken","tsNode","getCombinedNodeFlags","NodeFlags","Const","tsConstValue","getText","getConstantValue","isIntegerConstantValue","toFixed","relatedByInheritanceOrIdentical","typeA","typeB","isObject","isBISendable","isISendableInterface","typeADecl","hasSendableDecorator","processInterfaces","isClass","token","ExtendsKeyword","processParentTypes","needToDeduceStructuralIdentityHandleUnions","lhsType","rhsType","rhsExpr","compType","needToDeduceStructuralIdentity","getNonNullableType","isLibraryType","isDynamicObjectAssignedToStdType","areCompatibleFunctionals","isClassValueType","isObjectType","isClassOrInterface","parentTypes","baseTypeExpr","baseType","getTypeAtLocation","typeToTypeNode","ObjectKeyword","isCallToFunctionWithOmittedReturnType","isCallExpression","tsCallSignature","getResolvedSignature","tsSignDecl","hasReadonlyFields","_this","members","result","forEach","isPropertyDeclaration","propmMods","getModifiers","ReadonlyKeyword","bind","hasDefaultCtor","_this2","hasCtor","Constructor","declCtor","parameters","isAbstractClass","declClass","classMods","AbstractKeyword","validateObjectLiteralType","hasMethods","properties","getPropertiesOfType","prop","findProperty","checkTypeSet","typeSet","predicate","isUnionOrIntersection","elemType","isObjectLiteralAssignableToUnion","isObjectLiteralAssignable","isStdPartialType","isStdRequiredType","isStdReadonlyType","aliasTypeArguments","isStdRecordType","validateRecordObjectKeys","validateFields","isStdLibraryType","rhsSym","getSymbolOfCallExpression","isLibrarySymbol","objectType","objectLiteral","isPropertyAssignment","validateField","getPropertySymbol","propNameSymbol","propName","symbolName","isMemberName","idText","propSym","propType","getTypeOfSymbolAtLocation","initExpr","isObjectLiteralExpression","isValidComputedProperty","isComputedPropertyName","isValidComputedPropertyName","isStringLiteral","isNumericLiteral","isSupportedTypeNodeKind","AnyKeyword","UnknownKeyword","SymbolKeyword","IndexedAccessType","ConditionalType","MappedType","InferType","isSupportedTypeHandleUnionTypeNode","typeNode","unionTypeElem","isSupportedType","isSupportedTypeHandleTupleTypeNode","elem","elements","isTypeNode","isNamedTupleMember","isParenthesizedTypeNode","isArrayTypeNode","elementType","isTypeReferenceNode","typeArg","isUnionTypeNode","isTupleTypeNode","isTypeLiteralNode","isTypeQueryNode","isIntersectionTypeNode","isStructObjectInitializer","isCallLikeExpression","signature","signDecl","declaration","isConstructorDeclaration","isStructDeclaration","getParentSymbolName","dotPosition","lastIndexOf","substring","parentName","isSymbolAPI","escapedName","isSymbolIterator","parName","isDefaultImport","importSpec","propertyName","text","getStartPos","nodeOrComment","SingleLineCommentTrivia","MultiLineCommentTrivia","pos","getStart","getEndPos","end","getEnd","getHighlightRange","faultId","highlightRangeHandlers","getKeywordHighlightRange","keyword","start","getVarDeclarationHighlightRange","getCatchWithUnsupportedTypeHighlightRange","catchClauseNode","variableDeclaration","getForInStatementHighlightRange","getWithStatementHighlightRange","statement","getDeleteOperatorHighlightRange","getTypeQueryHighlightRange","getInstanceofUnsupportedHighlightRange","getConstAssertionHighlightRange","AsExpression","getLimitedReturnTypeInferenceHighlightRange","FunctionExpression","FunctionDeclaration","MethodDeclaration","getLocalFunctionHighlightRange","getFunctionApplyCallHighlightRange","pointPos","getDeclWithDuplicateNameHighlightRange","nameNode","getObjectLiteralNoContextTypeHighlightRange","getClassExpressionHighlightRange","getMultipleStaticBlocksHighlightRange","getParameterPropertiesHighlightRange","params","getObjectTypeLiteralHighlightRange","getSendableDefiniteAssignmentHighlightRange","exclamationToken","aliasSymbol","isStdErrorType","nonNullableType","componentType","hasLibraryType","_this3","srcFile","getSourceFile","fileName","ext","extname","toLowerCase","isThirdPartyCode","ARKTS_IGNORE_DIRS","some","ignore","pathContainsDirectory","normalize","ARKTS_IGNORE_FILES","basename","isEts","isTs","isDeclarationFile","isStatic","isStdLib","STANDARD_LIBRARIES","isDynamicType","isDynamic","isIntrinsicObjectType","isAnonymous","Anonymous","isDynamicLiteralInitializerHandleCallExpression","callExpr","isDynamicLiteralInitializer","expr","isArrayLiteralExpression","curNode","exprType","getContextualType","res","binExpr","propAccessExpr","isEsObjectType","typeName","ES_OBJECT","isInsideBlock","par","isBlock","isEsObjectPossiblyAllowed","typeRef","isValueAssignableToESObject","valueType","isAnonymousType","getVariableDeclarationTypeNode","getSymbolDeclarationTypeNode","decl","hasEsObjectType","symbolHasEsObjectType","isEsObjectSymbol","isTypeAliasDeclaration","isClassObjectExpression","isClassTypeExrepssion","isFunctionCalledRecursively","funcExpr","_this4","found","callback","callSym","stopCondition","forEachNodeInSubtree","getTypeOrTypeConstraintAtLocation","isTypeParameter","constraint","getConstraint","isStdFunctionType","isFunctionalType","callSigns","getCallSignatures","isStdBigIntType","isStdNumberType","isStdBooleanType","isEnumStringLiteral","isEnumMember","isStringEnumLiteral","computedProperty","isRecordObjectInitializer","isStringLiteralLike","skipPropertyInferredTypeCheck","sourceFile","isEtsFileCb","_this5","getScriptKind","ScriptKind","ETS","modifiers","m","PrivateKeyword","hasAccessModifier","PublicKeyword","ProtectedKeyword","getModifier","modifierKind","_this6","find","x","getAccessModifier","getBaseClassType","baseTypes","getBaseTypes","destructuringAssignmentHasSpreadOperator","_this7","isSpreadElement","isSpreadAssignment","destructuringDeclarationHasSpreadOperator","_this8","isBindingElement","dotDotDotToken","isArrayBindingPattern","isObjectBindingPattern","hasNestedObjectDestructuring","_this9","getDecoratorName","decorator","decoratorName","unwrapParenthesizedTypeNode","unwrappedTypeNode","isSendableTypeNode","_this10","every","TypeAlias","typeDecl","isConstEnum","isSendableType","getTypeFromTypeNode","BigInt","TypeParameter","isSendableClassOrInterface","isShareableType","_this11","targetType","typeContainsSendableClassOrInterface","_this12","Union","ConstEnum","isSendableUnionType","_this13","_this14","decorators","getDecorators","SENDABLE_DECORATOR","getNonSendableDecorators","_this15","filter","getDecoratorsIfInSendableClass","classNode","getClassNodeFromDeclaration","Parameter","isArkTSISendableDeclaration","ISENDABLE_TYPE","isModuleBlock","LANG_NAMESPACE","ARKTS_LANG_D_ETS","isAllowedIndexSignature","paramType","isArkTSCollectionsArrayLikeDeclaration","isArkTSCollectionsArrayLikeType","getNumberIndexType","COLLECTIONS_NAMESPACE","ARKTS_COLLECTIONS_D_ETS","proceedConstructorDeclaration","isFromPrivateIdentifierOrSdk","targetMember","classMember","isFromPrivateIdentifier","_this16","isPrivateIdentifierDuplicateOfIdentifier","proceedClassType","classType","baseDecl","valueDeclaration","classMemberHasDuplicateName","tsClassLikeDecl","isIdentifierOrPrivateIdentifier","constructorDeclarationProceedResult","proceedClassTypeResult","isPrivateIdentifier","ident1","ident2","findIdentifierNameForSymbol","getIdentifierNameFromString","parentType","getTypeByProperty","str","offset","codePoint","codePointAt","charSize","isIdentifierStart","isIdentifierPart","charAt","propDecl","isPropertySignature","isPropertyOfInternalClassOrInterface","ExportKeyword","NonPrimitive","isStringType","isStdMapType","hasGenericTypeParameter","_this17","typeArgs","getTypeArguments","getEnclosingTopLevelStatement","_this18","findAncestor","ancestor","isSourceFile","isDeclarationStatement","StructDeclaration","MissingDeclaration","ImportEqualsDeclaration","ImportDeclaration","NamespaceExportDeclaration","declarationNameExists","_this19","statements","stmt","_this20","isImportDeclaration","importClause","namedBindings","isNamespaceImport","generateUniqueName","nameGenerator","newName","isSharedModule","isExpressionStatement","USE_SHARED","getDeclarationNode","isFunctionLikeDeclaration","isFunctionDeclaration","isMethodDeclaration","isGetAccessorDeclaration","isSetAccessorDeclaration","isFunctionExpression","isArrowFunction","isShareableEntity","isSendableClassOrInterfaceEntity","isInImportWhiteList","resolvedModule","resolvedFileName","isClassNodeReference","_this21","isClassNode","FaultID","VarDeclaration","CatchWithUnsupportedType","ForInStatement","WithStatement","DeleteOperator","TypeQuery","InstanceofUnsupported","ConstAssertion","LimitedReturnTypeInference","LocalFunction","FunctionBind","FunctionApplyCall","DeclWithDuplicateName","ObjectLiteralNoContextType","ClassExpression","MultipleStaticBlocks","ParameterProperties","SendableDefiniteAssignment","ObjectTypeLiteral"],"sources":["../../../lib/utils/TsUtils.ts"],"sourcesContent":["/*\n * Copyright (c) 2022-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as path from 'node:path';\nimport * as ts from 'typescript';\nimport type { IsEtsFileCallback } from '../IsEtsFileCallback';\nimport { FaultID } from '../Problems';\nimport { ARKTS_IGNORE_DIRS, ARKTS_IGNORE_FILES } from './consts/ArktsIgnorePaths';\nimport { ES_OBJECT } from './consts/ESObject';\nimport { SENDABLE_DECORATOR } from './consts/SendableAPI';\nimport { USE_SHARED } from './consts/SharedModuleAPI';\nimport { STANDARD_LIBRARIES } from './consts/StandardLibraries';\nimport {\n  ARKTS_COLLECTIONS_D_ETS,\n  ARKTS_LANG_D_ETS,\n  COLLECTIONS_NAMESPACE,\n  ISENDABLE_TYPE,\n  LANG_NAMESPACE\n} from './consts/SupportedDetsIndexableTypes';\nimport { TYPED_ARRAYS } from './consts/TypedArrays';\nimport { forEachNodeInSubtree } from './functions/ForEachNodeInSubtree';\nimport { getScriptKind } from './functions/GetScriptKind';\nimport { isStdLibraryType } from './functions/IsStdLibrary';\nimport { isStructDeclaration, isStructDeclarationKind } from './functions/IsStruct';\nimport type { NameGenerator } from './functions/NameGenerator';\nimport { pathContainsDirectory } from './functions/PathHelper';\nimport { isAssignmentOperator } from './functions/isAssignmentOperator';\nimport { isIntrinsicObjectType } from './functions/isIntrinsicObjectType';\n\nexport const SYMBOL = 'Symbol';\nexport const SYMBOL_CONSTRUCTOR = 'SymbolConstructor';\nconst ITERATOR = 'iterator';\n\nexport type CheckType = (this: TsUtils, t: ts.Type) => boolean;\nexport class TsUtils {\n  constructor(\n    private readonly tsTypeChecker: ts.TypeChecker,\n    private readonly testMode: boolean,\n    private readonly advancedClassChecks: boolean,\n    private readonly useRtLogic: boolean\n  ) {}\n\n  entityNameToString(name: ts.EntityName): string {\n    if (ts.isIdentifier(name)) {\n      return name.escapedText.toString();\n    }\n    return this.entityNameToString(name.left) + this.entityNameToString(name.right);\n  }\n\n  isNumberLikeType(tsType: ts.Type): boolean {\n    if (this.useRtLogic && tsType.isUnion()) {\n      for (const tsCompType of tsType.types) {\n        if ((tsCompType.flags & ts.TypeFlags.NumberLike) === 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return (tsType.getFlags() & ts.TypeFlags.NumberLike) !== 0;\n  }\n\n  static isBooleanLikeType(tsType: ts.Type): boolean {\n    return (tsType.getFlags() & ts.TypeFlags.BooleanLike) !== 0;\n  }\n\n  static isDestructuringAssignmentLHS(tsExpr: ts.ArrayLiteralExpression | ts.ObjectLiteralExpression): boolean {\n\n    /*\n     * Check whether given expression is the LHS part of the destructuring\n     * assignment (or is a nested element of destructuring pattern).\n     */\n    let tsParent = tsExpr.parent;\n    let tsCurrentExpr: ts.Node = tsExpr;\n    while (tsParent) {\n      if (\n        ts.isBinaryExpression(tsParent) &&\n        isAssignmentOperator(tsParent.operatorToken) &&\n        tsParent.left === tsCurrentExpr\n      ) {\n        return true;\n      }\n\n      if (\n        (ts.isForStatement(tsParent) || ts.isForInStatement(tsParent) || ts.isForOfStatement(tsParent)) &&\n        tsParent.initializer &&\n        tsParent.initializer === tsCurrentExpr\n      ) {\n        return true;\n      }\n\n      tsCurrentExpr = tsParent;\n      tsParent = tsParent.parent;\n    }\n\n    return false;\n  }\n\n  static isEnumType(tsType: ts.Type): boolean {\n    // when type equals `typeof <Enum>`, only symbol contains information about it's type.\n    const isEnumSymbol = tsType.symbol && this.isEnum(tsType.symbol);\n    // otherwise, we should analyze flags of the type itself\n    const isEnumType = !!(tsType.flags & ts.TypeFlags.Enum) || !!(tsType.flags & ts.TypeFlags.EnumLiteral);\n    return isEnumSymbol || isEnumType;\n  }\n\n  static isEnum(tsSymbol: ts.Symbol): boolean {\n    return !!(tsSymbol.flags & ts.SymbolFlags.Enum);\n  }\n\n  static hasModifier(tsModifiers: readonly ts.Modifier[] | undefined, tsModifierKind: number): boolean {\n    if (!tsModifiers) {\n      return false;\n    }\n\n    for (const tsModifier of tsModifiers) {\n      if (tsModifier.kind === tsModifierKind) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static unwrapParenthesized(tsExpr: ts.Expression): ts.Expression {\n    let unwrappedExpr = tsExpr;\n    while (ts.isParenthesizedExpression(unwrappedExpr)) {\n      unwrappedExpr = unwrappedExpr.expression;\n    }\n\n    return unwrappedExpr;\n  }\n\n  followIfAliased(sym: ts.Symbol): ts.Symbol {\n    if ((sym.getFlags() & ts.SymbolFlags.Alias) !== 0) {\n      return this.tsTypeChecker.getAliasedSymbol(sym);\n    }\n    return sym;\n  }\n\n  private readonly trueSymbolAtLocationCache = new Map<ts.Node, ts.Symbol | null>();\n\n  trueSymbolAtLocation(node: ts.Node): ts.Symbol | undefined {\n    const cache = this.trueSymbolAtLocationCache;\n    const val = cache.get(node);\n    if (val !== undefined) {\n      return val !== null ? val : undefined;\n    }\n    let sym = this.tsTypeChecker.getSymbolAtLocation(node);\n    if (sym === undefined) {\n      cache.set(node, null);\n      return undefined;\n    }\n    sym = this.followIfAliased(sym);\n    cache.set(node, sym);\n    return sym;\n  }\n\n  private static isTypeDeclSyntaxKind(kind: ts.SyntaxKind): boolean {\n    return (\n      isStructDeclarationKind(kind) ||\n      kind === ts.SyntaxKind.EnumDeclaration ||\n      kind === ts.SyntaxKind.ClassDeclaration ||\n      kind === ts.SyntaxKind.InterfaceDeclaration ||\n      kind === ts.SyntaxKind.TypeAliasDeclaration\n    );\n  }\n\n  static symbolHasDuplicateName(symbol: ts.Symbol, tsDeclKind: ts.SyntaxKind): boolean {\n\n    /*\n     * Type Checker merges all declarations with the same name in one scope into one symbol.\n     * Thus, check whether the symbol of certain declaration has any declaration with\n     * different syntax kind.\n     */\n    const symbolDecls = symbol?.getDeclarations();\n    if (symbolDecls) {\n      for (const symDecl of symbolDecls) {\n        const declKind = symDecl.kind;\n        // we relax arkts-unique-names for namespace collision with class/interface/enum/type/struct\n        const isNamespaceTypeCollision =\n          TsUtils.isTypeDeclSyntaxKind(declKind) && tsDeclKind === ts.SyntaxKind.ModuleDeclaration ||\n          TsUtils.isTypeDeclSyntaxKind(tsDeclKind) && declKind === ts.SyntaxKind.ModuleDeclaration;\n\n        /*\n         * Don't count declarations with 'Identifier' syntax kind as those\n         * usually depict declaring an object's property through assignment.\n         */\n        if (declKind !== ts.SyntaxKind.Identifier && declKind !== tsDeclKind && !isNamespaceTypeCollision) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  static isPrimitiveType(type: ts.Type): boolean {\n    const f = type.getFlags();\n    return (\n      (f & ts.TypeFlags.Boolean) !== 0 ||\n      (f & ts.TypeFlags.BooleanLiteral) !== 0 ||\n      (f & ts.TypeFlags.Number) !== 0 ||\n      (f & ts.TypeFlags.NumberLiteral) !== 0\n\n    /*\n     *  In ArkTS 'string' is not a primitive type. So for the common subset 'string'\n     *  should be considered as a reference type. That is why next line is commented out.\n     * (f & ts.TypeFlags.String) != 0 || (f & ts.TypeFlags.StringLiteral) != 0\n     */\n    );\n  }\n\n  static isTypeSymbol(symbol: ts.Symbol | undefined): boolean {\n    return (\n      !!symbol &&\n      !!symbol.flags &&\n      ((symbol.flags & ts.SymbolFlags.Class) !== 0 || (symbol.flags & ts.SymbolFlags.Interface) !== 0)\n    );\n  }\n\n  // Check whether type is generic 'Array<T>' type defined in TypeScript standard library.\n  static isGenericArrayType(tsType: ts.Type): tsType is ts.TypeReference {\n    return (\n      TsUtils.isTypeReference(tsType) &&\n      tsType.typeArguments?.length === 1 &&\n      tsType.target.typeParameters?.length === 1 &&\n      tsType.getSymbol()?.getName() === 'Array'\n    );\n  }\n\n  static isReadonlyArrayType(tsType: ts.Type): boolean {\n    return (\n      TsUtils.isTypeReference(tsType) &&\n      tsType.typeArguments?.length === 1 &&\n      tsType.target.typeParameters?.length === 1 &&\n      tsType.getSymbol()?.getName() === 'ReadonlyArray'\n    );\n  }\n\n  isTypedArray(tsType: ts.Type): boolean {\n    const symbol = tsType.symbol;\n    if (!symbol) {\n      return false;\n    }\n    const name = this.tsTypeChecker.getFullyQualifiedName(symbol);\n    return this.isGlobalSymbol(symbol) && TYPED_ARRAYS.includes(name);\n  }\n\n  isArray(tsType: ts.Type): boolean {\n    return TsUtils.isGenericArrayType(tsType) || TsUtils.isReadonlyArrayType(tsType) || this.isTypedArray(tsType);\n  }\n\n  static isTuple(tsType: ts.Type): boolean {\n    return TsUtils.isTypeReference(tsType) && !!(tsType.objectFlags & ts.ObjectFlags.Tuple);\n  }\n\n  // does something similar to relatedByInheritanceOrIdentical function\n  isOrDerivedFrom(tsType: ts.Type, checkType: CheckType, checkedBaseTypes?: Set<ts.Type>): boolean {\n    tsType = TsUtils.reduceReference(tsType);\n\n    if (checkType.call(this, tsType)) {\n      return true;\n    }\n\n    if (!tsType.symbol?.declarations) {\n      return false;\n    }\n\n    // Avoid type recursion in heritage by caching checked types.\n    (checkedBaseTypes = checkedBaseTypes || new Set<ts.Type>()).add(tsType);\n\n    for (const tsTypeDecl of tsType.symbol.declarations) {\n      const isClassOrInterfaceDecl = ts.isClassDeclaration(tsTypeDecl) || ts.isInterfaceDeclaration(tsTypeDecl);\n      const isDerived = isClassOrInterfaceDecl && !!tsTypeDecl.heritageClauses;\n      if (!isDerived) {\n        continue;\n      }\n      for (const heritageClause of tsTypeDecl.heritageClauses) {\n        if (this.processParentTypesCheck(heritageClause.types, checkType, checkedBaseTypes)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  static isTypeReference(tsType: ts.Type): tsType is ts.TypeReference {\n    return (\n      (tsType.getFlags() & ts.TypeFlags.Object) !== 0 &&\n      ((tsType as ts.ObjectType).objectFlags & ts.ObjectFlags.Reference) !== 0\n    );\n  }\n\n  static isPrototypeSymbol(symbol: ts.Symbol | undefined): boolean {\n    return !!symbol && !!symbol.flags && (symbol.flags & ts.SymbolFlags.Prototype) !== 0;\n  }\n\n  static isFunctionSymbol(symbol: ts.Symbol | undefined): boolean {\n    return !!symbol && !!symbol.flags && (symbol.flags & ts.SymbolFlags.Function) !== 0;\n  }\n\n  static isInterfaceType(tsType: ts.Type | undefined): boolean {\n    return (\n      !!tsType && !!tsType.symbol && !!tsType.symbol.flags && (tsType.symbol.flags & ts.SymbolFlags.Interface) !== 0\n    );\n  }\n\n  static isAnyType(tsType: ts.Type): tsType is ts.TypeReference {\n    return (tsType.getFlags() & ts.TypeFlags.Any) !== 0;\n  }\n\n  static isUnknownType(tsType: ts.Type): boolean {\n    return (tsType.getFlags() & ts.TypeFlags.Unknown) !== 0;\n  }\n\n  static isUnsupportedType(tsType: ts.Type): boolean {\n    return (\n      !!tsType.flags &&\n      ((tsType.flags & ts.TypeFlags.Any) !== 0 ||\n        (tsType.flags & ts.TypeFlags.Unknown) !== 0 ||\n        (tsType.flags & ts.TypeFlags.Intersection) !== 0)\n    );\n  }\n\n  static isNullableUnionType(type: ts.Type): boolean {\n    if (type.isUnion()) {\n      for (const t of type.types) {\n        if (!!(t.flags & ts.TypeFlags.Undefined) || !!(t.flags & ts.TypeFlags.Null)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  static isMethodAssignment(tsSymbol: ts.Symbol | undefined): boolean {\n    return (\n      !!tsSymbol && (tsSymbol.flags & ts.SymbolFlags.Method) !== 0 && (tsSymbol.flags & ts.SymbolFlags.Assignment) !== 0\n    );\n  }\n\n  static getDeclaration(tsSymbol: ts.Symbol | undefined): ts.Declaration | undefined {\n    if (tsSymbol?.declarations && tsSymbol.declarations.length > 0) {\n      return tsSymbol.declarations[0];\n    }\n    return undefined;\n  }\n\n  private static isVarDeclaration(tsDecl: ts.Node): boolean {\n    return ts.isVariableDeclaration(tsDecl) && ts.isVariableDeclarationList(tsDecl.parent);\n  }\n\n  isValidEnumMemberInit(tsExpr: ts.Expression): boolean {\n    if (this.isNumberConstantValue(tsExpr.parent as ts.EnumMember)) {\n      return true;\n    }\n    if (this.isStringConstantValue(tsExpr.parent as ts.EnumMember)) {\n      return true;\n    }\n    return this.isCompileTimeExpression(tsExpr);\n  }\n\n  private isCompileTimeExpressionHandlePropertyAccess(tsExpr: ts.Expression): boolean {\n    if (!ts.isPropertyAccessExpression(tsExpr)) {\n      return false;\n    }\n\n    /*\n     * if enum member is in current enum declaration try to get value\n     * if it comes from another enum consider as constant\n     */\n    const propertyAccess = tsExpr;\n    if (this.isNumberConstantValue(propertyAccess)) {\n      return true;\n    }\n    const leftHandSymbol = this.trueSymbolAtLocation(propertyAccess.expression);\n    if (!leftHandSymbol) {\n      return false;\n    }\n    const decls = leftHandSymbol.getDeclarations();\n    if (!decls || decls.length !== 1) {\n      return false;\n    }\n    return ts.isEnumDeclaration(decls[0]);\n  }\n\n  isCompileTimeExpression(tsExpr: ts.Expression): boolean {\n    if (\n      ts.isParenthesizedExpression(tsExpr) ||\n      ts.isAsExpression(tsExpr) && tsExpr.type.kind === ts.SyntaxKind.NumberKeyword\n    ) {\n      return this.isCompileTimeExpression(tsExpr.expression);\n    }\n\n    switch (tsExpr.kind) {\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        return this.isPrefixUnaryExprValidEnumMemberInit(tsExpr as ts.PrefixUnaryExpression);\n      case ts.SyntaxKind.ParenthesizedExpression:\n      case ts.SyntaxKind.BinaryExpression:\n        return this.isBinaryExprValidEnumMemberInit(tsExpr as ts.BinaryExpression);\n      case ts.SyntaxKind.ConditionalExpression:\n        return this.isConditionalExprValidEnumMemberInit(tsExpr as ts.ConditionalExpression);\n      case ts.SyntaxKind.Identifier:\n        return this.isIdentifierValidEnumMemberInit(tsExpr as ts.Identifier);\n      case ts.SyntaxKind.NumericLiteral:\n        return true;\n      case ts.SyntaxKind.StringLiteral:\n        return true;\n      case ts.SyntaxKind.PropertyAccessExpression:\n        return this.isCompileTimeExpressionHandlePropertyAccess(tsExpr);\n      default:\n        return false;\n    }\n  }\n\n  private isPrefixUnaryExprValidEnumMemberInit(tsExpr: ts.PrefixUnaryExpression): boolean {\n    return TsUtils.isUnaryOpAllowedForEnumMemberInit(tsExpr.operator) && this.isCompileTimeExpression(tsExpr.operand);\n  }\n\n  private isBinaryExprValidEnumMemberInit(tsExpr: ts.BinaryExpression): boolean {\n    return (\n      TsUtils.isBinaryOpAllowedForEnumMemberInit(tsExpr.operatorToken) &&\n      this.isCompileTimeExpression(tsExpr.left) &&\n      this.isCompileTimeExpression(tsExpr.right)\n    );\n  }\n\n  private isConditionalExprValidEnumMemberInit(tsExpr: ts.ConditionalExpression): boolean {\n    return this.isCompileTimeExpression(tsExpr.whenTrue) && this.isCompileTimeExpression(tsExpr.whenFalse);\n  }\n\n  private isIdentifierValidEnumMemberInit(tsExpr: ts.Identifier): boolean {\n    const tsSymbol = this.trueSymbolAtLocation(tsExpr);\n    const tsDecl = TsUtils.getDeclaration(tsSymbol);\n    return (\n      !!tsDecl &&\n      (TsUtils.isVarDeclaration(tsDecl) && TsUtils.isConst(tsDecl.parent) || tsDecl.kind === ts.SyntaxKind.EnumMember)\n    );\n  }\n\n  private static isUnaryOpAllowedForEnumMemberInit(tsPrefixUnaryOp: ts.PrefixUnaryOperator): boolean {\n    return (\n      tsPrefixUnaryOp === ts.SyntaxKind.PlusToken ||\n      tsPrefixUnaryOp === ts.SyntaxKind.MinusToken ||\n      tsPrefixUnaryOp === ts.SyntaxKind.TildeToken\n    );\n  }\n\n  private static isBinaryOpAllowedForEnumMemberInit(tsBinaryOp: ts.BinaryOperatorToken): boolean {\n    return (\n      tsBinaryOp.kind === ts.SyntaxKind.AsteriskToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.SlashToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.PercentToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.MinusToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.PlusToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.LessThanLessThanToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.GreaterThanGreaterThanToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.BarBarToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.AmpersandToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.CaretToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.BarToken ||\n      tsBinaryOp.kind === ts.SyntaxKind.AmpersandAmpersandToken\n    );\n  }\n\n  static isConst(tsNode: ts.Node): boolean {\n    return !!(ts.getCombinedNodeFlags(tsNode) & ts.NodeFlags.Const);\n  }\n\n  isNumberConstantValue(\n    tsExpr: ts.EnumMember | ts.PropertyAccessExpression | ts.ElementAccessExpression | ts.NumericLiteral\n  ): boolean {\n    const tsConstValue =\n      tsExpr.kind === ts.SyntaxKind.NumericLiteral ?\n        Number(tsExpr.getText()) :\n        this.tsTypeChecker.getConstantValue(tsExpr);\n\n    return tsConstValue !== undefined && typeof tsConstValue === 'number';\n  }\n\n  isIntegerConstantValue(\n    tsExpr: ts.EnumMember | ts.PropertyAccessExpression | ts.ElementAccessExpression | ts.NumericLiteral\n  ): boolean {\n    const tsConstValue =\n      tsExpr.kind === ts.SyntaxKind.NumericLiteral ?\n        Number(tsExpr.getText()) :\n        this.tsTypeChecker.getConstantValue(tsExpr);\n    return (\n      tsConstValue !== undefined &&\n      typeof tsConstValue === 'number' &&\n      tsConstValue.toFixed(0) === tsConstValue.toString()\n    );\n  }\n\n  isStringConstantValue(tsExpr: ts.EnumMember | ts.PropertyAccessExpression | ts.ElementAccessExpression): boolean {\n    const tsConstValue = this.tsTypeChecker.getConstantValue(tsExpr);\n    return tsConstValue !== undefined && typeof tsConstValue === 'string';\n  }\n\n  // Returns true if typeA is a subtype of typeB\n  relatedByInheritanceOrIdentical(typeA: ts.Type, typeB: ts.Type): boolean {\n    typeA = TsUtils.reduceReference(typeA);\n    typeB = TsUtils.reduceReference(typeB);\n\n    if (typeA === typeB || this.isObject(typeB)) {\n      return true;\n    }\n    if (!typeA.symbol?.declarations) {\n      return false;\n    }\n    const isBISendable = TsUtils.isISendableInterface(typeB);\n    for (const typeADecl of typeA.symbol.declarations) {\n      if (isBISendable && ts.isClassDeclaration(typeADecl) && TsUtils.hasSendableDecorator(typeADecl)) {\n        return true;\n      }\n      if (!ts.isClassDeclaration(typeADecl) && !ts.isInterfaceDeclaration(typeADecl) || !typeADecl.heritageClauses) {\n        continue;\n      }\n      for (const heritageClause of typeADecl.heritageClauses) {\n        const processInterfaces = typeA.isClass() ? heritageClause.token !== ts.SyntaxKind.ExtendsKeyword : true;\n        if (this.processParentTypes(heritageClause.types, typeB, processInterfaces)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  static reduceReference(t: ts.Type): ts.Type {\n    return TsUtils.isTypeReference(t) && t.target !== t ? t.target : t;\n  }\n\n  private needToDeduceStructuralIdentityHandleUnions(\n    lhsType: ts.Type,\n    rhsType: ts.Type,\n    rhsExpr: ts.Expression\n  ): boolean {\n    if (rhsType.isUnion()) {\n      // Each Class/Interface of the RHS union type must be compatible with LHS type.\n      for (const compType of rhsType.types) {\n        if (this.needToDeduceStructuralIdentity(lhsType, compType, rhsExpr)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if (lhsType.isUnion()) {\n      // RHS type needs to be compatible with at least one type of the LHS union.\n      for (const compType of lhsType.types) {\n        if (!this.needToDeduceStructuralIdentity(compType, rhsType, rhsExpr)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    // should be unreachable\n    return false;\n  }\n\n  // return true if two class types are not related by inheritance and structural identity check is needed\n  needToDeduceStructuralIdentity(lhsType: ts.Type, rhsType: ts.Type, rhsExpr: ts.Expression): boolean {\n    lhsType = this.getNonNullableType(lhsType);\n    rhsType = this.getNonNullableType(rhsType);\n    if (this.isLibraryType(lhsType)) {\n      return false;\n    }\n    if (this.isDynamicObjectAssignedToStdType(lhsType, rhsExpr)) {\n      return false;\n    }\n    // #14569: Check for Function type.\n    if (this.areCompatibleFunctionals(lhsType, rhsType)) {\n      return false;\n    }\n    if (rhsType.isUnion() || lhsType.isUnion()) {\n      return this.needToDeduceStructuralIdentityHandleUnions(lhsType, rhsType, rhsExpr);\n    }\n    if (\n      this.advancedClassChecks &&\n      TsUtils.isClassValueType(rhsType) &&\n      lhsType !== rhsType &&\n      !TsUtils.isObjectType(lhsType)\n    ) {\n      // missing exact rule\n      return true;\n    }\n    return (\n      lhsType.isClassOrInterface() &&\n      rhsType.isClassOrInterface() &&\n      !this.relatedByInheritanceOrIdentical(rhsType, lhsType)\n    );\n  }\n\n  private processParentTypes(\n    parentTypes: ts.NodeArray<ts.Expression>,\n    typeB: ts.Type,\n    processInterfaces: boolean\n  ): boolean {\n    for (const baseTypeExpr of parentTypes) {\n      const baseType = TsUtils.reduceReference(this.tsTypeChecker.getTypeAtLocation(baseTypeExpr));\n      if (\n        baseType &&\n        baseType.isClass() !== processInterfaces &&\n        this.relatedByInheritanceOrIdentical(baseType, typeB)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private processParentTypesCheck(\n    parentTypes: ts.NodeArray<ts.Expression>,\n    checkType: CheckType,\n    checkedBaseTypes: Set<ts.Type>\n  ): boolean {\n    for (const baseTypeExpr of parentTypes) {\n      const baseType = TsUtils.reduceReference(this.tsTypeChecker.getTypeAtLocation(baseTypeExpr));\n      if (baseType && !checkedBaseTypes.has(baseType) && this.isOrDerivedFrom(baseType, checkType, checkedBaseTypes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isObject(tsType: ts.Type): boolean {\n    if (!tsType) {\n      return false;\n    }\n    if (tsType.symbol && tsType.isClassOrInterface() && tsType.symbol.name === 'Object') {\n      return true;\n    }\n    const node = this.tsTypeChecker.typeToTypeNode(tsType, undefined, undefined);\n    return node !== undefined && node.kind === ts.SyntaxKind.ObjectKeyword;\n  }\n\n  isCallToFunctionWithOmittedReturnType(tsExpr: ts.Expression): boolean {\n    if (ts.isCallExpression(tsExpr)) {\n      const tsCallSignature = this.tsTypeChecker.getResolvedSignature(tsExpr);\n      if (tsCallSignature) {\n        const tsSignDecl = tsCallSignature.getDeclaration();\n        // `tsSignDecl` is undefined when `getResolvedSignature` returns `unknownSignature`\n        if (!tsSignDecl?.type) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private static hasReadonlyFields(type: ts.Type): boolean {\n    // No members -> no readonly fields\n    if (type.symbol.members === undefined) {\n      return false;\n    }\n\n    let result: boolean = false;\n\n    type.symbol.members.forEach((value) => {\n      if (\n        value.declarations !== undefined &&\n        value.declarations.length > 0 &&\n        ts.isPropertyDeclaration(value.declarations[0])\n      ) {\n        const propmMods = ts.getModifiers(value.declarations[0]);\n        if (TsUtils.hasModifier(propmMods, ts.SyntaxKind.ReadonlyKeyword)) {\n          result = true;\n        }\n      }\n    });\n\n    return result;\n  }\n\n  private static hasDefaultCtor(type: ts.Type): boolean {\n    // No members -> no explicit constructors -> there is default ctor\n    if (type.symbol.members === undefined) {\n      return true;\n    }\n\n    // has any constructor\n    let hasCtor: boolean = false;\n    // has default constructor\n    let hasDefaultCtor: boolean = false;\n\n    type.symbol.members.forEach((value) => {\n      if ((value.flags & ts.SymbolFlags.Constructor) !== 0) {\n        hasCtor = true;\n\n        if (value.declarations !== undefined && value.declarations.length > 0) {\n          const declCtor = value.declarations[0] as ts.ConstructorDeclaration;\n          if (declCtor.parameters.length === 0) {\n            hasDefaultCtor = true;\n          }\n        }\n      }\n    });\n\n    // Has no any explicit constructor -> has implicit default constructor.\n    return !hasCtor || hasDefaultCtor;\n  }\n\n  private static isAbstractClass(type: ts.Type): boolean {\n    if (type.isClass() && type.symbol.declarations && type.symbol.declarations.length > 0) {\n      const declClass = type.symbol.declarations[0] as ts.ClassDeclaration;\n      const classMods = ts.getModifiers(declClass);\n      if (TsUtils.hasModifier(classMods, ts.SyntaxKind.AbstractKeyword)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static validateObjectLiteralType(type: ts.Type | undefined): boolean {\n    if (!type) {\n      return false;\n    }\n    type = TsUtils.reduceReference(type);\n    return (\n      type.isClassOrInterface() &&\n      TsUtils.hasDefaultCtor(type) &&\n      !TsUtils.hasReadonlyFields(type) &&\n      !TsUtils.isAbstractClass(type)\n    );\n  }\n\n  hasMethods(type: ts.Type): boolean {\n    const properties = this.tsTypeChecker.getPropertiesOfType(type);\n    if (properties?.length) {\n      for (const prop of properties) {\n        if (prop.getFlags() & ts.SymbolFlags.Method) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  findProperty(type: ts.Type, name: string): ts.Symbol | undefined {\n    const properties = this.tsTypeChecker.getPropertiesOfType(type);\n    if (properties?.length) {\n      for (const prop of properties) {\n        if (prop.name === name) {\n          return prop;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  checkTypeSet(typeSet: ts.Type, predicate: CheckType): boolean {\n    if (!typeSet.isUnionOrIntersection()) {\n      return predicate.call(this, typeSet);\n    }\n    for (const elemType of typeSet.types) {\n      if (this.checkTypeSet(elemType, predicate)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getNonNullableType(t: ts.Type): ts.Type {\n    const isNullableUnionType = this.useRtLogic ? TsUtils.isNullableUnionType(t) : t.isUnion();\n    if (isNullableUnionType) {\n      return t.getNonNullableType();\n    }\n    return t;\n  }\n\n  private isObjectLiteralAssignableToUnion(lhsType: ts.UnionType, rhsExpr: ts.ObjectLiteralExpression): boolean {\n    for (const compType of lhsType.types) {\n      if (this.isObjectLiteralAssignable(compType, rhsExpr)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isObjectLiteralAssignable(lhsType: ts.Type | undefined, rhsExpr: ts.ObjectLiteralExpression): boolean {\n    if (lhsType === undefined) {\n      return false;\n    }\n    // Always check with the non-nullable variant of lhs type.\n    lhsType = this.getNonNullableType(lhsType);\n    if (lhsType.isUnion() && this.isObjectLiteralAssignableToUnion(lhsType, rhsExpr)) {\n      return true;\n    }\n\n    /*\n     * Allow initializing with anything when the type\n     * originates from the library.\n     */\n    if (TsUtils.isAnyType(lhsType) || this.isLibraryType(lhsType)) {\n      return true;\n    }\n\n    /*\n     * issue 13412:\n     * Allow initializing with a dynamic object when the LHS type\n     * is primitive or defined in standard library.\n     */\n    if (this.isDynamicObjectAssignedToStdType(lhsType, rhsExpr)) {\n      return true;\n    }\n    // For Partial<T>, Required<T>, Readonly<T> types, validate their argument type.\n    if (this.isStdPartialType(lhsType) || this.isStdRequiredType(lhsType) || this.isStdReadonlyType(lhsType)) {\n      if (lhsType.aliasTypeArguments && lhsType.aliasTypeArguments.length === 1) {\n        lhsType = lhsType.aliasTypeArguments[0];\n      } else {\n        return false;\n      }\n    }\n\n    /*\n     * Allow initializing Record objects with object initializer.\n     * Record supports any type for a its value, but the key value\n     * must be either a string or number literal.\n     */\n    if (this.isStdRecordType(lhsType)) {\n      return this.validateRecordObjectKeys(rhsExpr);\n    }\n    return (\n      TsUtils.validateObjectLiteralType(lhsType) && !this.hasMethods(lhsType) && this.validateFields(lhsType, rhsExpr)\n    );\n  }\n\n  private isDynamicObjectAssignedToStdType(lhsType: ts.Type, rhsExpr: ts.Expression): boolean {\n    if (isStdLibraryType(lhsType) || TsUtils.isPrimitiveType(lhsType)) {\n      const rhsSym = ts.isCallExpression(rhsExpr) ?\n        this.getSymbolOfCallExpression(rhsExpr) :\n        this.useRtLogic ?\n          this.trueSymbolAtLocation(rhsExpr) :\n          this.tsTypeChecker.getSymbolAtLocation(rhsExpr);\n      if (rhsSym && this.isLibrarySymbol(rhsSym)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  validateFields(objectType: ts.Type, objectLiteral: ts.ObjectLiteralExpression): boolean {\n    for (const prop of objectLiteral.properties) {\n      if (ts.isPropertyAssignment(prop)) {\n        if (!this.validateField(objectType, prop)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  getPropertySymbol(type: ts.Type, prop: ts.PropertyAssignment): ts.Symbol | undefined {\n    const propNameSymbol = this.tsTypeChecker.getSymbolAtLocation(prop.name);\n    const propName = propNameSymbol ?\n      ts.symbolName(propNameSymbol) :\n      ts.isMemberName(prop.name) ?\n        ts.idText(prop.name) :\n        prop.name.getText();\n    const propSym = this.findProperty(type, propName);\n    return propSym;\n  }\n\n  private validateField(type: ts.Type, prop: ts.PropertyAssignment): boolean {\n    // Issue 15497: Use unescaped property name to find correpsponding property.\n    const propSym = this.getPropertySymbol(type, prop);\n    if (!propSym?.declarations?.length) {\n      return false;\n    }\n\n    const propType = this.tsTypeChecker.getTypeOfSymbolAtLocation(propSym, propSym.declarations[0]);\n    const initExpr = TsUtils.unwrapParenthesized(prop.initializer);\n    if (ts.isObjectLiteralExpression(initExpr)) {\n      if (!this.isObjectLiteralAssignable(propType, initExpr)) {\n        return false;\n      }\n    } else if (\n      this.needToDeduceStructuralIdentity(propType, this.tsTypeChecker.getTypeAtLocation(initExpr), initExpr)\n    ) {\n      // Only check for structural sub-typing.\n      return false;\n    }\n\n    return true;\n  }\n\n  validateRecordObjectKeys(objectLiteral: ts.ObjectLiteralExpression): boolean {\n    for (const prop of objectLiteral.properties) {\n      if (!prop.name) {\n        return false;\n      }\n      const isValidComputedProperty =\n        ts.isComputedPropertyName(prop.name) && this.isValidComputedPropertyName(prop.name, true);\n      if (!ts.isStringLiteral(prop.name) && !ts.isNumericLiteral(prop.name) && !isValidComputedProperty) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static isSupportedTypeNodeKind(kind: ts.SyntaxKind): boolean {\n    return (\n      kind !== ts.SyntaxKind.AnyKeyword &&\n      kind !== ts.SyntaxKind.UnknownKeyword &&\n      kind !== ts.SyntaxKind.SymbolKeyword &&\n      kind !== ts.SyntaxKind.IndexedAccessType &&\n      kind !== ts.SyntaxKind.ConditionalType &&\n      kind !== ts.SyntaxKind.MappedType &&\n      kind !== ts.SyntaxKind.InferType\n    );\n  }\n\n  private isSupportedTypeHandleUnionTypeNode(typeNode: ts.UnionTypeNode): boolean {\n    for (const unionTypeElem of typeNode.types) {\n      if (!this.isSupportedType(unionTypeElem)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private isSupportedTypeHandleTupleTypeNode(typeNode: ts.TupleTypeNode): boolean {\n    for (const elem of typeNode.elements) {\n      if (ts.isTypeNode(elem) && !this.isSupportedType(elem)) {\n        return false;\n      }\n      if (ts.isNamedTupleMember(elem) && !this.isSupportedType(elem.type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isSupportedType(typeNode: ts.TypeNode): boolean {\n    if (ts.isParenthesizedTypeNode(typeNode)) {\n      return this.isSupportedType(typeNode.type);\n    }\n\n    if (ts.isArrayTypeNode(typeNode)) {\n      return this.isSupportedType(typeNode.elementType);\n    }\n\n    if (ts.isTypeReferenceNode(typeNode) && typeNode.typeArguments) {\n      for (const typeArg of typeNode.typeArguments) {\n        if (!this.isSupportedType(typeArg)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    if (ts.isUnionTypeNode(typeNode)) {\n      return this.isSupportedTypeHandleUnionTypeNode(typeNode);\n    }\n\n    if (ts.isTupleTypeNode(typeNode)) {\n      return this.isSupportedTypeHandleTupleTypeNode(typeNode);\n    }\n\n    return (\n      !ts.isTypeLiteralNode(typeNode) &&\n      (this.advancedClassChecks || !ts.isTypeQueryNode(typeNode)) &&\n      !ts.isIntersectionTypeNode(typeNode) &&\n      TsUtils.isSupportedTypeNodeKind(typeNode.kind)\n    );\n  }\n\n  isStructObjectInitializer(objectLiteral: ts.ObjectLiteralExpression): boolean {\n    if (ts.isCallLikeExpression(objectLiteral.parent)) {\n      const signature = this.tsTypeChecker.getResolvedSignature(objectLiteral.parent);\n      const signDecl = signature?.declaration;\n      return !!signDecl && ts.isConstructorDeclaration(signDecl) && isStructDeclaration(signDecl.parent);\n    }\n    return false;\n  }\n\n  getParentSymbolName(symbol: ts.Symbol): string | undefined {\n    const name = this.tsTypeChecker.getFullyQualifiedName(symbol);\n    const dotPosition = name.lastIndexOf('.');\n    return dotPosition === -1 ? undefined : name.substring(0, dotPosition);\n  }\n\n  isGlobalSymbol(symbol: ts.Symbol): boolean {\n    const parentName = this.getParentSymbolName(symbol);\n    return !parentName || parentName === 'global';\n  }\n\n  isSymbolAPI(symbol: ts.Symbol): boolean {\n    const parentName = this.getParentSymbolName(symbol);\n    if (!this.useRtLogic) {\n      const name = parentName ? parentName : symbol.escapedName;\n      return name === SYMBOL || name === SYMBOL_CONSTRUCTOR;\n    }\n    return !!parentName && (parentName === SYMBOL || parentName === SYMBOL_CONSTRUCTOR);\n  }\n\n  isSymbolIterator(symbol: ts.Symbol): boolean {\n    if (!this.useRtLogic) {\n      const name = symbol.name;\n      const parName = this.getParentSymbolName(symbol);\n      return (parName === SYMBOL || parName === SYMBOL_CONSTRUCTOR) && name === ITERATOR;\n    }\n    return this.isSymbolAPI(symbol) && symbol.name === ITERATOR;\n  }\n\n  static isDefaultImport(importSpec: ts.ImportSpecifier): boolean {\n    return importSpec?.propertyName?.text === 'default';\n  }\n\n  static getStartPos(nodeOrComment: ts.Node | ts.CommentRange): number {\n    return nodeOrComment.kind === ts.SyntaxKind.SingleLineCommentTrivia ||\n      nodeOrComment.kind === ts.SyntaxKind.MultiLineCommentTrivia ?\n      (nodeOrComment as ts.CommentRange).pos :\n      (nodeOrComment as ts.Node).getStart();\n  }\n\n  static getEndPos(nodeOrComment: ts.Node | ts.CommentRange): number {\n    return nodeOrComment.kind === ts.SyntaxKind.SingleLineCommentTrivia ||\n      nodeOrComment.kind === ts.SyntaxKind.MultiLineCommentTrivia ?\n      (nodeOrComment as ts.CommentRange).end :\n      (nodeOrComment as ts.Node).getEnd();\n  }\n\n  static getHighlightRange(nodeOrComment: ts.Node | ts.CommentRange, faultId: number): [number, number] {\n    return (\n      this.highlightRangeHandlers.get(faultId)?.call(this, nodeOrComment) ?? [\n        this.getStartPos(nodeOrComment),\n        this.getEndPos(nodeOrComment)\n      ]\n    );\n  }\n\n  static highlightRangeHandlers = new Map([\n    [FaultID.VarDeclaration, TsUtils.getVarDeclarationHighlightRange],\n    [FaultID.CatchWithUnsupportedType, TsUtils.getCatchWithUnsupportedTypeHighlightRange],\n    [FaultID.ForInStatement, TsUtils.getForInStatementHighlightRange],\n    [FaultID.WithStatement, TsUtils.getWithStatementHighlightRange],\n    [FaultID.DeleteOperator, TsUtils.getDeleteOperatorHighlightRange],\n    [FaultID.TypeQuery, TsUtils.getTypeQueryHighlightRange],\n    [FaultID.InstanceofUnsupported, TsUtils.getInstanceofUnsupportedHighlightRange],\n    [FaultID.ConstAssertion, TsUtils.getConstAssertionHighlightRange],\n    [FaultID.LimitedReturnTypeInference, TsUtils.getLimitedReturnTypeInferenceHighlightRange],\n    [FaultID.LocalFunction, TsUtils.getLocalFunctionHighlightRange],\n    [FaultID.FunctionBind, TsUtils.getFunctionApplyCallHighlightRange],\n    [FaultID.FunctionApplyCall, TsUtils.getFunctionApplyCallHighlightRange],\n    [FaultID.DeclWithDuplicateName, TsUtils.getDeclWithDuplicateNameHighlightRange],\n    [FaultID.ObjectLiteralNoContextType, TsUtils.getObjectLiteralNoContextTypeHighlightRange],\n    [FaultID.ClassExpression, TsUtils.getClassExpressionHighlightRange],\n    [FaultID.MultipleStaticBlocks, TsUtils.getMultipleStaticBlocksHighlightRange],\n    [FaultID.ParameterProperties, TsUtils.getParameterPropertiesHighlightRange],\n    [FaultID.SendableDefiniteAssignment, TsUtils.getSendableDefiniteAssignmentHighlightRange],\n    [FaultID.ObjectTypeLiteral, TsUtils.getObjectTypeLiteralHighlightRange]\n  ]);\n\n  static getKeywordHighlightRange(nodeOrComment: ts.Node | ts.CommentRange, keyword: string): [number, number] {\n    const start = this.getStartPos(nodeOrComment);\n    return [start, start + keyword.length];\n  }\n\n  static getVarDeclarationHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, 'var');\n  }\n\n  static getCatchWithUnsupportedTypeHighlightRange(\n    nodeOrComment: ts.Node | ts.CommentRange\n  ): [number, number] | undefined {\n    const catchClauseNode = (nodeOrComment as ts.CatchClause).variableDeclaration;\n    if (catchClauseNode !== undefined) {\n      return [catchClauseNode.getStart(), catchClauseNode.getEnd()];\n    }\n\n    return undefined;\n  }\n\n  static getForInStatementHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return [\n      this.getEndPos((nodeOrComment as ts.ForInStatement).initializer) + 1,\n      this.getStartPos((nodeOrComment as ts.ForInStatement).expression) - 1\n    ];\n  }\n\n  static getWithStatementHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return [this.getStartPos(nodeOrComment), (nodeOrComment as ts.WithStatement).statement.getStart() - 1];\n  }\n\n  static getDeleteOperatorHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, 'delete');\n  }\n\n  static getTypeQueryHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, 'typeof');\n  }\n\n  static getInstanceofUnsupportedHighlightRange(\n    nodeOrComment: ts.Node | ts.CommentRange\n  ): [number, number] | undefined {\n    return this.getKeywordHighlightRange((nodeOrComment as ts.BinaryExpression).operatorToken, 'instanceof');\n  }\n\n  static getConstAssertionHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    if (nodeOrComment.kind === ts.SyntaxKind.AsExpression) {\n      return [\n        (nodeOrComment as ts.AsExpression).expression.getEnd() + 1,\n        (nodeOrComment as ts.AsExpression).type.getStart() - 1\n      ];\n    }\n    return [\n      (nodeOrComment as ts.TypeAssertion).expression.getEnd() + 1,\n      (nodeOrComment as ts.TypeAssertion).type.getEnd() + 1\n    ];\n  }\n\n  static getLimitedReturnTypeInferenceHighlightRange(\n    nodeOrComment: ts.Node | ts.CommentRange\n  ): [number, number] | undefined {\n    let node: ts.Node | undefined;\n    if (nodeOrComment.kind === ts.SyntaxKind.FunctionExpression) {\n      // we got error about return type so it should be present\n      node = (nodeOrComment as ts.FunctionExpression).type;\n    } else if (nodeOrComment.kind === ts.SyntaxKind.FunctionDeclaration) {\n      node = (nodeOrComment as ts.FunctionDeclaration).name;\n    } else if (nodeOrComment.kind === ts.SyntaxKind.MethodDeclaration) {\n      node = (nodeOrComment as ts.MethodDeclaration).name;\n    }\n\n    if (node !== undefined) {\n      return [node.getStart(), node.getEnd()];\n    }\n\n    return undefined;\n  }\n\n  static getLocalFunctionHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, 'function');\n  }\n\n  static getFunctionApplyCallHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    const pointPos = (nodeOrComment as ts.Node).getText().lastIndexOf('.');\n    return [this.getStartPos(nodeOrComment) + pointPos + 1, this.getEndPos(nodeOrComment)];\n  }\n\n  static getDeclWithDuplicateNameHighlightRange(\n    nodeOrComment: ts.Node | ts.CommentRange\n  ): [number, number] | undefined {\n    // in case of private identifier no range update is needed\n    const nameNode: ts.Node | undefined = (nodeOrComment as ts.NamedDeclaration).name;\n    if (nameNode !== undefined) {\n      return [nameNode.getStart(), nameNode.getEnd()];\n    }\n\n    return undefined;\n  }\n\n  static getObjectLiteralNoContextTypeHighlightRange(\n    nodeOrComment: ts.Node | ts.CommentRange\n  ): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, '{');\n  }\n\n  static getClassExpressionHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, 'class');\n  }\n\n  static getMultipleStaticBlocksHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, 'static');\n  }\n\n  static getParameterPropertiesHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    const params = (nodeOrComment as ts.ConstructorDeclaration).parameters;\n    if (params.length) {\n      return [params[0].getStart(), params[params.length - 1].getEnd()];\n    }\n    return undefined;\n  }\n\n  static getObjectTypeLiteralHighlightRange(nodeOrComment: ts.Node | ts.CommentRange): [number, number] | undefined {\n    return this.getKeywordHighlightRange(nodeOrComment, '{');\n  }\n\n  // highlight ranges for Sendable rules\n\n  static getSendableDefiniteAssignmentHighlightRange(\n    nodeOrComment: ts.Node | ts.CommentRange\n  ): [number, number] | undefined {\n    const name = (nodeOrComment as ts.PropertyDeclaration).name;\n    const exclamationToken = (nodeOrComment as ts.PropertyDeclaration).exclamationToken;\n    return [name.getStart(), exclamationToken ? exclamationToken.getEnd() : name.getEnd()];\n  }\n\n  isStdRecordType(type: ts.Type): boolean {\n\n    /*\n     * In TypeScript, 'Record<K, T>' is defined as type alias to a mapped type.\n     * Thus, it should have 'aliasSymbol' and 'target' properties. The 'target'\n     * in this case will resolve to origin 'Record' symbol.\n     */\n    if (type.aliasSymbol) {\n      const target = (type as ts.TypeReference).target;\n      if (target) {\n        const sym = target.aliasSymbol;\n        return !!sym && sym.getName() === 'Record' && this.isGlobalSymbol(sym);\n      }\n    }\n\n    return false;\n  }\n\n  isStdErrorType(type: ts.Type): boolean {\n    const symbol = type.symbol;\n    if (!symbol) {\n      return false;\n    }\n    const name = this.tsTypeChecker.getFullyQualifiedName(symbol);\n    return name === 'Error' && this.isGlobalSymbol(symbol);\n  }\n\n  isStdPartialType(type: ts.Type): boolean {\n    const sym = type.aliasSymbol;\n    return !!sym && sym.getName() === 'Partial' && this.isGlobalSymbol(sym);\n  }\n\n  isStdRequiredType(type: ts.Type): boolean {\n    const sym = type.aliasSymbol;\n    return !!sym && sym.getName() === 'Required' && this.isGlobalSymbol(sym);\n  }\n\n  isStdReadonlyType(type: ts.Type): boolean {\n    const sym = type.aliasSymbol;\n    return !!sym && sym.getName() === 'Readonly' && this.isGlobalSymbol(sym);\n  }\n\n  isLibraryType(type: ts.Type): boolean {\n    const nonNullableType = type.getNonNullableType();\n    if (nonNullableType.isUnion()) {\n      for (const componentType of nonNullableType.types) {\n        if (!this.isLibraryType(componentType)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return this.isLibrarySymbol(nonNullableType.aliasSymbol ?? nonNullableType.getSymbol());\n  }\n\n  hasLibraryType(node: ts.Node): boolean {\n    return this.isLibraryType(this.tsTypeChecker.getTypeAtLocation(node));\n  }\n\n  isLibrarySymbol(sym: ts.Symbol | undefined): boolean {\n    if (sym?.declarations && sym.declarations.length > 0) {\n      const srcFile = sym.declarations[0].getSourceFile();\n      if (!srcFile) {\n        return false;\n      }\n      const fileName = srcFile.fileName;\n\n      /*\n       * Symbols from both *.ts and *.d.ts files should obey interop rules.\n       * We disable such behavior for *.ts files in the test mode due to lack of 'ets'\n       * extension support.\n       */\n      const ext = path.extname(fileName).toLowerCase();\n      const isThirdPartyCode =\n        ARKTS_IGNORE_DIRS.some((ignore) => {\n          return pathContainsDirectory(path.normalize(fileName), ignore);\n        }) ||\n        ARKTS_IGNORE_FILES.some((ignore) => {\n          return path.basename(fileName) === ignore;\n        });\n      const isEts = ext === '.ets';\n      const isTs = ext === '.ts' && !srcFile.isDeclarationFile;\n      const isStatic = (isEts || isTs && this.testMode) && !isThirdPartyCode;\n      const isStdLib = STANDARD_LIBRARIES.includes(path.basename(fileName).toLowerCase());\n\n      /*\n       * We still need to confirm support for certain API from the\n       * TypeScript standard library in ArkTS. Thus, for now do not\n       * count standard library modules as dynamic.\n       */\n      return !isStatic && !isStdLib;\n    }\n    return false;\n  }\n\n  isDynamicType(type: ts.Type | undefined): boolean | undefined {\n    if (type === undefined) {\n      return false;\n    }\n\n    /*\n     * Return 'true' if it is an object of library type initialization, otherwise\n     * return 'false' if it is not an object of standard library type one.\n     * In the case of standard library type we need to determine context.\n     */\n\n    /*\n     * Check the non-nullable version of type to eliminate 'undefined' type\n     * from the union type elements.\n     */\n    type = type.getNonNullableType();\n\n    if (type.isUnion()) {\n      for (const compType of type.types) {\n        const isDynamic = this.isDynamicType(compType);\n        if (isDynamic || isDynamic === undefined) {\n          return isDynamic;\n        }\n      }\n      return false;\n    }\n\n    if (this.isLibraryType(type)) {\n      return true;\n    }\n\n    if (!isStdLibraryType(type) && !isIntrinsicObjectType(type) && !TsUtils.isAnyType(type)) {\n      return false;\n    }\n\n    return undefined;\n  }\n\n  static isObjectType(type: ts.Type): type is ts.ObjectType {\n    return !!(type.flags & ts.TypeFlags.Object);\n  }\n\n  private static isAnonymous(type: ts.Type): boolean {\n    if (TsUtils.isObjectType(type)) {\n      return !!(type.objectFlags & ts.ObjectFlags.Anonymous);\n    }\n    return false;\n  }\n\n  private isDynamicLiteralInitializerHandleCallExpression(callExpr: ts.CallExpression): boolean {\n    const type = this.tsTypeChecker.getTypeAtLocation(callExpr.expression);\n\n    if (TsUtils.isAnyType(type)) {\n      return true;\n    }\n\n    let sym: ts.Symbol | undefined = type.symbol;\n    if (this.isLibrarySymbol(sym)) {\n      return true;\n    }\n\n    /*\n     * #13483:\n     * x.foo({ ... }), where 'x' is exported from some library:\n     */\n    if (ts.isPropertyAccessExpression(callExpr.expression)) {\n      sym = this.trueSymbolAtLocation(callExpr.expression.expression);\n      if (sym && this.isLibrarySymbol(sym)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isDynamicLiteralInitializer(expr: ts.Expression): boolean {\n    if (!ts.isObjectLiteralExpression(expr) && !ts.isArrayLiteralExpression(expr)) {\n      return false;\n    }\n\n    /*\n     * Handle nested literals:\n     * { f: { ... } }\n     */\n    let curNode: ts.Node = expr;\n    while (ts.isObjectLiteralExpression(curNode) || ts.isArrayLiteralExpression(curNode)) {\n      const exprType = this.tsTypeChecker.getContextualType(curNode);\n      if (exprType !== undefined && !TsUtils.isAnonymous(exprType)) {\n        const res = this.isDynamicType(exprType);\n        if (res !== undefined) {\n          return res;\n        }\n      }\n\n      curNode = curNode.parent;\n      if (ts.isPropertyAssignment(curNode)) {\n        curNode = curNode.parent;\n      }\n    }\n\n    /*\n     * Handle calls with literals:\n     * foo({ ... })\n     */\n    if (ts.isCallExpression(curNode) && this.isDynamicLiteralInitializerHandleCallExpression(curNode)) {\n      return true;\n    }\n\n    /*\n     * Handle property assignments with literals:\n     * obj.f = { ... }\n     */\n    if (ts.isBinaryExpression(curNode)) {\n      const binExpr = curNode;\n      if (ts.isPropertyAccessExpression(binExpr.left)) {\n        const propAccessExpr = binExpr.left;\n        const type = this.tsTypeChecker.getTypeAtLocation(propAccessExpr.expression);\n        return this.isLibrarySymbol(type.symbol);\n      }\n    }\n\n    return false;\n  }\n\n  static isEsObjectType(typeNode: ts.TypeNode | undefined): boolean {\n    return (\n      !!typeNode &&\n      ts.isTypeReferenceNode(typeNode) &&\n      ts.isIdentifier(typeNode.typeName) &&\n      typeNode.typeName.text === ES_OBJECT\n    );\n  }\n\n  static isInsideBlock(node: ts.Node): boolean {\n    let par = node.parent;\n    while (par) {\n      if (ts.isBlock(par)) {\n        return true;\n      }\n      par = par.parent;\n    }\n    return false;\n  }\n\n  static isEsObjectPossiblyAllowed(typeRef: ts.TypeReferenceNode): boolean {\n    return ts.isVariableDeclaration(typeRef.parent);\n  }\n\n  isValueAssignableToESObject(node: ts.Node): boolean {\n    if (ts.isArrayLiteralExpression(node) || ts.isObjectLiteralExpression(node)) {\n      return false;\n    }\n    const valueType = this.tsTypeChecker.getTypeAtLocation(node);\n    return TsUtils.isUnsupportedType(valueType) || TsUtils.isAnonymousType(valueType);\n  }\n\n  getVariableDeclarationTypeNode(node: ts.Node): ts.TypeNode | undefined {\n    const sym = this.trueSymbolAtLocation(node);\n    if (sym === undefined) {\n      return undefined;\n    }\n    return TsUtils.getSymbolDeclarationTypeNode(sym);\n  }\n\n  static getSymbolDeclarationTypeNode(sym: ts.Symbol): ts.TypeNode | undefined {\n    const decl = TsUtils.getDeclaration(sym);\n    if (!!decl && ts.isVariableDeclaration(decl)) {\n      return decl.type;\n    }\n    return undefined;\n  }\n\n  hasEsObjectType(node: ts.Node): boolean {\n    const typeNode = this.getVariableDeclarationTypeNode(node);\n    return typeNode !== undefined && TsUtils.isEsObjectType(typeNode);\n  }\n\n  static symbolHasEsObjectType(sym: ts.Symbol): boolean {\n    const typeNode = TsUtils.getSymbolDeclarationTypeNode(sym);\n    return typeNode !== undefined && TsUtils.isEsObjectType(typeNode);\n  }\n\n  static isEsObjectSymbol(sym: ts.Symbol): boolean {\n    const decl = TsUtils.getDeclaration(sym);\n    return (\n      !!decl &&\n      ts.isTypeAliasDeclaration(decl) &&\n      decl.name.escapedText === ES_OBJECT &&\n      decl.type.kind === ts.SyntaxKind.AnyKeyword\n    );\n  }\n\n  static isAnonymousType(type: ts.Type): boolean {\n    if (type.isUnionOrIntersection()) {\n      for (const compType of type.types) {\n        if (TsUtils.isAnonymousType(compType)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return (\n      (type.flags & ts.TypeFlags.Object) !== 0 && ((type as ts.ObjectType).objectFlags & ts.ObjectFlags.Anonymous) !== 0\n    );\n  }\n\n  getSymbolOfCallExpression(callExpr: ts.CallExpression): ts.Symbol | undefined {\n    const signature = this.tsTypeChecker.getResolvedSignature(callExpr);\n    const signDecl = signature?.getDeclaration();\n    if (signDecl?.name) {\n      return this.trueSymbolAtLocation(signDecl.name);\n    }\n    return undefined;\n  }\n\n  static isClassValueType(type: ts.Type): boolean {\n    if (\n      (type.flags & ts.TypeFlags.Object) === 0 ||\n      ((type as ts.ObjectType).objectFlags & ts.ObjectFlags.Anonymous) === 0\n    ) {\n      return false;\n    }\n    return type.symbol && (type.symbol.flags & ts.SymbolFlags.Class) !== 0;\n  }\n\n  isClassObjectExpression(expr: ts.Expression): boolean {\n    if (!TsUtils.isClassValueType(this.tsTypeChecker.getTypeAtLocation(expr))) {\n      return false;\n    }\n    const symbol = this.trueSymbolAtLocation(expr);\n    return !symbol || (symbol.flags & ts.SymbolFlags.Class) === 0;\n  }\n\n  isClassTypeExrepssion(expr: ts.Expression): boolean {\n    const sym = this.trueSymbolAtLocation(expr);\n    return sym !== undefined && (sym.flags & ts.SymbolFlags.Class) !== 0;\n  }\n\n  isFunctionCalledRecursively(funcExpr: ts.FunctionExpression): boolean {\n    if (!funcExpr.name) {\n      return false;\n    }\n\n    const sym = this.tsTypeChecker.getSymbolAtLocation(funcExpr.name);\n    if (!sym) {\n      return false;\n    }\n\n    let found = false;\n    const callback = (node: ts.Node): void => {\n      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression)) {\n        const callSym = this.tsTypeChecker.getSymbolAtLocation(node.expression);\n        if (callSym && callSym === sym) {\n          found = true;\n        }\n      }\n    };\n\n    const stopCondition = (node: ts.Node): boolean => {\n      void node;\n      return found;\n    };\n\n    forEachNodeInSubtree(funcExpr, callback, stopCondition);\n    return found;\n  }\n\n  getTypeOrTypeConstraintAtLocation(expr: ts.Expression): ts.Type {\n    const type = this.tsTypeChecker.getTypeAtLocation(expr);\n    if (type.isTypeParameter()) {\n      const constraint = type.getConstraint();\n      if (constraint) {\n        return constraint;\n      }\n    }\n    return type;\n  }\n\n  private areCompatibleFunctionals(lhsType: ts.Type, rhsType: ts.Type): boolean {\n    return (\n      (this.isStdFunctionType(lhsType) || TsUtils.isFunctionalType(lhsType)) &&\n      (this.isStdFunctionType(rhsType) || TsUtils.isFunctionalType(rhsType))\n    );\n  }\n\n  private static isFunctionalType(type: ts.Type): boolean {\n    const callSigns = type.getCallSignatures();\n    return callSigns && callSigns.length > 0;\n  }\n\n  private isStdFunctionType(type: ts.Type): boolean {\n    const sym = type.getSymbol();\n    return !!sym && sym.getName() === 'Function' && this.isGlobalSymbol(sym);\n  }\n\n  isStdBigIntType(type: ts.Type): boolean {\n    const sym = type.symbol;\n    return !!sym && sym.getName() === 'BigInt' && this.isGlobalSymbol(sym);\n  }\n\n  isStdNumberType(type: ts.Type): boolean {\n    const sym = type.symbol;\n    return !!sym && sym.getName() === 'Number' && this.isGlobalSymbol(sym);\n  }\n\n  isStdBooleanType(type: ts.Type): boolean {\n    const sym = type.symbol;\n    return !!sym && sym.getName() === 'Boolean' && this.isGlobalSymbol(sym);\n  }\n\n  isEnumStringLiteral(expr: ts.Expression): boolean {\n    const symbol = this.trueSymbolAtLocation(expr);\n    const isEnumMember = !!symbol && !!(symbol.flags & ts.SymbolFlags.EnumMember);\n    const type = this.tsTypeChecker.getTypeAtLocation(expr);\n    const isStringEnumLiteral = TsUtils.isEnumType(type) && !!(type.flags & ts.TypeFlags.StringLiteral);\n    return isEnumMember && isStringEnumLiteral;\n  }\n\n  isValidComputedPropertyName(computedProperty: ts.ComputedPropertyName, isRecordObjectInitializer = false): boolean {\n    const expr = computedProperty.expression;\n    if (!isRecordObjectInitializer) {\n      const symbol = this.trueSymbolAtLocation(expr);\n      if (!!symbol && this.isSymbolIterator(symbol)) {\n        return true;\n      }\n    }\n    // We allow computed property names if expression is string literal or string Enum member\n    return ts.isStringLiteralLike(expr) || this.isEnumStringLiteral(computedProperty.expression);\n  }\n\n  skipPropertyInferredTypeCheck(\n    decl: ts.PropertyDeclaration,\n    sourceFile: ts.SourceFile | undefined,\n    isEtsFileCb: IsEtsFileCallback | undefined\n  ): boolean {\n    if (!sourceFile) {\n      return false;\n    }\n\n    const isEts = this.useRtLogic ?\n      !!isEtsFileCb && isEtsFileCb(sourceFile) :\n      getScriptKind(sourceFile) === ts.ScriptKind.ETS;\n    return (\n      isEts &&\n      sourceFile.isDeclarationFile &&\n      !!decl.modifiers?.some((m) => {\n        return m.kind === ts.SyntaxKind.PrivateKeyword;\n      })\n    );\n  }\n\n  hasAccessModifier(decl: ts.HasModifiers): boolean {\n    const modifiers = ts.getModifiers(decl);\n    return (\n      !!modifiers &&\n      (!this.useRtLogic && TsUtils.hasModifier(modifiers, ts.SyntaxKind.ReadonlyKeyword) ||\n        TsUtils.hasModifier(modifiers, ts.SyntaxKind.PublicKeyword) ||\n        TsUtils.hasModifier(modifiers, ts.SyntaxKind.ProtectedKeyword) ||\n        TsUtils.hasModifier(modifiers, ts.SyntaxKind.PrivateKeyword))\n    );\n  }\n\n  static getModifier(\n    modifiers: readonly ts.Modifier[] | undefined,\n    modifierKind: ts.SyntaxKind\n  ): ts.Modifier | undefined {\n    if (!modifiers) {\n      return undefined;\n    }\n    return modifiers.find((x) => {\n      return x.kind === modifierKind;\n    });\n  }\n\n  static getAccessModifier(modifiers: readonly ts.Modifier[] | undefined): ts.Modifier | undefined {\n    return (\n      TsUtils.getModifier(modifiers, ts.SyntaxKind.PublicKeyword) ??\n      TsUtils.getModifier(modifiers, ts.SyntaxKind.ProtectedKeyword) ??\n      TsUtils.getModifier(modifiers, ts.SyntaxKind.PrivateKeyword)\n    );\n  }\n\n  static getBaseClassType(type: ts.Type): ts.InterfaceType | undefined {\n    const baseTypes = type.getBaseTypes();\n    if (baseTypes) {\n      for (const baseType of baseTypes) {\n        if (baseType.isClass()) {\n          return baseType;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  static destructuringAssignmentHasSpreadOperator(node: ts.AssignmentPattern): boolean {\n    if (ts.isArrayLiteralExpression(node)) {\n      return node.elements.some((x) => {\n        if (ts.isSpreadElement(x)) {\n          return true;\n        }\n        if (ts.isObjectLiteralExpression(x) || ts.isArrayLiteralExpression(x)) {\n          return TsUtils.destructuringAssignmentHasSpreadOperator(x);\n        }\n        return false;\n      });\n    }\n\n    return node.properties.some((x) => {\n      if (ts.isSpreadAssignment(x)) {\n        return true;\n      }\n      if (\n        ts.isPropertyAssignment(x) &&\n        (ts.isObjectLiteralExpression(x.initializer) || ts.isArrayLiteralExpression(x.initializer))\n      ) {\n        return TsUtils.destructuringAssignmentHasSpreadOperator(x.initializer);\n      }\n      return false;\n    });\n  }\n\n  static destructuringDeclarationHasSpreadOperator(node: ts.BindingPattern): boolean {\n    return node.elements.some((x) => {\n      if (ts.isBindingElement(x)) {\n        if (x.dotDotDotToken) {\n          return true;\n        }\n        if (ts.isArrayBindingPattern(x.name) || ts.isObjectBindingPattern(x.name)) {\n          return TsUtils.destructuringDeclarationHasSpreadOperator(x.name);\n        }\n      }\n      return false;\n    });\n  }\n\n  static hasNestedObjectDestructuring(node: ts.ArrayBindingOrAssignmentPattern): boolean {\n    if (ts.isArrayLiteralExpression(node)) {\n      return node.elements.some((x) => {\n        const elem = ts.isSpreadElement(x) ? x.expression : x;\n        if (ts.isArrayLiteralExpression(elem)) {\n          return TsUtils.hasNestedObjectDestructuring(elem);\n        }\n        return ts.isObjectLiteralExpression(elem);\n      });\n    }\n\n    return node.elements.some((x) => {\n      if (ts.isBindingElement(x)) {\n        if (ts.isArrayBindingPattern(x.name)) {\n          return TsUtils.hasNestedObjectDestructuring(x.name);\n        }\n        return ts.isObjectBindingPattern(x.name);\n      }\n      return false;\n    });\n  }\n\n  static getDecoratorName(decorator: ts.Decorator): string {\n    let decoratorName = '';\n    if (ts.isIdentifier(decorator.expression)) {\n      decoratorName = decorator.expression.text;\n    } else if (ts.isCallExpression(decorator.expression) && ts.isIdentifier(decorator.expression.expression)) {\n      decoratorName = decorator.expression.expression.text;\n    }\n    return decoratorName;\n  }\n\n  static unwrapParenthesizedTypeNode(typeNode: ts.TypeNode): ts.TypeNode {\n    let unwrappedTypeNode = typeNode;\n    while (ts.isParenthesizedTypeNode(unwrappedTypeNode)) {\n      unwrappedTypeNode = unwrappedTypeNode.type;\n    }\n\n    return unwrappedTypeNode;\n  }\n\n  isSendableTypeNode(typeNode: ts.TypeNode): boolean {\n\n    /*\n     * In order to correctly identify the usage of the enum member or\n     * const enum in type annotation, we need to handle union type and\n     * type alias cases by processing the type node and checking the\n     * symbol in case of type reference node.\n     */\n\n    typeNode = TsUtils.unwrapParenthesizedTypeNode(typeNode);\n\n    // Only a sendable union type is supported\n    if (ts.isUnionTypeNode(typeNode)) {\n      return typeNode.types.every((elemType) => {\n        return this.isSendableTypeNode(elemType);\n      });\n    }\n\n    const sym = ts.isTypeReferenceNode(typeNode) ? this.trueSymbolAtLocation(typeNode.typeName) : undefined;\n\n    if (sym && sym.getFlags() & ts.SymbolFlags.TypeAlias) {\n      const typeDecl = TsUtils.getDeclaration(sym);\n      if (typeDecl && ts.isTypeAliasDeclaration(typeDecl)) {\n        return this.isSendableTypeNode(typeDecl.type);\n      }\n    }\n\n    // Const enum type is supported\n    if (TsUtils.isConstEnum(sym)) {\n      return true;\n    }\n\n    return this.isSendableType(this.tsTypeChecker.getTypeFromTypeNode(typeNode));\n  }\n\n  isSendableType(type: ts.Type): boolean {\n    if (\n      (type.flags &\n        (ts.TypeFlags.Boolean |\n          ts.TypeFlags.Number |\n          ts.TypeFlags.String |\n          ts.TypeFlags.BigInt |\n          ts.TypeFlags.Null |\n          ts.TypeFlags.Undefined |\n          ts.TypeFlags.TypeParameter)) !==\n      0\n    ) {\n      return true;\n    }\n\n    return this.isSendableClassOrInterface(type);\n  }\n\n  isShareableType(tsType: ts.Type): boolean {\n    const sym = tsType.getSymbol();\n    if (TsUtils.isConstEnum(sym)) {\n      return true;\n    }\n\n    if (tsType.isUnion()) {\n      return tsType.types.every((elemType) => {\n        return this.isShareableType(elemType);\n      });\n    }\n\n    return this.isSendableType(tsType);\n  }\n\n  isSendableClassOrInterface(type: ts.Type): boolean {\n    const sym = type.getSymbol();\n    if (!sym) {\n      return false;\n    }\n\n    const targetType = TsUtils.reduceReference(type);\n\n    // class with @Sendable decorator\n    if (targetType.isClass()) {\n      if (sym.declarations?.length) {\n        const decl = sym.declarations[0];\n        if (ts.isClassDeclaration(decl)) {\n          return TsUtils.hasSendableDecorator(decl);\n        }\n      }\n    }\n    // ISendable interface, or a class/interface that implements/extends ISendable interface\n    return this.isOrDerivedFrom(type, TsUtils.isISendableInterface);\n  }\n\n  typeContainsSendableClassOrInterface(type: ts.Type): boolean {\n    // Only check type contains sendable class / interface\n    if ((type.flags & ts.TypeFlags.Union) !== 0) {\n      return !!(type as ts.UnionType)?.types?.some((type) => {\n        return this.typeContainsSendableClassOrInterface(type);\n      });\n    }\n\n    return this.isSendableClassOrInterface(type);\n  }\n\n  static isConstEnum(sym: ts.Symbol | undefined): boolean {\n    return !!sym && sym.flags === ts.SymbolFlags.ConstEnum;\n  }\n\n  isSendableUnionType(type: ts.UnionType): boolean {\n    const types = type?.types;\n    if (!types) {\n      return false;\n    }\n\n    return types.every((type) => {\n      return this.isSendableType(type);\n    });\n  }\n\n  static hasSendableDecorator(decl: ts.ClassDeclaration): boolean {\n    const decorators = ts.getDecorators(decl);\n    return !!decorators?.some((x) => {\n      return TsUtils.getDecoratorName(x) === SENDABLE_DECORATOR;\n    });\n  }\n\n  static getNonSendableDecorators(decl: ts.ClassDeclaration): ts.Decorator[] | undefined {\n    const decorators = ts.getDecorators(decl);\n    return decorators?.filter((x) => {\n      return TsUtils.getDecoratorName(x) !== SENDABLE_DECORATOR;\n    });\n  }\n\n  static getDecoratorsIfInSendableClass(declaration: ts.HasDecorators): readonly ts.Decorator[] | undefined {\n    const classNode = TsUtils.getClassNodeFromDeclaration(declaration);\n    if (classNode === undefined || !TsUtils.hasSendableDecorator(classNode)) {\n      return undefined;\n    }\n    return ts.getDecorators(declaration);\n  }\n\n  private static getClassNodeFromDeclaration(declaration: ts.HasDecorators): ts.ClassDeclaration | undefined {\n    if (declaration.kind === ts.SyntaxKind.Parameter) {\n      return ts.isClassDeclaration(declaration.parent.parent) ? declaration.parent.parent : undefined;\n    }\n    return ts.isClassDeclaration(declaration.parent) ? declaration.parent : undefined;\n  }\n\n  static isISendableInterface(type: ts.Type): boolean {\n    const symbol = type.aliasSymbol ?? type.getSymbol();\n    if (symbol?.declarations === undefined || symbol.declarations.length < 1) {\n      return false;\n    }\n\n    return TsUtils.isArkTSISendableDeclaration(symbol.declarations[0]);\n  }\n\n  private static isArkTSISendableDeclaration(decl: ts.Declaration): boolean {\n    if (!ts.isInterfaceDeclaration(decl) || !decl.name || decl.name.text !== ISENDABLE_TYPE) {\n      return false;\n    }\n\n    if (!ts.isModuleBlock(decl.parent) || decl.parent.parent.name.text !== LANG_NAMESPACE) {\n      return false;\n    }\n\n    if (path.basename(decl.getSourceFile().fileName).toLowerCase() !== ARKTS_LANG_D_ETS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isAllowedIndexSignature(node: ts.IndexSignatureDeclaration): boolean {\n\n    /*\n     * For now, relax index signature only for specific array-like types\n     * with the following signature: 'collections.Array<T>.[_: number]: T'.\n     */\n\n    if (node.parameters.length !== 1) {\n      return false;\n    }\n\n    const paramType = this.tsTypeChecker.getTypeAtLocation(node.parameters[0]);\n    if ((paramType.flags & ts.TypeFlags.Number) === 0) {\n      return false;\n    }\n\n    return this.isArkTSCollectionsArrayLikeDeclaration(node.parent);\n  }\n\n  isArkTSCollectionsArrayLikeType(type: ts.Type): boolean {\n    const symbol = type.aliasSymbol ?? type.getSymbol();\n    if (symbol?.declarations === undefined || symbol.declarations.length < 1) {\n      return false;\n    }\n\n    return this.isArkTSCollectionsArrayLikeDeclaration(symbol.declarations[0]);\n  }\n\n  private isArkTSCollectionsArrayLikeDeclaration(decl: ts.Declaration): boolean {\n    if (!ts.isClassDeclaration(decl) && !ts.isInterfaceDeclaration(decl) || !decl.name) {\n      return false;\n    }\n\n    if (!this.tsTypeChecker.getTypeAtLocation(decl).getNumberIndexType()) {\n      return false;\n    }\n\n    if (!ts.isModuleBlock(decl.parent) || decl.parent.parent.name.text !== COLLECTIONS_NAMESPACE) {\n      return false;\n    }\n\n    if (path.basename(decl.getSourceFile().fileName).toLowerCase() !== ARKTS_COLLECTIONS_D_ETS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private proceedConstructorDeclaration(\n    isFromPrivateIdentifierOrSdk: boolean,\n    targetMember: ts.ClassElement,\n    classMember: ts.ClassElement,\n    isFromPrivateIdentifier: boolean\n  ): boolean | undefined {\n    if (\n      isFromPrivateIdentifierOrSdk &&\n      ts.isConstructorDeclaration(classMember) &&\n      classMember.parameters.some((x) => {\n        return (\n          ts.isIdentifier(x.name) &&\n          this.hasAccessModifier(x) &&\n          this.isPrivateIdentifierDuplicateOfIdentifier(\n            targetMember.name as ts.Identifier,\n            x.name,\n            isFromPrivateIdentifier\n          )\n        );\n      })\n    ) {\n      return true;\n    }\n    return undefined;\n  }\n\n  private proceedClassType(\n    targetMember: ts.ClassElement,\n    classType: ts.Type,\n    isFromPrivateIdentifier: boolean\n  ): boolean | undefined {\n    if (classType) {\n      const baseType = TsUtils.getBaseClassType(classType);\n      if (baseType) {\n        const baseDecl = baseType.getSymbol()?.valueDeclaration as ts.ClassLikeDeclaration;\n        if (baseDecl) {\n          return this.classMemberHasDuplicateName(targetMember, baseDecl, isFromPrivateIdentifier);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  classMemberHasDuplicateName(\n    targetMember: ts.ClassElement,\n    tsClassLikeDecl: ts.ClassLikeDeclaration,\n    isFromPrivateIdentifier: boolean,\n    classType?: ts.Type\n  ): boolean {\n\n    /*\n     * If two class members have the same name where one is a private identifer,\n     * then such members are considered to have duplicate names.\n     */\n    if (!TsUtils.isIdentifierOrPrivateIdentifier(targetMember.name)) {\n      return false;\n    }\n\n    const isFromPrivateIdentifierOrSdk = this.isFromPrivateIdentifierOrSdk(isFromPrivateIdentifier);\n    for (const classMember of tsClassLikeDecl.members) {\n      if (targetMember === classMember) {\n        continue;\n      }\n\n      // Check constructor parameter properties.\n      const constructorDeclarationProceedResult = this.proceedConstructorDeclaration(\n        isFromPrivateIdentifierOrSdk,\n        targetMember,\n        classMember,\n        isFromPrivateIdentifier\n      );\n      if (constructorDeclarationProceedResult) {\n        return constructorDeclarationProceedResult;\n      }\n      if (!TsUtils.isIdentifierOrPrivateIdentifier(classMember.name)) {\n        continue;\n      }\n      if (this.isPrivateIdentifierDuplicateOfIdentifier(targetMember.name, classMember.name, isFromPrivateIdentifier)) {\n        return true;\n      }\n    }\n\n    if (isFromPrivateIdentifierOrSdk) {\n      classType ??= this.tsTypeChecker.getTypeAtLocation(tsClassLikeDecl);\n      const proceedClassTypeResult = this.proceedClassType(targetMember, classType, isFromPrivateIdentifier);\n      if (proceedClassTypeResult) {\n        return proceedClassTypeResult;\n      }\n    }\n\n    return false;\n  }\n\n  private isFromPrivateIdentifierOrSdk(isFromPrivateIdentifier: boolean): boolean {\n    return this.useRtLogic || isFromPrivateIdentifier;\n  }\n\n  private static isIdentifierOrPrivateIdentifier(node?: ts.PropertyName): node is ts.Identifier | ts.PrivateIdentifier {\n    if (!node) {\n      return false;\n    }\n    return ts.isIdentifier(node) || ts.isPrivateIdentifier(node);\n  }\n\n  private isPrivateIdentifierDuplicateOfIdentifier(\n    ident1: ts.Identifier | ts.PrivateIdentifier,\n    ident2: ts.Identifier | ts.PrivateIdentifier,\n    isFromPrivateIdentifier: boolean\n  ): boolean {\n    if (ts.isIdentifier(ident1) && ts.isPrivateIdentifier(ident2)) {\n      return ident1.text === ident2.text.substring(1);\n    }\n    if (ts.isIdentifier(ident2) && ts.isPrivateIdentifier(ident1)) {\n      return ident2.text === ident1.text.substring(1);\n    }\n    if (\n      this.isFromPrivateIdentifierOrSdk(isFromPrivateIdentifier) &&\n      ts.isPrivateIdentifier(ident1) &&\n      ts.isPrivateIdentifier(ident2)\n    ) {\n      return ident1.text.substring(1) === ident2.text.substring(1);\n    }\n    return false;\n  }\n\n  findIdentifierNameForSymbol(symbol: ts.Symbol): string | undefined {\n    let name = TsUtils.getIdentifierNameFromString(symbol.name);\n    if (name === undefined || name === symbol.name) {\n      return name;\n    }\n\n    const parentType = this.getTypeByProperty(symbol);\n    if (parentType === undefined) {\n      return undefined;\n    }\n\n    while (this.findProperty(parentType, name) !== undefined) {\n      name = '_' + name;\n    }\n\n    return name;\n  }\n\n  private static getIdentifierNameFromString(str: string): string | undefined {\n    let result: string = '';\n\n    let offset = 0;\n    while (offset < str.length) {\n      const codePoint = str.codePointAt(offset);\n      if (!codePoint) {\n        return undefined;\n      }\n\n      const charSize = TsUtils.charSize(codePoint);\n\n      if (offset === 0 && !ts.isIdentifierStart(codePoint, undefined)) {\n        result = '__';\n      }\n\n      if (!ts.isIdentifierPart(codePoint, undefined)) {\n        if (codePoint === 0x20) {\n          result += '_';\n        } else {\n          result += 'x' + codePoint.toString(16);\n        }\n      } else {\n        for (let i = 0; i < charSize; i++) {\n          result += str.charAt(offset + i);\n        }\n      }\n\n      offset += charSize;\n    }\n\n    return result;\n  }\n\n  private static charSize(codePoint: number): number {\n    return codePoint >= 0x10000 ? 2 : 1;\n  }\n\n  private getTypeByProperty(symbol: ts.Symbol): ts.Type | undefined {\n    if (symbol.declarations === undefined) {\n      return undefined;\n    }\n\n    for (const propDecl of symbol.declarations) {\n      if (\n        !ts.isPropertyDeclaration(propDecl) &&\n        !ts.isPropertyAssignment(propDecl) &&\n        !ts.isPropertySignature(propDecl)\n      ) {\n        return undefined;\n      }\n\n      const type = this.tsTypeChecker.getTypeAtLocation(propDecl.parent);\n      if (type !== undefined) {\n        return type;\n      }\n    }\n\n    return undefined;\n  }\n\n  static isPropertyOfInternalClassOrInterface(symbol: ts.Symbol): boolean {\n    if (symbol.declarations === undefined) {\n      return false;\n    }\n\n    for (const propDecl of symbol.declarations) {\n      if (!ts.isPropertyDeclaration(propDecl) && !ts.isPropertySignature(propDecl)) {\n        return false;\n      }\n\n      if (!ts.isClassDeclaration(propDecl.parent) && !ts.isInterfaceDeclaration(propDecl.parent)) {\n        return false;\n      }\n\n      if (TsUtils.hasModifier(ts.getModifiers(propDecl.parent), ts.SyntaxKind.ExportKeyword)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static isIntrinsicObjectType(type: ts.Type): boolean {\n    return !!(type.flags & ts.TypeFlags.NonPrimitive);\n  }\n\n  isStringType(tsType: ts.Type): boolean {\n    if ((tsType.getFlags() & ts.TypeFlags.String) !== 0) {\n      return true;\n    }\n\n    if (!TsUtils.isTypeReference(tsType)) {\n      return false;\n    }\n\n    const symbol = tsType.symbol;\n    const name = this.tsTypeChecker.getFullyQualifiedName(symbol);\n    return name === 'String' && this.isGlobalSymbol(symbol);\n  }\n\n  isStdMapType(type: ts.Type): boolean {\n    const sym = type.symbol;\n    return !!sym && sym.getName() === 'Map' && this.isGlobalSymbol(sym);\n  }\n\n  hasGenericTypeParameter(type: ts.Type): boolean {\n    if (type.isUnionOrIntersection()) {\n      return type.types.some((x) => {\n        return this.hasGenericTypeParameter(x);\n      });\n    }\n    if (TsUtils.isTypeReference(type)) {\n      const typeArgs = this.tsTypeChecker.getTypeArguments(type);\n      return typeArgs.some((x) => {\n        return this.hasGenericTypeParameter(x);\n      });\n    }\n    return type.isTypeParameter();\n  }\n\n  static getEnclosingTopLevelStatement(node: ts.Node): ts.Node | undefined {\n    return ts.findAncestor(node, (ancestor) => {\n      return ts.isSourceFile(ancestor.parent);\n    });\n  }\n\n  static isDeclarationStatement(node: ts.Node): node is ts.DeclarationStatement {\n    const kind = node.kind;\n    return (\n      kind === ts.SyntaxKind.FunctionDeclaration ||\n      kind === ts.SyntaxKind.ModuleDeclaration ||\n      kind === ts.SyntaxKind.ClassDeclaration ||\n      kind === ts.SyntaxKind.StructDeclaration ||\n      kind === ts.SyntaxKind.TypeAliasDeclaration ||\n      kind === ts.SyntaxKind.InterfaceDeclaration ||\n      kind === ts.SyntaxKind.EnumDeclaration ||\n      kind === ts.SyntaxKind.MissingDeclaration ||\n      kind === ts.SyntaxKind.ImportEqualsDeclaration ||\n      kind === ts.SyntaxKind.ImportDeclaration ||\n      kind === ts.SyntaxKind.NamespaceExportDeclaration\n    );\n  }\n\n  static declarationNameExists(srcFile: ts.SourceFile, name: string): boolean {\n    return srcFile.statements.some((stmt) => {\n      if (ts.isImportDeclaration(stmt)) {\n        if (!stmt.importClause) {\n          return false;\n        }\n        if (stmt.importClause.namedBindings) {\n          if (ts.isNamespaceImport(stmt.importClause.namedBindings)) {\n            return stmt.importClause.namedBindings.name.text === name;\n          }\n          return stmt.importClause.namedBindings.elements.some((x) => {\n            return x.name.text === name;\n          });\n        }\n        return stmt.importClause.name?.text === name;\n      }\n\n      return (\n        TsUtils.isDeclarationStatement(stmt) &&\n        stmt.name !== undefined &&\n        ts.isIdentifier(stmt.name) &&\n        stmt.name.text === name\n      );\n    });\n  }\n\n  static generateUniqueName(nameGenerator: NameGenerator, srcFile: ts.SourceFile): string | undefined {\n    let newName: string | undefined;\n\n    do {\n      newName = nameGenerator.getName();\n      if (newName !== undefined && TsUtils.declarationNameExists(srcFile, newName)) {\n        continue;\n      }\n      break;\n    } while (newName !== undefined);\n\n    return newName;\n  }\n\n  static isSharedModule(sourceFile: ts.SourceFile): boolean {\n    const statements = sourceFile.statements;\n    for (const statement of statements) {\n      if (ts.isImportDeclaration(statement)) {\n        continue;\n      }\n\n      return (\n        ts.isExpressionStatement(statement) &&\n        ts.isStringLiteral(statement.expression) &&\n        statement.expression.text === USE_SHARED\n      );\n    }\n    return false;\n  }\n\n  getDeclarationNode(node: ts.Node): ts.Declaration | undefined {\n    const sym = this.trueSymbolAtLocation(node);\n    return TsUtils.getDeclaration(sym);\n  }\n\n  static isFunctionLikeDeclaration(node: ts.Declaration): boolean {\n    return (\n      ts.isFunctionDeclaration(node) ||\n      ts.isMethodDeclaration(node) ||\n      ts.isGetAccessorDeclaration(node) ||\n      ts.isSetAccessorDeclaration(node) ||\n      ts.isConstructorDeclaration(node) ||\n      ts.isFunctionExpression(node) ||\n      ts.isArrowFunction(node)\n    );\n  }\n\n  isShareableEntity(node: ts.Node): boolean {\n    const decl = this.getDeclarationNode(node);\n    const typeNode = (decl as any)?.type;\n    return typeNode && !TsUtils.isFunctionLikeDeclaration(decl!) ?\n      this.isSendableTypeNode(typeNode) :\n      this.isShareableType(this.tsTypeChecker.getTypeAtLocation(decl ? decl : node));\n  }\n\n  isSendableClassOrInterfaceEntity(node: ts.Node): boolean {\n    const decl = this.getDeclarationNode(node);\n    if (!decl) {\n      return false;\n    }\n    if (ts.isClassDeclaration(decl)) {\n      return TsUtils.hasSendableDecorator(decl);\n    }\n    if (ts.isInterfaceDeclaration(decl)) {\n      return this.isOrDerivedFrom(this.tsTypeChecker.getTypeAtLocation(decl), TsUtils.isISendableInterface);\n    }\n    return false;\n  }\n\n  static isInImportWhiteList(resolvedModule: ts.ResolvedModuleFull): boolean {\n    if (\n      !resolvedModule.resolvedFileName ||\n      path.basename(resolvedModule.resolvedFileName).toLowerCase() !== ARKTS_LANG_D_ETS &&\n        path.basename(resolvedModule.resolvedFileName).toLowerCase() !== ARKTS_COLLECTIONS_D_ETS\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  isClassNodeReference(node: ts.Node): boolean {\n    // handle union type node\n    if (ts.isUnionTypeNode(node)) {\n      return node.types.every((elemType) => {\n        return this.isClassNode(elemType);\n      });\n    }\n    return this.isClassNode(node);\n  }\n\n  isClassNode(node: ts.Node): boolean {\n    const decl = this.getDeclarationNode(node);\n    return decl ? ts.isClassDeclaration(decl) : false;\n  }\n}\n"],"mappings":";;;;;;AAeA,IAAAA,IAAA,GAAAC,uBAAA,CAAAC,OAAA;AACA,IAAAC,EAAA,GAAAF,uBAAA,CAAAC,OAAA;AAEA,IAAAE,SAAA,GAAAF,OAAA;AACA,IAAAG,iBAAA,GAAAH,OAAA;AACA,IAAAI,SAAA,GAAAJ,OAAA;AACA,IAAAK,YAAA,GAAAL,OAAA;AACA,IAAAM,gBAAA,GAAAN,OAAA;AACA,IAAAO,kBAAA,GAAAP,OAAA;AACA,IAAAQ,4BAAA,GAAAR,OAAA;AAOA,IAAAS,YAAA,GAAAT,OAAA;AACA,IAAAU,qBAAA,GAAAV,OAAA;AACA,IAAAW,cAAA,GAAAX,OAAA;AACA,IAAAY,aAAA,GAAAZ,OAAA;AACA,IAAAa,SAAA,GAAAb,OAAA;AAEA,IAAAc,WAAA,GAAAd,OAAA;AACA,IAAAe,qBAAA,GAAAf,OAAA;AACA,IAAAgB,sBAAA,GAAAhB,OAAA;AAA0E,IAAAiB,QAAA;AAAA,SAAAC,yBAAAC,CAAA,6BAAAC,OAAA,mBAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,CAAA,WAAAA,CAAA,GAAAG,CAAA,GAAAD,CAAA,KAAAF,CAAA;AAAA,SAAApB,wBAAAoB,CAAA,EAAAE,CAAA,SAAAA,CAAA,IAAAF,CAAA,IAAAA,CAAA,CAAAI,UAAA,SAAAJ,CAAA,eAAAA,CAAA,uBAAAA,CAAA,yBAAAA,CAAA,WAAAK,OAAA,EAAAL,CAAA,QAAAG,CAAA,GAAAJ,wBAAA,CAAAG,CAAA,OAAAC,CAAA,IAAAA,CAAA,CAAAG,GAAA,CAAAN,CAAA,UAAAG,CAAA,CAAAI,GAAA,CAAAP,CAAA,OAAAQ,CAAA,KAAAC,SAAA,UAAAC,CAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,CAAA,IAAAd,CAAA,oBAAAc,CAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,CAAA,SAAAG,CAAA,GAAAP,CAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAb,CAAA,EAAAc,CAAA,UAAAG,CAAA,KAAAA,CAAA,CAAAV,GAAA,IAAAU,CAAA,CAAAC,GAAA,IAAAP,MAAA,CAAAC,cAAA,CAAAJ,CAAA,EAAAM,CAAA,EAAAG,CAAA,IAAAT,CAAA,CAAAM,CAAA,IAAAd,CAAA,CAAAc,CAAA,YAAAN,CAAA,CAAAH,OAAA,GAAAL,CAAA,EAAAG,CAAA,IAAAA,CAAA,CAAAe,GAAA,CAAAlB,CAAA,EAAAQ,CAAA,GAAAA,CAAA;AAAA,SAAAW,eAAAX,CAAA,EAAAN,CAAA,QAAAM,CAAA,KAAAN,CAAA,YAAAkB,SAAA;AAAA,SAAAC,gBAAArB,CAAA,EAAAE,CAAA,EAAAC,CAAA,YAAAD,CAAA,GAAAoB,cAAA,CAAApB,CAAA,MAAAF,CAAA,GAAAW,MAAA,CAAAC,cAAA,CAAAZ,CAAA,EAAAE,CAAA,IAAAqB,KAAA,EAAApB,CAAA,EAAAqB,UAAA,MAAAC,YAAA,MAAAC,QAAA,UAAA1B,CAAA,CAAAE,CAAA,IAAAC,CAAA,EAAAH,CAAA;AAAA,SAAAsB,eAAAnB,CAAA,QAAAc,CAAA,GAAAU,YAAA,CAAAxB,CAAA,uCAAAc,CAAA,GAAAA,CAAA,GAAAA,CAAA;AAAA,SAAAU,aAAAxB,CAAA,EAAAD,CAAA,2BAAAC,CAAA,KAAAA,CAAA,SAAAA,CAAA,MAAAH,CAAA,GAAAG,CAAA,CAAAyB,MAAA,CAAAC,WAAA,kBAAA7B,CAAA,QAAAiB,CAAA,GAAAjB,CAAA,CAAAgB,IAAA,CAAAb,CAAA,EAAAD,CAAA,uCAAAe,CAAA,SAAAA,CAAA,YAAAG,SAAA,yEAAAlB,CAAA,GAAA4B,MAAA,GAAAC,MAAA,EAAA5B,CAAA,KAvC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4BO,MAAM6B,MAAM,GAAAC,OAAA,CAAAD,MAAA,GAAG,QAAQ;AACvB,MAAME,kBAAkB,GAAAD,OAAA,CAAAC,kBAAA,GAAG,mBAAmB;AACrD,MAAMC,QAAQ,GAAG,UAAU;AAGpB,MAAMC,OAAO,CAAC;EACnBC,WAAWA,CACQC,aAA6B,EAC7BC,QAAiB,EACjBC,mBAA4B,EAC5BC,UAAmB,EACpC;IAAA,KAJiBH,aAA6B,GAA7BA,aAA6B;IAAA,KAC7BC,QAAiB,GAAjBA,QAAiB;IAAA,KACjBC,mBAA4B,GAA5BA,mBAA4B;IAAA,KAC5BC,UAAmB,GAAnBA,UAAmB;IAAApB,eAAA,oCAoGO,IAAIqB,GAAG,CAA4B,CAAC;EAnG9E;EAEHC,kBAAkBA,CAACC,IAAmB,EAAU;IAC9C,IAAI9D,EAAE,CAAC+D,YAAY,CAACD,IAAI,CAAC,EAAE;MACzB,OAAOA,IAAI,CAACE,WAAW,CAACC,QAAQ,CAAC,CAAC;IACpC;IACA,OAAO,IAAI,CAACJ,kBAAkB,CAACC,IAAI,CAACI,IAAI,CAAC,GAAG,IAAI,CAACL,kBAAkB,CAACC,IAAI,CAACK,KAAK,CAAC;EACjF;EAEAC,gBAAgBA,CAACC,MAAe,EAAW;IACzC,IAAI,IAAI,CAACV,UAAU,IAAIU,MAAM,CAACC,OAAO,CAAC,CAAC,EAAE;MACvC,KAAK,MAAMC,UAAU,IAAIF,MAAM,CAACG,KAAK,EAAE;QACrC,IAAI,CAACD,UAAU,CAACE,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACC,UAAU,MAAM,CAAC,EAAE;UACtD,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;IACA,OAAO,CAACN,MAAM,CAACO,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC0E,SAAS,CAACC,UAAU,MAAM,CAAC;EAC5D;EAEA,OAAOE,iBAAiBA,CAACR,MAAe,EAAW;IACjD,OAAO,CAACA,MAAM,CAACO,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC0E,SAAS,CAACI,WAAW,MAAM,CAAC;EAC7D;EAEA,OAAOC,4BAA4BA,CAACC,MAA8D,EAAW;IAE3G;AACJ;AACA;AACA;IACI,IAAIC,QAAQ,GAAGD,MAAM,CAACE,MAAM;IAC5B,IAAIC,aAAsB,GAAGH,MAAM;IACnC,OAAOC,QAAQ,EAAE;MACf,IACEjF,EAAE,CAACoF,kBAAkB,CAACH,QAAQ,CAAC,IAC/B,IAAAI,0CAAoB,EAACJ,QAAQ,CAACK,aAAa,CAAC,IAC5CL,QAAQ,CAACf,IAAI,KAAKiB,aAAa,EAC/B;QACA,OAAO,IAAI;MACb;MAEA,IACE,CAACnF,EAAE,CAACuF,cAAc,CAACN,QAAQ,CAAC,IAAIjF,EAAE,CAACwF,gBAAgB,CAACP,QAAQ,CAAC,IAAIjF,EAAE,CAACyF,gBAAgB,CAACR,QAAQ,CAAC,KAC9FA,QAAQ,CAACS,WAAW,IACpBT,QAAQ,CAACS,WAAW,KAAKP,aAAa,EACtC;QACA,OAAO,IAAI;MACb;MAEAA,aAAa,GAAGF,QAAQ;MACxBA,QAAQ,GAAGA,QAAQ,CAACC,MAAM;IAC5B;IAEA,OAAO,KAAK;EACd;EAEA,OAAOS,UAAUA,CAACtB,MAAe,EAAW;IAC1C;IACA,MAAMuB,YAAY,GAAGvB,MAAM,CAACwB,MAAM,IAAI,IAAI,CAACC,MAAM,CAACzB,MAAM,CAACwB,MAAM,CAAC;IAChE;IACA,MAAMF,UAAU,GAAG,CAAC,EAAEtB,MAAM,CAACI,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACqB,IAAI,CAAC,IAAI,CAAC,EAAE1B,MAAM,CAACI,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACsB,WAAW,CAAC;IACtG,OAAOJ,YAAY,IAAID,UAAU;EACnC;EAEA,OAAOG,MAAMA,CAACG,QAAmB,EAAW;IAC1C,OAAO,CAAC,EAAEA,QAAQ,CAACxB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACH,IAAI,CAAC;EACjD;EAEA,OAAOI,WAAWA,CAACC,WAA+C,EAAEC,cAAsB,EAAW;IACnG,IAAI,CAACD,WAAW,EAAE;MAChB,OAAO,KAAK;IACd;IAEA,KAAK,MAAME,UAAU,IAAIF,WAAW,EAAE;MACpC,IAAIE,UAAU,CAACC,IAAI,KAAKF,cAAc,EAAE;QACtC,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAOG,mBAAmBA,CAACxB,MAAqB,EAAiB;IAC/D,IAAIyB,aAAa,GAAGzB,MAAM;IAC1B,OAAOhF,EAAE,CAAC0G,yBAAyB,CAACD,aAAa,CAAC,EAAE;MAClDA,aAAa,GAAGA,aAAa,CAACE,UAAU;IAC1C;IAEA,OAAOF,aAAa;EACtB;EAEAG,eAAeA,CAACC,GAAc,EAAa;IACzC,IAAI,CAACA,GAAG,CAACjC,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAACkG,WAAW,CAACY,KAAK,MAAM,CAAC,EAAE;MACjD,OAAO,IAAI,CAACtD,aAAa,CAACuD,gBAAgB,CAACF,GAAG,CAAC;IACjD;IACA,OAAOA,GAAG;EACZ;EAIAG,oBAAoBA,CAACC,IAAa,EAAyB;IACzD,MAAMC,KAAK,GAAG,IAAI,CAACC,yBAAyB;IAC5C,MAAMC,GAAG,GAAGF,KAAK,CAACzF,GAAG,CAACwF,IAAI,CAAC;IAC3B,IAAIG,GAAG,KAAKC,SAAS,EAAE;MACrB,OAAOD,GAAG,KAAK,IAAI,GAAGA,GAAG,GAAGC,SAAS;IACvC;IACA,IAAIR,GAAG,GAAG,IAAI,CAACrD,aAAa,CAAC8D,mBAAmB,CAACL,IAAI,CAAC;IACtD,IAAIJ,GAAG,KAAKQ,SAAS,EAAE;MACrBH,KAAK,CAAC9E,GAAG,CAAC6E,IAAI,EAAE,IAAI,CAAC;MACrB,OAAOI,SAAS;IAClB;IACAR,GAAG,GAAG,IAAI,CAACD,eAAe,CAACC,GAAG,CAAC;IAC/BK,KAAK,CAAC9E,GAAG,CAAC6E,IAAI,EAAEJ,GAAG,CAAC;IACpB,OAAOA,GAAG;EACZ;EAEA,OAAeU,oBAAoBA,CAAChB,IAAmB,EAAW;IAChE,OACE,IAAAiB,iCAAuB,EAACjB,IAAI,CAAC,IAC7BA,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACC,eAAe,IACtCnB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACE,gBAAgB,IACvCpB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACG,oBAAoB,IAC3CrB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACI,oBAAoB;EAE/C;EAEA,OAAOC,sBAAsBA,CAACjC,MAAiB,EAAEkC,UAAyB,EAAW;IAEnF;AACJ;AACA;AACA;AACA;IACI,MAAMC,WAAW,GAAGnC,MAAM,EAAEoC,eAAe,CAAC,CAAC;IAC7C,IAAID,WAAW,EAAE;MACf,KAAK,MAAME,OAAO,IAAIF,WAAW,EAAE;QACjC,MAAMG,QAAQ,GAAGD,OAAO,CAAC3B,IAAI;QAC7B;QACA,MAAM6B,wBAAwB,GAC5B9E,OAAO,CAACiE,oBAAoB,CAACY,QAAQ,CAAC,IAAIJ,UAAU,KAAK/H,EAAE,CAACyH,UAAU,CAACY,iBAAiB,IACxF/E,OAAO,CAACiE,oBAAoB,CAACQ,UAAU,CAAC,IAAII,QAAQ,KAAKnI,EAAE,CAACyH,UAAU,CAACY,iBAAiB;;QAE1F;AACR;AACA;AACA;QACQ,IAAIF,QAAQ,KAAKnI,EAAE,CAACyH,UAAU,CAACa,UAAU,IAAIH,QAAQ,KAAKJ,UAAU,IAAI,CAACK,wBAAwB,EAAE;UACjG,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAOG,eAAeA,CAACC,IAAa,EAAW;IAC7C,MAAMC,CAAC,GAAGD,IAAI,CAAC5D,QAAQ,CAAC,CAAC;IACzB,OACE,CAAC6D,CAAC,GAAGzI,EAAE,CAAC0E,SAAS,CAACgE,OAAO,MAAM,CAAC,IAChC,CAACD,CAAC,GAAGzI,EAAE,CAAC0E,SAAS,CAACiE,cAAc,MAAM,CAAC,IACvC,CAACF,CAAC,GAAGzI,EAAE,CAAC0E,SAAS,CAACzB,MAAM,MAAM,CAAC,IAC/B,CAACwF,CAAC,GAAGzI,EAAE,CAAC0E,SAAS,CAACkE,aAAa,MAAM;;IAEvC;AACJ;AACA;AACA;AACA,OAJI;EAMF;EAEA,OAAOC,YAAYA,CAAChD,MAA6B,EAAW;IAC1D,OACE,CAAC,CAACA,MAAM,IACR,CAAC,CAACA,MAAM,CAACpB,KAAK,KACb,CAACoB,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAAC4C,KAAK,MAAM,CAAC,IAAI,CAACjD,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAAC6C,SAAS,MAAM,CAAC,CAAC;EAEpG;;EAEA;EACA,OAAOC,kBAAkBA,CAAC3E,MAAe,EAA8B;IACrE,OACEf,OAAO,CAAC2F,eAAe,CAAC5E,MAAM,CAAC,IAC/BA,MAAM,CAAC6E,aAAa,EAAEC,MAAM,KAAK,CAAC,IAClC9E,MAAM,CAAC+E,MAAM,CAACC,cAAc,EAAEF,MAAM,KAAK,CAAC,IAC1C9E,MAAM,CAACiF,SAAS,CAAC,CAAC,EAAEC,OAAO,CAAC,CAAC,KAAK,OAAO;EAE7C;EAEA,OAAOC,mBAAmBA,CAACnF,MAAe,EAAW;IACnD,OACEf,OAAO,CAAC2F,eAAe,CAAC5E,MAAM,CAAC,IAC/BA,MAAM,CAAC6E,aAAa,EAAEC,MAAM,KAAK,CAAC,IAClC9E,MAAM,CAAC+E,MAAM,CAACC,cAAc,EAAEF,MAAM,KAAK,CAAC,IAC1C9E,MAAM,CAACiF,SAAS,CAAC,CAAC,EAAEC,OAAO,CAAC,CAAC,KAAK,eAAe;EAErD;EAEAE,YAAYA,CAACpF,MAAe,EAAW;IACrC,MAAMwB,MAAM,GAAGxB,MAAM,CAACwB,MAAM;IAC5B,IAAI,CAACA,MAAM,EAAE;MACX,OAAO,KAAK;IACd;IACA,MAAM/B,IAAI,GAAG,IAAI,CAACN,aAAa,CAACkG,qBAAqB,CAAC7D,MAAM,CAAC;IAC7D,OAAO,IAAI,CAAC8D,cAAc,CAAC9D,MAAM,CAAC,IAAI+D,yBAAY,CAACC,QAAQ,CAAC/F,IAAI,CAAC;EACnE;EAEAgG,OAAOA,CAACzF,MAAe,EAAW;IAChC,OAAOf,OAAO,CAAC0F,kBAAkB,CAAC3E,MAAM,CAAC,IAAIf,OAAO,CAACkG,mBAAmB,CAACnF,MAAM,CAAC,IAAI,IAAI,CAACoF,YAAY,CAACpF,MAAM,CAAC;EAC/G;EAEA,OAAO0F,OAAOA,CAAC1F,MAAe,EAAW;IACvC,OAAOf,OAAO,CAAC2F,eAAe,CAAC5E,MAAM,CAAC,IAAI,CAAC,EAAEA,MAAM,CAAC2F,WAAW,GAAGhK,EAAE,CAACiK,WAAW,CAACC,KAAK,CAAC;EACzF;;EAEA;EACAC,eAAeA,CAAC9F,MAAe,EAAE+F,SAAoB,EAAEC,gBAA+B,EAAW;IAC/FhG,MAAM,GAAGf,OAAO,CAACgH,eAAe,CAACjG,MAAM,CAAC;IAExC,IAAI+F,SAAS,CAAClI,IAAI,CAAC,IAAI,EAAEmC,MAAM,CAAC,EAAE;MAChC,OAAO,IAAI;IACb;IAEA,IAAI,CAACA,MAAM,CAACwB,MAAM,EAAE0E,YAAY,EAAE;MAChC,OAAO,KAAK;IACd;;IAEA;IACA,CAACF,gBAAgB,GAAGA,gBAAgB,IAAI,IAAIG,GAAG,CAAU,CAAC,EAAEC,GAAG,CAACpG,MAAM,CAAC;IAEvE,KAAK,MAAMqG,UAAU,IAAIrG,MAAM,CAACwB,MAAM,CAAC0E,YAAY,EAAE;MACnD,MAAMI,sBAAsB,GAAG3K,EAAE,CAAC4K,kBAAkB,CAACF,UAAU,CAAC,IAAI1K,EAAE,CAAC6K,sBAAsB,CAACH,UAAU,CAAC;MACzG,MAAMI,SAAS,GAAGH,sBAAsB,IAAI,CAAC,CAACD,UAAU,CAACK,eAAe;MACxE,IAAI,CAACD,SAAS,EAAE;QACd;MACF;MACA,KAAK,MAAME,cAAc,IAAIN,UAAU,CAACK,eAAe,EAAE;QACvD,IAAI,IAAI,CAACE,uBAAuB,CAACD,cAAc,CAACxG,KAAK,EAAE4F,SAAS,EAAEC,gBAAgB,CAAC,EAAE;UACnF,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAOpB,eAAeA,CAAC5E,MAAe,EAA8B;IAClE,OACE,CAACA,MAAM,CAACO,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC0E,SAAS,CAAC7C,MAAM,MAAM,CAAC,IAC/C,CAAEwC,MAAM,CAAmB2F,WAAW,GAAGhK,EAAE,CAACiK,WAAW,CAACiB,SAAS,MAAM,CAAC;EAE5E;EAEA,OAAOC,iBAAiBA,CAACtF,MAA6B,EAAW;IAC/D,OAAO,CAAC,CAACA,MAAM,IAAI,CAAC,CAACA,MAAM,CAACpB,KAAK,IAAI,CAACoB,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACkF,SAAS,MAAM,CAAC;EACtF;EAEA,OAAOC,gBAAgBA,CAACxF,MAA6B,EAAW;IAC9D,OAAO,CAAC,CAACA,MAAM,IAAI,CAAC,CAACA,MAAM,CAACpB,KAAK,IAAI,CAACoB,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACoF,QAAQ,MAAM,CAAC;EACrF;EAEA,OAAOC,eAAeA,CAAClH,MAA2B,EAAW;IAC3D,OACE,CAAC,CAACA,MAAM,IAAI,CAAC,CAACA,MAAM,CAACwB,MAAM,IAAI,CAAC,CAACxB,MAAM,CAACwB,MAAM,CAACpB,KAAK,IAAI,CAACJ,MAAM,CAACwB,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAAC6C,SAAS,MAAM,CAAC;EAElH;EAEA,OAAOyC,SAASA,CAACnH,MAAe,EAA8B;IAC5D,OAAO,CAACA,MAAM,CAACO,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC0E,SAAS,CAAC+G,GAAG,MAAM,CAAC;EACrD;EAEA,OAAOC,aAAaA,CAACrH,MAAe,EAAW;IAC7C,OAAO,CAACA,MAAM,CAACO,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC0E,SAAS,CAACiH,OAAO,MAAM,CAAC;EACzD;EAEA,OAAOC,iBAAiBA,CAACvH,MAAe,EAAW;IACjD,OACE,CAAC,CAACA,MAAM,CAACI,KAAK,KACb,CAACJ,MAAM,CAACI,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAAC+G,GAAG,MAAM,CAAC,IACtC,CAACpH,MAAM,CAACI,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACiH,OAAO,MAAM,CAAC,IAC3C,CAACtH,MAAM,CAACI,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACmH,YAAY,MAAM,CAAC,CAAC;EAEvD;EAEA,OAAOC,mBAAmBA,CAACtD,IAAa,EAAW;IACjD,IAAIA,IAAI,CAAClE,OAAO,CAAC,CAAC,EAAE;MAClB,KAAK,MAAMjD,CAAC,IAAImH,IAAI,CAAChE,KAAK,EAAE;QAC1B,IAAI,CAAC,EAAEnD,CAAC,CAACoD,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACqH,SAAS,CAAC,IAAI,CAAC,EAAE1K,CAAC,CAACoD,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACsH,IAAI,CAAC,EAAE;UAC3E,OAAO,IAAI;QACb;MACF;IACF;IACA,OAAO,KAAK;EACd;EAEA,OAAOC,kBAAkBA,CAAChG,QAA+B,EAAW;IAClE,OACE,CAAC,CAACA,QAAQ,IAAI,CAACA,QAAQ,CAACxB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACgG,MAAM,MAAM,CAAC,IAAI,CAACjG,QAAQ,CAACxB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACiG,UAAU,MAAM,CAAC;EAEtH;EAEA,OAAOC,cAAcA,CAACnG,QAA+B,EAA8B;IACjF,IAAIA,QAAQ,EAAEsE,YAAY,IAAItE,QAAQ,CAACsE,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE;MAC9D,OAAOlD,QAAQ,CAACsE,YAAY,CAAC,CAAC,CAAC;IACjC;IACA,OAAOlD,SAAS;EAClB;EAEA,OAAegF,gBAAgBA,CAACC,MAAe,EAAW;IACxD,OAAOtM,EAAE,CAACuM,qBAAqB,CAACD,MAAM,CAAC,IAAItM,EAAE,CAACwM,yBAAyB,CAACF,MAAM,CAACpH,MAAM,CAAC;EACxF;EAEAuH,qBAAqBA,CAACzH,MAAqB,EAAW;IACpD,IAAI,IAAI,CAAC0H,qBAAqB,CAAC1H,MAAM,CAACE,MAAuB,CAAC,EAAE;MAC9D,OAAO,IAAI;IACb;IACA,IAAI,IAAI,CAACyH,qBAAqB,CAAC3H,MAAM,CAACE,MAAuB,CAAC,EAAE;MAC9D,OAAO,IAAI;IACb;IACA,OAAO,IAAI,CAAC0H,uBAAuB,CAAC5H,MAAM,CAAC;EAC7C;EAEQ6H,2CAA2CA,CAAC7H,MAAqB,EAAW;IAClF,IAAI,CAAChF,EAAE,CAAC8M,0BAA0B,CAAC9H,MAAM,CAAC,EAAE;MAC1C,OAAO,KAAK;IACd;;IAEA;AACJ;AACA;AACA;IACI,MAAM+H,cAAc,GAAG/H,MAAM;IAC7B,IAAI,IAAI,CAAC0H,qBAAqB,CAACK,cAAc,CAAC,EAAE;MAC9C,OAAO,IAAI;IACb;IACA,MAAMC,cAAc,GAAG,IAAI,CAAChG,oBAAoB,CAAC+F,cAAc,CAACpG,UAAU,CAAC;IAC3E,IAAI,CAACqG,cAAc,EAAE;MACnB,OAAO,KAAK;IACd;IACA,MAAMC,KAAK,GAAGD,cAAc,CAAC/E,eAAe,CAAC,CAAC;IAC9C,IAAI,CAACgF,KAAK,IAAIA,KAAK,CAAC9D,MAAM,KAAK,CAAC,EAAE;MAChC,OAAO,KAAK;IACd;IACA,OAAOnJ,EAAE,CAACkN,iBAAiB,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;EACvC;EAEAL,uBAAuBA,CAAC5H,MAAqB,EAAW;IACtD,IACEhF,EAAE,CAAC0G,yBAAyB,CAAC1B,MAAM,CAAC,IACpChF,EAAE,CAACmN,cAAc,CAACnI,MAAM,CAAC,IAAIA,MAAM,CAACwD,IAAI,CAACjC,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC2F,aAAa,EAC7E;MACA,OAAO,IAAI,CAACR,uBAAuB,CAAC5H,MAAM,CAAC2B,UAAU,CAAC;IACxD;IAEA,QAAQ3B,MAAM,CAACuB,IAAI;MACjB,KAAKvG,EAAE,CAACyH,UAAU,CAAC4F,qBAAqB;QACtC,OAAO,IAAI,CAACC,oCAAoC,CAACtI,MAAkC,CAAC;MACtF,KAAKhF,EAAE,CAACyH,UAAU,CAAC8F,uBAAuB;MAC1C,KAAKvN,EAAE,CAACyH,UAAU,CAAC+F,gBAAgB;QACjC,OAAO,IAAI,CAACC,+BAA+B,CAACzI,MAA6B,CAAC;MAC5E,KAAKhF,EAAE,CAACyH,UAAU,CAACiG,qBAAqB;QACtC,OAAO,IAAI,CAACC,oCAAoC,CAAC3I,MAAkC,CAAC;MACtF,KAAKhF,EAAE,CAACyH,UAAU,CAACa,UAAU;QAC3B,OAAO,IAAI,CAACsF,+BAA+B,CAAC5I,MAAuB,CAAC;MACtE,KAAKhF,EAAE,CAACyH,UAAU,CAACoG,cAAc;QAC/B,OAAO,IAAI;MACb,KAAK7N,EAAE,CAACyH,UAAU,CAACqG,aAAa;QAC9B,OAAO,IAAI;MACb,KAAK9N,EAAE,CAACyH,UAAU,CAACsG,wBAAwB;QACzC,OAAO,IAAI,CAAClB,2CAA2C,CAAC7H,MAAM,CAAC;MACjE;QACE,OAAO,KAAK;IAChB;EACF;EAEQsI,oCAAoCA,CAACtI,MAAgC,EAAW;IACtF,OAAO1B,OAAO,CAAC0K,iCAAiC,CAAChJ,MAAM,CAACiJ,QAAQ,CAAC,IAAI,IAAI,CAACrB,uBAAuB,CAAC5H,MAAM,CAACkJ,OAAO,CAAC;EACnH;EAEQT,+BAA+BA,CAACzI,MAA2B,EAAW;IAC5E,OACE1B,OAAO,CAAC6K,kCAAkC,CAACnJ,MAAM,CAACM,aAAa,CAAC,IAChE,IAAI,CAACsH,uBAAuB,CAAC5H,MAAM,CAACd,IAAI,CAAC,IACzC,IAAI,CAAC0I,uBAAuB,CAAC5H,MAAM,CAACb,KAAK,CAAC;EAE9C;EAEQwJ,oCAAoCA,CAAC3I,MAAgC,EAAW;IACtF,OAAO,IAAI,CAAC4H,uBAAuB,CAAC5H,MAAM,CAACoJ,QAAQ,CAAC,IAAI,IAAI,CAACxB,uBAAuB,CAAC5H,MAAM,CAACqJ,SAAS,CAAC;EACxG;EAEQT,+BAA+BA,CAAC5I,MAAqB,EAAW;IACtE,MAAMiB,QAAQ,GAAG,IAAI,CAACe,oBAAoB,CAAChC,MAAM,CAAC;IAClD,MAAMsH,MAAM,GAAGhJ,OAAO,CAAC8I,cAAc,CAACnG,QAAQ,CAAC;IAC/C,OACE,CAAC,CAACqG,MAAM,KACPhJ,OAAO,CAAC+I,gBAAgB,CAACC,MAAM,CAAC,IAAIhJ,OAAO,CAACgL,OAAO,CAAChC,MAAM,CAACpH,MAAM,CAAC,IAAIoH,MAAM,CAAC/F,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC8G,UAAU,CAAC;EAEpH;EAEA,OAAeP,iCAAiCA,CAACQ,eAAuC,EAAW;IACjG,OACEA,eAAe,KAAKxO,EAAE,CAACyH,UAAU,CAACgH,SAAS,IAC3CD,eAAe,KAAKxO,EAAE,CAACyH,UAAU,CAACiH,UAAU,IAC5CF,eAAe,KAAKxO,EAAE,CAACyH,UAAU,CAACkH,UAAU;EAEhD;EAEA,OAAeR,kCAAkCA,CAACS,UAAkC,EAAW;IAC7F,OACEA,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACoH,aAAa,IAC/CD,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACqH,UAAU,IAC5CF,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACsH,YAAY,IAC9CH,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACiH,UAAU,IAC5CE,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACgH,SAAS,IAC3CG,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACuH,qBAAqB,IACvDJ,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACwH,2BAA2B,IAC7DL,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACyH,WAAW,IAC7CN,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC0H,sCAAsC,IACxEP,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC2H,cAAc,IAChDR,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC4H,UAAU,IAC5CT,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC6H,QAAQ,IAC1CV,UAAU,CAACrI,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC8H,uBAAuB;EAE7D;EAEA,OAAOjB,OAAOA,CAACkB,MAAe,EAAW;IACvC,OAAO,CAAC,EAAExP,EAAE,CAACyP,oBAAoB,CAACD,MAAM,CAAC,GAAGxP,EAAE,CAAC0P,SAAS,CAACC,KAAK,CAAC;EACjE;EAEAjD,qBAAqBA,CACnB1H,MAAoG,EAC3F;IACT,MAAM4K,YAAY,GAChB5K,MAAM,CAACuB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACoG,cAAc,GAC1C5K,MAAM,CAAC+B,MAAM,CAAC6K,OAAO,CAAC,CAAC,CAAC,GACxB,IAAI,CAACrM,aAAa,CAACsM,gBAAgB,CAAC9K,MAAM,CAAC;IAE/C,OAAO4K,YAAY,KAAKvI,SAAS,IAAI,OAAOuI,YAAY,KAAK,QAAQ;EACvE;EAEAG,sBAAsBA,CACpB/K,MAAoG,EAC3F;IACT,MAAM4K,YAAY,GAChB5K,MAAM,CAACuB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACoG,cAAc,GAC1C5K,MAAM,CAAC+B,MAAM,CAAC6K,OAAO,CAAC,CAAC,CAAC,GACxB,IAAI,CAACrM,aAAa,CAACsM,gBAAgB,CAAC9K,MAAM,CAAC;IAC/C,OACE4K,YAAY,KAAKvI,SAAS,IAC1B,OAAOuI,YAAY,KAAK,QAAQ,IAChCA,YAAY,CAACI,OAAO,CAAC,CAAC,CAAC,KAAKJ,YAAY,CAAC3L,QAAQ,CAAC,CAAC;EAEvD;EAEA0I,qBAAqBA,CAAC3H,MAAgF,EAAW;IAC/G,MAAM4K,YAAY,GAAG,IAAI,CAACpM,aAAa,CAACsM,gBAAgB,CAAC9K,MAAM,CAAC;IAChE,OAAO4K,YAAY,KAAKvI,SAAS,IAAI,OAAOuI,YAAY,KAAK,QAAQ;EACvE;;EAEA;EACAK,+BAA+BA,CAACC,KAAc,EAAEC,KAAc,EAAW;IACvED,KAAK,GAAG5M,OAAO,CAACgH,eAAe,CAAC4F,KAAK,CAAC;IACtCC,KAAK,GAAG7M,OAAO,CAACgH,eAAe,CAAC6F,KAAK,CAAC;IAEtC,IAAID,KAAK,KAAKC,KAAK,IAAI,IAAI,CAACC,QAAQ,CAACD,KAAK,CAAC,EAAE;MAC3C,OAAO,IAAI;IACb;IACA,IAAI,CAACD,KAAK,CAACrK,MAAM,EAAE0E,YAAY,EAAE;MAC/B,OAAO,KAAK;IACd;IACA,MAAM8F,YAAY,GAAG/M,OAAO,CAACgN,oBAAoB,CAACH,KAAK,CAAC;IACxD,KAAK,MAAMI,SAAS,IAAIL,KAAK,CAACrK,MAAM,CAAC0E,YAAY,EAAE;MACjD,IAAI8F,YAAY,IAAIrQ,EAAE,CAAC4K,kBAAkB,CAAC2F,SAAS,CAAC,IAAIjN,OAAO,CAACkN,oBAAoB,CAACD,SAAS,CAAC,EAAE;QAC/F,OAAO,IAAI;MACb;MACA,IAAI,CAACvQ,EAAE,CAAC4K,kBAAkB,CAAC2F,SAAS,CAAC,IAAI,CAACvQ,EAAE,CAAC6K,sBAAsB,CAAC0F,SAAS,CAAC,IAAI,CAACA,SAAS,CAACxF,eAAe,EAAE;QAC5G;MACF;MACA,KAAK,MAAMC,cAAc,IAAIuF,SAAS,CAACxF,eAAe,EAAE;QACtD,MAAM0F,iBAAiB,GAAGP,KAAK,CAACQ,OAAO,CAAC,CAAC,GAAG1F,cAAc,CAAC2F,KAAK,KAAK3Q,EAAE,CAACyH,UAAU,CAACmJ,cAAc,GAAG,IAAI;QACxG,IAAI,IAAI,CAACC,kBAAkB,CAAC7F,cAAc,CAACxG,KAAK,EAAE2L,KAAK,EAAEM,iBAAiB,CAAC,EAAE;UAC3E,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAOnG,eAAeA,CAACjJ,CAAU,EAAW;IAC1C,OAAOiC,OAAO,CAAC2F,eAAe,CAAC5H,CAAC,CAAC,IAAIA,CAAC,CAAC+H,MAAM,KAAK/H,CAAC,GAAGA,CAAC,CAAC+H,MAAM,GAAG/H,CAAC;EACpE;EAEQyP,0CAA0CA,CAChDC,OAAgB,EAChBC,OAAgB,EAChBC,OAAsB,EACb;IACT,IAAID,OAAO,CAAC1M,OAAO,CAAC,CAAC,EAAE;MACrB;MACA,KAAK,MAAM4M,QAAQ,IAAIF,OAAO,CAACxM,KAAK,EAAE;QACpC,IAAI,IAAI,CAAC2M,8BAA8B,CAACJ,OAAO,EAAEG,QAAQ,EAAED,OAAO,CAAC,EAAE;UACnE,OAAO,IAAI;QACb;MACF;MACA,OAAO,KAAK;IACd;IACA,IAAIF,OAAO,CAACzM,OAAO,CAAC,CAAC,EAAE;MACrB;MACA,KAAK,MAAM4M,QAAQ,IAAIH,OAAO,CAACvM,KAAK,EAAE;QACpC,IAAI,CAAC,IAAI,CAAC2M,8BAA8B,CAACD,QAAQ,EAAEF,OAAO,EAAEC,OAAO,CAAC,EAAE;UACpE,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;IACA;IACA,OAAO,KAAK;EACd;;EAEA;EACAE,8BAA8BA,CAACJ,OAAgB,EAAEC,OAAgB,EAAEC,OAAsB,EAAW;IAClGF,OAAO,GAAG,IAAI,CAACK,kBAAkB,CAACL,OAAO,CAAC;IAC1CC,OAAO,GAAG,IAAI,CAACI,kBAAkB,CAACJ,OAAO,CAAC;IAC1C,IAAI,IAAI,CAACK,aAAa,CAACN,OAAO,CAAC,EAAE;MAC/B,OAAO,KAAK;IACd;IACA,IAAI,IAAI,CAACO,gCAAgC,CAACP,OAAO,EAAEE,OAAO,CAAC,EAAE;MAC3D,OAAO,KAAK;IACd;IACA;IACA,IAAI,IAAI,CAACM,wBAAwB,CAACR,OAAO,EAAEC,OAAO,CAAC,EAAE;MACnD,OAAO,KAAK;IACd;IACA,IAAIA,OAAO,CAAC1M,OAAO,CAAC,CAAC,IAAIyM,OAAO,CAACzM,OAAO,CAAC,CAAC,EAAE;MAC1C,OAAO,IAAI,CAACwM,0CAA0C,CAACC,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC;IACnF;IACA,IACE,IAAI,CAACvN,mBAAmB,IACxBJ,OAAO,CAACkO,gBAAgB,CAACR,OAAO,CAAC,IACjCD,OAAO,KAAKC,OAAO,IACnB,CAAC1N,OAAO,CAACmO,YAAY,CAACV,OAAO,CAAC,EAC9B;MACA;MACA,OAAO,IAAI;IACb;IACA,OACEA,OAAO,CAACW,kBAAkB,CAAC,CAAC,IAC5BV,OAAO,CAACU,kBAAkB,CAAC,CAAC,IAC5B,CAAC,IAAI,CAACzB,+BAA+B,CAACe,OAAO,EAAED,OAAO,CAAC;EAE3D;EAEQF,kBAAkBA,CACxBc,WAAwC,EACxCxB,KAAc,EACdM,iBAA0B,EACjB;IACT,KAAK,MAAMmB,YAAY,IAAID,WAAW,EAAE;MACtC,MAAME,QAAQ,GAAGvO,OAAO,CAACgH,eAAe,CAAC,IAAI,CAAC9G,aAAa,CAACsO,iBAAiB,CAACF,YAAY,CAAC,CAAC;MAC5F,IACEC,QAAQ,IACRA,QAAQ,CAACnB,OAAO,CAAC,CAAC,KAAKD,iBAAiB,IACxC,IAAI,CAACR,+BAA+B,CAAC4B,QAAQ,EAAE1B,KAAK,CAAC,EACrD;QACA,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EAEQlF,uBAAuBA,CAC7B0G,WAAwC,EACxCvH,SAAoB,EACpBC,gBAA8B,EACrB;IACT,KAAK,MAAMuH,YAAY,IAAID,WAAW,EAAE;MACtC,MAAME,QAAQ,GAAGvO,OAAO,CAACgH,eAAe,CAAC,IAAI,CAAC9G,aAAa,CAACsO,iBAAiB,CAACF,YAAY,CAAC,CAAC;MAC5F,IAAIC,QAAQ,IAAI,CAACxH,gBAAgB,CAAC7I,GAAG,CAACqQ,QAAQ,CAAC,IAAI,IAAI,CAAC1H,eAAe,CAAC0H,QAAQ,EAAEzH,SAAS,EAAEC,gBAAgB,CAAC,EAAE;QAC9G,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EAEA+F,QAAQA,CAAC/L,MAAe,EAAW;IACjC,IAAI,CAACA,MAAM,EAAE;MACX,OAAO,KAAK;IACd;IACA,IAAIA,MAAM,CAACwB,MAAM,IAAIxB,MAAM,CAACqN,kBAAkB,CAAC,CAAC,IAAIrN,MAAM,CAACwB,MAAM,CAAC/B,IAAI,KAAK,QAAQ,EAAE;MACnF,OAAO,IAAI;IACb;IACA,MAAMmD,IAAI,GAAG,IAAI,CAACzD,aAAa,CAACuO,cAAc,CAAC1N,MAAM,EAAEgD,SAAS,EAAEA,SAAS,CAAC;IAC5E,OAAOJ,IAAI,KAAKI,SAAS,IAAIJ,IAAI,CAACV,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACuK,aAAa;EACxE;EAEAC,qCAAqCA,CAACjN,MAAqB,EAAW;IACpE,IAAIhF,EAAE,CAACkS,gBAAgB,CAAClN,MAAM,CAAC,EAAE;MAC/B,MAAMmN,eAAe,GAAG,IAAI,CAAC3O,aAAa,CAAC4O,oBAAoB,CAACpN,MAAM,CAAC;MACvE,IAAImN,eAAe,EAAE;QACnB,MAAME,UAAU,GAAGF,eAAe,CAAC/F,cAAc,CAAC,CAAC;QACnD;QACA,IAAI,CAACiG,UAAU,EAAE7J,IAAI,EAAE;UACrB,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAe8J,iBAAiBA,CAAC9J,IAAa,EAAW;IAAA,IAAA+J,KAAA;IACvD;IACA,IAAI/J,IAAI,CAAC3C,MAAM,CAAC2M,OAAO,KAAKnL,SAAS,EAAE;MACrC,OAAO,KAAK;IACd;IAEA,IAAIoL,MAAe,GAAG,KAAK;IAE3BjK,IAAI,CAAC3C,MAAM,CAAC2M,OAAO,CAACE,OAAO,CAAC,UAACjQ,KAAK,EAAK;MAAAJ,cAAA,OAAAkQ,KAAA;MACrC,IACE9P,KAAK,CAAC8H,YAAY,KAAKlD,SAAS,IAChC5E,KAAK,CAAC8H,YAAY,CAACpB,MAAM,GAAG,CAAC,IAC7BnJ,EAAE,CAAC2S,qBAAqB,CAAClQ,KAAK,CAAC8H,YAAY,CAAC,CAAC,CAAC,CAAC,EAC/C;QACA,MAAMqI,SAAS,GAAG5S,EAAE,CAAC6S,YAAY,CAACpQ,KAAK,CAAC8H,YAAY,CAAC,CAAC,CAAC,CAAC;QACxD,IAAIjH,OAAO,CAAC6C,WAAW,CAACyM,SAAS,EAAE5S,EAAE,CAACyH,UAAU,CAACqL,eAAe,CAAC,EAAE;UACjEL,MAAM,GAAG,IAAI;QACf;MACF;IACF,CAAC,CAAAM,IAAA,OAAC;IAEF,OAAON,MAAM;EACf;EAEA,OAAeO,cAAcA,CAACxK,IAAa,EAAW;IAAA,IAAAyK,MAAA;IACpD;IACA,IAAIzK,IAAI,CAAC3C,MAAM,CAAC2M,OAAO,KAAKnL,SAAS,EAAE;MACrC,OAAO,IAAI;IACb;;IAEA;IACA,IAAI6L,OAAgB,GAAG,KAAK;IAC5B;IACA,IAAIF,cAAuB,GAAG,KAAK;IAEnCxK,IAAI,CAAC3C,MAAM,CAAC2M,OAAO,CAACE,OAAO,CAAC,UAACjQ,KAAK,EAAK;MAAAJ,cAAA,OAAA4Q,MAAA;MACrC,IAAI,CAACxQ,KAAK,CAACgC,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACiN,WAAW,MAAM,CAAC,EAAE;QACpDD,OAAO,GAAG,IAAI;QAEd,IAAIzQ,KAAK,CAAC8H,YAAY,KAAKlD,SAAS,IAAI5E,KAAK,CAAC8H,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE;UACrE,MAAMiK,QAAQ,GAAG3Q,KAAK,CAAC8H,YAAY,CAAC,CAAC,CAA8B;UACnE,IAAI6I,QAAQ,CAACC,UAAU,CAAClK,MAAM,KAAK,CAAC,EAAE;YACpC6J,cAAc,GAAG,IAAI;UACvB;QACF;MACF;IACF,CAAC,CAAAD,IAAA,OAAC;;IAEF;IACA,OAAO,CAACG,OAAO,IAAIF,cAAc;EACnC;EAEA,OAAeM,eAAeA,CAAC9K,IAAa,EAAW;IACrD,IAAIA,IAAI,CAACkI,OAAO,CAAC,CAAC,IAAIlI,IAAI,CAAC3C,MAAM,CAAC0E,YAAY,IAAI/B,IAAI,CAAC3C,MAAM,CAAC0E,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE;MACrF,MAAMoK,SAAS,GAAG/K,IAAI,CAAC3C,MAAM,CAAC0E,YAAY,CAAC,CAAC,CAAwB;MACpE,MAAMiJ,SAAS,GAAGxT,EAAE,CAAC6S,YAAY,CAACU,SAAS,CAAC;MAC5C,IAAIjQ,OAAO,CAAC6C,WAAW,CAACqN,SAAS,EAAExT,EAAE,CAACyH,UAAU,CAACgM,eAAe,CAAC,EAAE;QACjE,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAOC,yBAAyBA,CAAClL,IAAyB,EAAW;IACnE,IAAI,CAACA,IAAI,EAAE;MACT,OAAO,KAAK;IACd;IACAA,IAAI,GAAGlF,OAAO,CAACgH,eAAe,CAAC9B,IAAI,CAAC;IACpC,OACEA,IAAI,CAACkJ,kBAAkB,CAAC,CAAC,IACzBpO,OAAO,CAAC0P,cAAc,CAACxK,IAAI,CAAC,IAC5B,CAAClF,OAAO,CAACgP,iBAAiB,CAAC9J,IAAI,CAAC,IAChC,CAAClF,OAAO,CAACgQ,eAAe,CAAC9K,IAAI,CAAC;EAElC;EAEAmL,UAAUA,CAACnL,IAAa,EAAW;IACjC,MAAMoL,UAAU,GAAG,IAAI,CAACpQ,aAAa,CAACqQ,mBAAmB,CAACrL,IAAI,CAAC;IAC/D,IAAIoL,UAAU,EAAEzK,MAAM,EAAE;MACtB,KAAK,MAAM2K,IAAI,IAAIF,UAAU,EAAE;QAC7B,IAAIE,IAAI,CAAClP,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAACkG,WAAW,CAACgG,MAAM,EAAE;UAC3C,OAAO,IAAI;QACb;MACF;IACF;IACA,OAAO,KAAK;EACd;EAEA6H,YAAYA,CAACvL,IAAa,EAAE1E,IAAY,EAAyB;IAC/D,MAAM8P,UAAU,GAAG,IAAI,CAACpQ,aAAa,CAACqQ,mBAAmB,CAACrL,IAAI,CAAC;IAC/D,IAAIoL,UAAU,EAAEzK,MAAM,EAAE;MACtB,KAAK,MAAM2K,IAAI,IAAIF,UAAU,EAAE;QAC7B,IAAIE,IAAI,CAAChQ,IAAI,KAAKA,IAAI,EAAE;UACtB,OAAOgQ,IAAI;QACb;MACF;IACF;IAEA,OAAOzM,SAAS;EAClB;EAEA2M,YAAYA,CAACC,OAAgB,EAAEC,SAAoB,EAAW;IAC5D,IAAI,CAACD,OAAO,CAACE,qBAAqB,CAAC,CAAC,EAAE;MACpC,OAAOD,SAAS,CAAChS,IAAI,CAAC,IAAI,EAAE+R,OAAO,CAAC;IACtC;IACA,KAAK,MAAMG,QAAQ,IAAIH,OAAO,CAACzP,KAAK,EAAE;MACpC,IAAI,IAAI,CAACwP,YAAY,CAACI,QAAQ,EAAEF,SAAS,CAAC,EAAE;QAC1C,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EAEA9C,kBAAkBA,CAAC/P,CAAU,EAAW;IACtC,MAAMyK,mBAAmB,GAAG,IAAI,CAACnI,UAAU,GAAGL,OAAO,CAACwI,mBAAmB,CAACzK,CAAC,CAAC,GAAGA,CAAC,CAACiD,OAAO,CAAC,CAAC;IAC1F,IAAIwH,mBAAmB,EAAE;MACvB,OAAOzK,CAAC,CAAC+P,kBAAkB,CAAC,CAAC;IAC/B;IACA,OAAO/P,CAAC;EACV;EAEQgT,gCAAgCA,CAACtD,OAAqB,EAAEE,OAAmC,EAAW;IAC5G,KAAK,MAAMC,QAAQ,IAAIH,OAAO,CAACvM,KAAK,EAAE;MACpC,IAAI,IAAI,CAAC8P,yBAAyB,CAACpD,QAAQ,EAAED,OAAO,CAAC,EAAE;QACrD,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EAEAqD,yBAAyBA,CAACvD,OAA4B,EAAEE,OAAmC,EAAW;IACpG,IAAIF,OAAO,KAAK1J,SAAS,EAAE;MACzB,OAAO,KAAK;IACd;IACA;IACA0J,OAAO,GAAG,IAAI,CAACK,kBAAkB,CAACL,OAAO,CAAC;IAC1C,IAAIA,OAAO,CAACzM,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC+P,gCAAgC,CAACtD,OAAO,EAAEE,OAAO,CAAC,EAAE;MAChF,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;IACI,IAAI3N,OAAO,CAACkI,SAAS,CAACuF,OAAO,CAAC,IAAI,IAAI,CAACM,aAAa,CAACN,OAAO,CAAC,EAAE;MAC7D,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;AACA;IACI,IAAI,IAAI,CAACO,gCAAgC,CAACP,OAAO,EAAEE,OAAO,CAAC,EAAE;MAC3D,OAAO,IAAI;IACb;IACA;IACA,IAAI,IAAI,CAACsD,gBAAgB,CAACxD,OAAO,CAAC,IAAI,IAAI,CAACyD,iBAAiB,CAACzD,OAAO,CAAC,IAAI,IAAI,CAAC0D,iBAAiB,CAAC1D,OAAO,CAAC,EAAE;MACxG,IAAIA,OAAO,CAAC2D,kBAAkB,IAAI3D,OAAO,CAAC2D,kBAAkB,CAACvL,MAAM,KAAK,CAAC,EAAE;QACzE4H,OAAO,GAAGA,OAAO,CAAC2D,kBAAkB,CAAC,CAAC,CAAC;MACzC,CAAC,MAAM;QACL,OAAO,KAAK;MACd;IACF;;IAEA;AACJ;AACA;AACA;AACA;IACI,IAAI,IAAI,CAACC,eAAe,CAAC5D,OAAO,CAAC,EAAE;MACjC,OAAO,IAAI,CAAC6D,wBAAwB,CAAC3D,OAAO,CAAC;IAC/C;IACA,OACE3N,OAAO,CAACoQ,yBAAyB,CAAC3C,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC4C,UAAU,CAAC5C,OAAO,CAAC,IAAI,IAAI,CAAC8D,cAAc,CAAC9D,OAAO,EAAEE,OAAO,CAAC;EAEpH;EAEQK,gCAAgCA,CAACP,OAAgB,EAAEE,OAAsB,EAAW;IAC1F,IAAI,IAAA6D,8BAAgB,EAAC/D,OAAO,CAAC,IAAIzN,OAAO,CAACiF,eAAe,CAACwI,OAAO,CAAC,EAAE;MACjE,MAAMgE,MAAM,GAAG/U,EAAE,CAACkS,gBAAgB,CAACjB,OAAO,CAAC,GACzC,IAAI,CAAC+D,yBAAyB,CAAC/D,OAAO,CAAC,GACvC,IAAI,CAACtN,UAAU,GACb,IAAI,CAACqD,oBAAoB,CAACiK,OAAO,CAAC,GAClC,IAAI,CAACzN,aAAa,CAAC8D,mBAAmB,CAAC2J,OAAO,CAAC;MACnD,IAAI8D,MAAM,IAAI,IAAI,CAACE,eAAe,CAACF,MAAM,CAAC,EAAE;QAC1C,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EAEAF,cAAcA,CAACK,UAAmB,EAAEC,aAAyC,EAAW;IACtF,KAAK,MAAMrB,IAAI,IAAIqB,aAAa,CAACvB,UAAU,EAAE;MAC3C,IAAI5T,EAAE,CAACoV,oBAAoB,CAACtB,IAAI,CAAC,EAAE;QACjC,IAAI,CAAC,IAAI,CAACuB,aAAa,CAACH,UAAU,EAAEpB,IAAI,CAAC,EAAE;UACzC,OAAO,KAAK;QACd;MACF;IACF;IAEA,OAAO,IAAI;EACb;EAEAwB,iBAAiBA,CAAC9M,IAAa,EAAEsL,IAA2B,EAAyB;IACnF,MAAMyB,cAAc,GAAG,IAAI,CAAC/R,aAAa,CAAC8D,mBAAmB,CAACwM,IAAI,CAAChQ,IAAI,CAAC;IACxE,MAAM0R,QAAQ,GAAGD,cAAc,GAC7BvV,EAAE,CAACyV,UAAU,CAACF,cAAc,CAAC,GAC7BvV,EAAE,CAAC0V,YAAY,CAAC5B,IAAI,CAAChQ,IAAI,CAAC,GACxB9D,EAAE,CAAC2V,MAAM,CAAC7B,IAAI,CAAChQ,IAAI,CAAC,GACpBgQ,IAAI,CAAChQ,IAAI,CAAC+L,OAAO,CAAC,CAAC;IACvB,MAAM+F,OAAO,GAAG,IAAI,CAAC7B,YAAY,CAACvL,IAAI,EAAEgN,QAAQ,CAAC;IACjD,OAAOI,OAAO;EAChB;EAEQP,aAAaA,CAAC7M,IAAa,EAAEsL,IAA2B,EAAW;IACzE;IACA,MAAM8B,OAAO,GAAG,IAAI,CAACN,iBAAiB,CAAC9M,IAAI,EAAEsL,IAAI,CAAC;IAClD,IAAI,CAAC8B,OAAO,EAAErL,YAAY,EAAEpB,MAAM,EAAE;MAClC,OAAO,KAAK;IACd;IAEA,MAAM0M,QAAQ,GAAG,IAAI,CAACrS,aAAa,CAACsS,yBAAyB,CAACF,OAAO,EAAEA,OAAO,CAACrL,YAAY,CAAC,CAAC,CAAC,CAAC;IAC/F,MAAMwL,QAAQ,GAAGzS,OAAO,CAACkD,mBAAmB,CAACsN,IAAI,CAACpO,WAAW,CAAC;IAC9D,IAAI1F,EAAE,CAACgW,yBAAyB,CAACD,QAAQ,CAAC,EAAE;MAC1C,IAAI,CAAC,IAAI,CAACzB,yBAAyB,CAACuB,QAAQ,EAAEE,QAAQ,CAAC,EAAE;QACvD,OAAO,KAAK;MACd;IACF,CAAC,MAAM,IACL,IAAI,CAAC5E,8BAA8B,CAAC0E,QAAQ,EAAE,IAAI,CAACrS,aAAa,CAACsO,iBAAiB,CAACiE,QAAQ,CAAC,EAAEA,QAAQ,CAAC,EACvG;MACA;MACA,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;EAEAnB,wBAAwBA,CAACO,aAAyC,EAAW;IAC3E,KAAK,MAAMrB,IAAI,IAAIqB,aAAa,CAACvB,UAAU,EAAE;MAC3C,IAAI,CAACE,IAAI,CAAChQ,IAAI,EAAE;QACd,OAAO,KAAK;MACd;MACA,MAAMmS,uBAAuB,GAC3BjW,EAAE,CAACkW,sBAAsB,CAACpC,IAAI,CAAChQ,IAAI,CAAC,IAAI,IAAI,CAACqS,2BAA2B,CAACrC,IAAI,CAAChQ,IAAI,EAAE,IAAI,CAAC;MAC3F,IAAI,CAAC9D,EAAE,CAACoW,eAAe,CAACtC,IAAI,CAAChQ,IAAI,CAAC,IAAI,CAAC9D,EAAE,CAACqW,gBAAgB,CAACvC,IAAI,CAAChQ,IAAI,CAAC,IAAI,CAACmS,uBAAuB,EAAE;QACjG,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;EAEA,OAAeK,uBAAuBA,CAAC/P,IAAmB,EAAW;IACnE,OACEA,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC8O,UAAU,IACjChQ,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC+O,cAAc,IACrCjQ,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACgP,aAAa,IACpClQ,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACiP,iBAAiB,IACxCnQ,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACkP,eAAe,IACtCpQ,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACmP,UAAU,IACjCrQ,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACoP,SAAS;EAEpC;EAEQC,kCAAkCA,CAACC,QAA0B,EAAW;IAC9E,KAAK,MAAMC,aAAa,IAAID,QAAQ,CAACvS,KAAK,EAAE;MAC1C,IAAI,CAAC,IAAI,CAACyS,eAAe,CAACD,aAAa,CAAC,EAAE;QACxC,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;EAEQE,kCAAkCA,CAACH,QAA0B,EAAW;IAC9E,KAAK,MAAMI,IAAI,IAAIJ,QAAQ,CAACK,QAAQ,EAAE;MACpC,IAAIpX,EAAE,CAACqX,UAAU,CAACF,IAAI,CAAC,IAAI,CAAC,IAAI,CAACF,eAAe,CAACE,IAAI,CAAC,EAAE;QACtD,OAAO,KAAK;MACd;MACA,IAAInX,EAAE,CAACsX,kBAAkB,CAACH,IAAI,CAAC,IAAI,CAAC,IAAI,CAACF,eAAe,CAACE,IAAI,CAAC3O,IAAI,CAAC,EAAE;QACnE,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;EAEAyO,eAAeA,CAACF,QAAqB,EAAW;IAC9C,IAAI/W,EAAE,CAACuX,uBAAuB,CAACR,QAAQ,CAAC,EAAE;MACxC,OAAO,IAAI,CAACE,eAAe,CAACF,QAAQ,CAACvO,IAAI,CAAC;IAC5C;IAEA,IAAIxI,EAAE,CAACwX,eAAe,CAACT,QAAQ,CAAC,EAAE;MAChC,OAAO,IAAI,CAACE,eAAe,CAACF,QAAQ,CAACU,WAAW,CAAC;IACnD;IAEA,IAAIzX,EAAE,CAAC0X,mBAAmB,CAACX,QAAQ,CAAC,IAAIA,QAAQ,CAAC7N,aAAa,EAAE;MAC9D,KAAK,MAAMyO,OAAO,IAAIZ,QAAQ,CAAC7N,aAAa,EAAE;QAC5C,IAAI,CAAC,IAAI,CAAC+N,eAAe,CAACU,OAAO,CAAC,EAAE;UAClC,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;IAEA,IAAI3X,EAAE,CAAC4X,eAAe,CAACb,QAAQ,CAAC,EAAE;MAChC,OAAO,IAAI,CAACD,kCAAkC,CAACC,QAAQ,CAAC;IAC1D;IAEA,IAAI/W,EAAE,CAAC6X,eAAe,CAACd,QAAQ,CAAC,EAAE;MAChC,OAAO,IAAI,CAACG,kCAAkC,CAACH,QAAQ,CAAC;IAC1D;IAEA,OACE,CAAC/W,EAAE,CAAC8X,iBAAiB,CAACf,QAAQ,CAAC,KAC9B,IAAI,CAACrT,mBAAmB,IAAI,CAAC1D,EAAE,CAAC+X,eAAe,CAAChB,QAAQ,CAAC,CAAC,IAC3D,CAAC/W,EAAE,CAACgY,sBAAsB,CAACjB,QAAQ,CAAC,IACpCzT,OAAO,CAACgT,uBAAuB,CAACS,QAAQ,CAACxQ,IAAI,CAAC;EAElD;EAEA0R,yBAAyBA,CAAC9C,aAAyC,EAAW;IAC5E,IAAInV,EAAE,CAACkY,oBAAoB,CAAC/C,aAAa,CAACjQ,MAAM,CAAC,EAAE;MACjD,MAAMiT,SAAS,GAAG,IAAI,CAAC3U,aAAa,CAAC4O,oBAAoB,CAAC+C,aAAa,CAACjQ,MAAM,CAAC;MAC/E,MAAMkT,QAAQ,GAAGD,SAAS,EAAEE,WAAW;MACvC,OAAO,CAAC,CAACD,QAAQ,IAAIpY,EAAE,CAACsY,wBAAwB,CAACF,QAAQ,CAAC,IAAI,IAAAG,6BAAmB,EAACH,QAAQ,CAAClT,MAAM,CAAC;IACpG;IACA,OAAO,KAAK;EACd;EAEAsT,mBAAmBA,CAAC3S,MAAiB,EAAsB;IACzD,MAAM/B,IAAI,GAAG,IAAI,CAACN,aAAa,CAACkG,qBAAqB,CAAC7D,MAAM,CAAC;IAC7D,MAAM4S,WAAW,GAAG3U,IAAI,CAAC4U,WAAW,CAAC,GAAG,CAAC;IACzC,OAAOD,WAAW,KAAK,CAAC,CAAC,GAAGpR,SAAS,GAAGvD,IAAI,CAAC6U,SAAS,CAAC,CAAC,EAAEF,WAAW,CAAC;EACxE;EAEA9O,cAAcA,CAAC9D,MAAiB,EAAW;IACzC,MAAM+S,UAAU,GAAG,IAAI,CAACJ,mBAAmB,CAAC3S,MAAM,CAAC;IACnD,OAAO,CAAC+S,UAAU,IAAIA,UAAU,KAAK,QAAQ;EAC/C;EAEAC,WAAWA,CAAChT,MAAiB,EAAW;IACtC,MAAM+S,UAAU,GAAG,IAAI,CAACJ,mBAAmB,CAAC3S,MAAM,CAAC;IACnD,IAAI,CAAC,IAAI,CAAClC,UAAU,EAAE;MACpB,MAAMG,IAAI,GAAG8U,UAAU,GAAGA,UAAU,GAAG/S,MAAM,CAACiT,WAAW;MACzD,OAAOhV,IAAI,KAAKZ,MAAM,IAAIY,IAAI,KAAKV,kBAAkB;IACvD;IACA,OAAO,CAAC,CAACwV,UAAU,KAAKA,UAAU,KAAK1V,MAAM,IAAI0V,UAAU,KAAKxV,kBAAkB,CAAC;EACrF;EAEA2V,gBAAgBA,CAAClT,MAAiB,EAAW;IAC3C,IAAI,CAAC,IAAI,CAAClC,UAAU,EAAE;MACpB,MAAMG,IAAI,GAAG+B,MAAM,CAAC/B,IAAI;MACxB,MAAMkV,OAAO,GAAG,IAAI,CAACR,mBAAmB,CAAC3S,MAAM,CAAC;MAChD,OAAO,CAACmT,OAAO,KAAK9V,MAAM,IAAI8V,OAAO,KAAK5V,kBAAkB,KAAKU,IAAI,KAAKT,QAAQ;IACpF;IACA,OAAO,IAAI,CAACwV,WAAW,CAAChT,MAAM,CAAC,IAAIA,MAAM,CAAC/B,IAAI,KAAKT,QAAQ;EAC7D;EAEA,OAAO4V,eAAeA,CAACC,UAA8B,EAAW;IAC9D,OAAOA,UAAU,EAAEC,YAAY,EAAEC,IAAI,KAAK,SAAS;EACrD;EAEA,OAAOC,WAAWA,CAACC,aAAwC,EAAU;IACnE,OAAOA,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC8R,uBAAuB,IACjED,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC+R,sBAAsB,GAC1DF,aAAa,CAAqBG,GAAG,GACrCH,aAAa,CAAaI,QAAQ,CAAC,CAAC;EACzC;EAEA,OAAOC,SAASA,CAACL,aAAwC,EAAU;IACjE,OAAOA,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC8R,uBAAuB,IACjED,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC+R,sBAAsB,GAC1DF,aAAa,CAAqBM,GAAG,GACrCN,aAAa,CAAaO,MAAM,CAAC,CAAC;EACvC;EAEA,OAAOC,iBAAiBA,CAACR,aAAwC,EAAES,OAAe,EAAoB;IACpG,OACE,IAAI,CAACC,sBAAsB,CAACvY,GAAG,CAACsY,OAAO,CAAC,EAAE7X,IAAI,CAAC,IAAI,EAAEoX,aAAa,CAAC,IAAI,CACrE,IAAI,CAACD,WAAW,CAACC,aAAa,CAAC,EAC/B,IAAI,CAACK,SAAS,CAACL,aAAa,CAAC,CAC9B;EAEL;EAwBA,OAAOW,wBAAwBA,CAACX,aAAwC,EAAEY,OAAe,EAAoB;IAC3G,MAAMC,KAAK,GAAG,IAAI,CAACd,WAAW,CAACC,aAAa,CAAC;IAC7C,OAAO,CAACa,KAAK,EAAEA,KAAK,GAAGD,OAAO,CAAC/Q,MAAM,CAAC;EACxC;EAEA,OAAOiR,+BAA+BA,CAACd,aAAwC,EAAgC;IAC7G,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,KAAK,CAAC;EAC5D;EAEA,OAAOe,yCAAyCA,CAC9Cf,aAAwC,EACV;IAC9B,MAAMgB,eAAe,GAAIhB,aAAa,CAAoBiB,mBAAmB;IAC7E,IAAID,eAAe,KAAKjT,SAAS,EAAE;MACjC,OAAO,CAACiT,eAAe,CAACZ,QAAQ,CAAC,CAAC,EAAEY,eAAe,CAACT,MAAM,CAAC,CAAC,CAAC;IAC/D;IAEA,OAAOxS,SAAS;EAClB;EAEA,OAAOmT,+BAA+BA,CAAClB,aAAwC,EAAgC;IAC7G,OAAO,CACL,IAAI,CAACK,SAAS,CAAEL,aAAa,CAAuB5T,WAAW,CAAC,GAAG,CAAC,EACpE,IAAI,CAAC2T,WAAW,CAAEC,aAAa,CAAuB3S,UAAU,CAAC,GAAG,CAAC,CACtE;EACH;EAEA,OAAO8T,8BAA8BA,CAACnB,aAAwC,EAAgC;IAC5G,OAAO,CAAC,IAAI,CAACD,WAAW,CAACC,aAAa,CAAC,EAAGA,aAAa,CAAsBoB,SAAS,CAAChB,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;EACxG;EAEA,OAAOiB,+BAA+BA,CAACrB,aAAwC,EAAgC;IAC7G,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,QAAQ,CAAC;EAC/D;EAEA,OAAOsB,0BAA0BA,CAACtB,aAAwC,EAAgC;IACxG,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,QAAQ,CAAC;EAC/D;EAEA,OAAOuB,sCAAsCA,CAC3CvB,aAAwC,EACV;IAC9B,OAAO,IAAI,CAACW,wBAAwB,CAAEX,aAAa,CAAyBhU,aAAa,EAAE,YAAY,CAAC;EAC1G;EAEA,OAAOwV,+BAA+BA,CAACxB,aAAwC,EAAgC;IAC7G,IAAIA,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACsT,YAAY,EAAE;MACrD,OAAO,CACJzB,aAAa,CAAqB3S,UAAU,CAACkT,MAAM,CAAC,CAAC,GAAG,CAAC,EACzDP,aAAa,CAAqB9Q,IAAI,CAACkR,QAAQ,CAAC,CAAC,GAAG,CAAC,CACvD;IACH;IACA,OAAO,CACJJ,aAAa,CAAsB3S,UAAU,CAACkT,MAAM,CAAC,CAAC,GAAG,CAAC,EAC1DP,aAAa,CAAsB9Q,IAAI,CAACqR,MAAM,CAAC,CAAC,GAAG,CAAC,CACtD;EACH;EAEA,OAAOmB,2CAA2CA,CAChD1B,aAAwC,EACV;IAC9B,IAAIrS,IAAyB;IAC7B,IAAIqS,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACwT,kBAAkB,EAAE;MAC3D;MACAhU,IAAI,GAAIqS,aAAa,CAA2B9Q,IAAI;IACtD,CAAC,MAAM,IAAI8Q,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACyT,mBAAmB,EAAE;MACnEjU,IAAI,GAAIqS,aAAa,CAA4BxV,IAAI;IACvD,CAAC,MAAM,IAAIwV,aAAa,CAAC/S,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC0T,iBAAiB,EAAE;MACjElU,IAAI,GAAIqS,aAAa,CAA0BxV,IAAI;IACrD;IAEA,IAAImD,IAAI,KAAKI,SAAS,EAAE;MACtB,OAAO,CAACJ,IAAI,CAACyS,QAAQ,CAAC,CAAC,EAAEzS,IAAI,CAAC4S,MAAM,CAAC,CAAC,CAAC;IACzC;IAEA,OAAOxS,SAAS;EAClB;EAEA,OAAO+T,8BAA8BA,CAAC9B,aAAwC,EAAgC;IAC5G,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,UAAU,CAAC;EACjE;EAEA,OAAO+B,kCAAkCA,CAAC/B,aAAwC,EAAgC;IAChH,MAAMgC,QAAQ,GAAIhC,aAAa,CAAazJ,OAAO,CAAC,CAAC,CAAC6I,WAAW,CAAC,GAAG,CAAC;IACtE,OAAO,CAAC,IAAI,CAACW,WAAW,CAACC,aAAa,CAAC,GAAGgC,QAAQ,GAAG,CAAC,EAAE,IAAI,CAAC3B,SAAS,CAACL,aAAa,CAAC,CAAC;EACxF;EAEA,OAAOiC,sCAAsCA,CAC3CjC,aAAwC,EACV;IAC9B;IACA,MAAMkC,QAA6B,GAAIlC,aAAa,CAAyBxV,IAAI;IACjF,IAAI0X,QAAQ,KAAKnU,SAAS,EAAE;MAC1B,OAAO,CAACmU,QAAQ,CAAC9B,QAAQ,CAAC,CAAC,EAAE8B,QAAQ,CAAC3B,MAAM,CAAC,CAAC,CAAC;IACjD;IAEA,OAAOxS,SAAS;EAClB;EAEA,OAAOoU,2CAA2CA,CAChDnC,aAAwC,EACV;IAC9B,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,GAAG,CAAC;EAC1D;EAEA,OAAOoC,gCAAgCA,CAACpC,aAAwC,EAAgC;IAC9G,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,OAAO,CAAC;EAC9D;EAEA,OAAOqC,qCAAqCA,CAACrC,aAAwC,EAAgC;IACnH,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,QAAQ,CAAC;EAC/D;EAEA,OAAOsC,oCAAoCA,CAACtC,aAAwC,EAAgC;IAClH,MAAMuC,MAAM,GAAIvC,aAAa,CAA+BjG,UAAU;IACtE,IAAIwI,MAAM,CAAC1S,MAAM,EAAE;MACjB,OAAO,CAAC0S,MAAM,CAAC,CAAC,CAAC,CAACnC,QAAQ,CAAC,CAAC,EAAEmC,MAAM,CAACA,MAAM,CAAC1S,MAAM,GAAG,CAAC,CAAC,CAAC0Q,MAAM,CAAC,CAAC,CAAC;IACnE;IACA,OAAOxS,SAAS;EAClB;EAEA,OAAOyU,kCAAkCA,CAACxC,aAAwC,EAAgC;IAChH,OAAO,IAAI,CAACW,wBAAwB,CAACX,aAAa,EAAE,GAAG,CAAC;EAC1D;;EAEA;;EAEA,OAAOyC,2CAA2CA,CAChDzC,aAAwC,EACV;IAC9B,MAAMxV,IAAI,GAAIwV,aAAa,CAA4BxV,IAAI;IAC3D,MAAMkY,gBAAgB,GAAI1C,aAAa,CAA4B0C,gBAAgB;IACnF,OAAO,CAAClY,IAAI,CAAC4V,QAAQ,CAAC,CAAC,EAAEsC,gBAAgB,GAAGA,gBAAgB,CAACnC,MAAM,CAAC,CAAC,GAAG/V,IAAI,CAAC+V,MAAM,CAAC,CAAC,CAAC;EACxF;EAEAlF,eAAeA,CAACnM,IAAa,EAAW;IAEtC;AACJ;AACA;AACA;AACA;IACI,IAAIA,IAAI,CAACyT,WAAW,EAAE;MACpB,MAAM7S,MAAM,GAAIZ,IAAI,CAAsBY,MAAM;MAChD,IAAIA,MAAM,EAAE;QACV,MAAMvC,GAAG,GAAGuC,MAAM,CAAC6S,WAAW;QAC9B,OAAO,CAAC,CAACpV,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,QAAQ,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;MACxE;IACF;IAEA,OAAO,KAAK;EACd;EAEAqV,cAAcA,CAAC1T,IAAa,EAAW;IACrC,MAAM3C,MAAM,GAAG2C,IAAI,CAAC3C,MAAM;IAC1B,IAAI,CAACA,MAAM,EAAE;MACX,OAAO,KAAK;IACd;IACA,MAAM/B,IAAI,GAAG,IAAI,CAACN,aAAa,CAACkG,qBAAqB,CAAC7D,MAAM,CAAC;IAC7D,OAAO/B,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC6F,cAAc,CAAC9D,MAAM,CAAC;EACxD;EAEA0O,gBAAgBA,CAAC/L,IAAa,EAAW;IACvC,MAAM3B,GAAG,GAAG2B,IAAI,CAACyT,WAAW;IAC5B,OAAO,CAAC,CAACpV,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,SAAS,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EACzE;EAEA2N,iBAAiBA,CAAChM,IAAa,EAAW;IACxC,MAAM3B,GAAG,GAAG2B,IAAI,CAACyT,WAAW;IAC5B,OAAO,CAAC,CAACpV,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,UAAU,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EAC1E;EAEA4N,iBAAiBA,CAACjM,IAAa,EAAW;IACxC,MAAM3B,GAAG,GAAG2B,IAAI,CAACyT,WAAW;IAC5B,OAAO,CAAC,CAACpV,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,UAAU,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EAC1E;EAEAwK,aAAaA,CAAC7I,IAAa,EAAW;IACpC,MAAM2T,eAAe,GAAG3T,IAAI,CAAC4I,kBAAkB,CAAC,CAAC;IACjD,IAAI+K,eAAe,CAAC7X,OAAO,CAAC,CAAC,EAAE;MAC7B,KAAK,MAAM8X,aAAa,IAAID,eAAe,CAAC3X,KAAK,EAAE;QACjD,IAAI,CAAC,IAAI,CAAC6M,aAAa,CAAC+K,aAAa,CAAC,EAAE;UACtC,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;IACA,OAAO,IAAI,CAACnH,eAAe,CAACkH,eAAe,CAACF,WAAW,IAAIE,eAAe,CAAC7S,SAAS,CAAC,CAAC,CAAC;EACzF;EAEA+S,cAAcA,CAACpV,IAAa,EAAW;IACrC,OAAO,IAAI,CAACoK,aAAa,CAAC,IAAI,CAAC7N,aAAa,CAACsO,iBAAiB,CAAC7K,IAAI,CAAC,CAAC;EACvE;EAEAgO,eAAeA,CAACpO,GAA0B,EAAW;IAAA,IAAAyV,MAAA;IACnD,IAAIzV,GAAG,EAAE0D,YAAY,IAAI1D,GAAG,CAAC0D,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE;MACpD,MAAMoT,OAAO,GAAG1V,GAAG,CAAC0D,YAAY,CAAC,CAAC,CAAC,CAACiS,aAAa,CAAC,CAAC;MACnD,IAAI,CAACD,OAAO,EAAE;QACZ,OAAO,KAAK;MACd;MACA,MAAME,QAAQ,GAAGF,OAAO,CAACE,QAAQ;;MAEjC;AACN;AACA;AACA;AACA;MACM,MAAMC,GAAG,GAAG7c,IAAI,CAAC8c,OAAO,CAACF,QAAQ,CAAC,CAACG,WAAW,CAAC,CAAC;MAChD,MAAMC,gBAAgB,GACpBC,mCAAiB,CAACC,IAAI,CAAC,UAACC,MAAM,EAAK;QAAA3a,cAAA,OAAAia,MAAA;QACjC,OAAO,IAAAW,iCAAqB,EAACpd,IAAI,CAACqd,SAAS,CAACT,QAAQ,CAAC,EAAEO,MAAM,CAAC;MAChE,CAAC,CAAAjK,IAAA,OAAC,IACFoK,oCAAkB,CAACJ,IAAI,CAAC,UAACC,MAAM,EAAK;QAAA3a,cAAA,OAAAia,MAAA;QAClC,OAAOzc,IAAI,CAACud,QAAQ,CAACX,QAAQ,CAAC,KAAKO,MAAM;MAC3C,CAAC,CAAAjK,IAAA,OAAC;MACJ,MAAMsK,KAAK,GAAGX,GAAG,KAAK,MAAM;MAC5B,MAAMY,IAAI,GAAGZ,GAAG,KAAK,KAAK,IAAI,CAACH,OAAO,CAACgB,iBAAiB;MACxD,MAAMC,QAAQ,GAAG,CAACH,KAAK,IAAIC,IAAI,IAAI,IAAI,CAAC7Z,QAAQ,KAAK,CAACoZ,gBAAgB;MACtE,MAAMY,QAAQ,GAAGC,qCAAkB,CAAC7T,QAAQ,CAAChK,IAAI,CAACud,QAAQ,CAACX,QAAQ,CAAC,CAACG,WAAW,CAAC,CAAC,CAAC;;MAEnF;AACN;AACA;AACA;AACA;MACM,OAAO,CAACY,QAAQ,IAAI,CAACC,QAAQ;IAC/B;IACA,OAAO,KAAK;EACd;EAEAE,aAAaA,CAACnV,IAAyB,EAAuB;IAC5D,IAAIA,IAAI,KAAKnB,SAAS,EAAE;MACtB,OAAO,KAAK;IACd;;IAEA;AACJ;AACA;AACA;AACA;;IAEI;AACJ;AACA;AACA;IACImB,IAAI,GAAGA,IAAI,CAAC4I,kBAAkB,CAAC,CAAC;IAEhC,IAAI5I,IAAI,CAAClE,OAAO,CAAC,CAAC,EAAE;MAClB,KAAK,MAAM4M,QAAQ,IAAI1I,IAAI,CAAChE,KAAK,EAAE;QACjC,MAAMoZ,SAAS,GAAG,IAAI,CAACD,aAAa,CAACzM,QAAQ,CAAC;QAC9C,IAAI0M,SAAS,IAAIA,SAAS,KAAKvW,SAAS,EAAE;UACxC,OAAOuW,SAAS;QAClB;MACF;MACA,OAAO,KAAK;IACd;IAEA,IAAI,IAAI,CAACvM,aAAa,CAAC7I,IAAI,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb;IAEA,IAAI,CAAC,IAAAsM,8BAAgB,EAACtM,IAAI,CAAC,IAAI,CAAC,IAAAqV,4CAAqB,EAACrV,IAAI,CAAC,IAAI,CAAClF,OAAO,CAACkI,SAAS,CAAChD,IAAI,CAAC,EAAE;MACvF,OAAO,KAAK;IACd;IAEA,OAAOnB,SAAS;EAClB;EAEA,OAAOoK,YAAYA,CAACjJ,IAAa,EAAyB;IACxD,OAAO,CAAC,EAAEA,IAAI,CAAC/D,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAAC7C,MAAM,CAAC;EAC7C;EAEA,OAAeic,WAAWA,CAACtV,IAAa,EAAW;IACjD,IAAIlF,OAAO,CAACmO,YAAY,CAACjJ,IAAI,CAAC,EAAE;MAC9B,OAAO,CAAC,EAAEA,IAAI,CAACwB,WAAW,GAAGhK,EAAE,CAACiK,WAAW,CAAC8T,SAAS,CAAC;IACxD;IACA,OAAO,KAAK;EACd;EAEQC,+CAA+CA,CAACC,QAA2B,EAAW;IAC5F,MAAMzV,IAAI,GAAG,IAAI,CAAChF,aAAa,CAACsO,iBAAiB,CAACmM,QAAQ,CAACtX,UAAU,CAAC;IAEtE,IAAIrD,OAAO,CAACkI,SAAS,CAAChD,IAAI,CAAC,EAAE;MAC3B,OAAO,IAAI;IACb;IAEA,IAAI3B,GAA0B,GAAG2B,IAAI,CAAC3C,MAAM;IAC5C,IAAI,IAAI,CAACoP,eAAe,CAACpO,GAAG,CAAC,EAAE;MAC7B,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;IACI,IAAI7G,EAAE,CAAC8M,0BAA0B,CAACmR,QAAQ,CAACtX,UAAU,CAAC,EAAE;MACtDE,GAAG,GAAG,IAAI,CAACG,oBAAoB,CAACiX,QAAQ,CAACtX,UAAU,CAACA,UAAU,CAAC;MAC/D,IAAIE,GAAG,IAAI,IAAI,CAACoO,eAAe,CAACpO,GAAG,CAAC,EAAE;QACpC,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd;EAEAqX,2BAA2BA,CAACC,IAAmB,EAAW;IACxD,IAAI,CAACne,EAAE,CAACgW,yBAAyB,CAACmI,IAAI,CAAC,IAAI,CAACne,EAAE,CAACoe,wBAAwB,CAACD,IAAI,CAAC,EAAE;MAC7E,OAAO,KAAK;IACd;;IAEA;AACJ;AACA;AACA;IACI,IAAIE,OAAgB,GAAGF,IAAI;IAC3B,OAAOne,EAAE,CAACgW,yBAAyB,CAACqI,OAAO,CAAC,IAAIre,EAAE,CAACoe,wBAAwB,CAACC,OAAO,CAAC,EAAE;MACpF,MAAMC,QAAQ,GAAG,IAAI,CAAC9a,aAAa,CAAC+a,iBAAiB,CAACF,OAAO,CAAC;MAC9D,IAAIC,QAAQ,KAAKjX,SAAS,IAAI,CAAC/D,OAAO,CAACwa,WAAW,CAACQ,QAAQ,CAAC,EAAE;QAC5D,MAAME,GAAG,GAAG,IAAI,CAACb,aAAa,CAACW,QAAQ,CAAC;QACxC,IAAIE,GAAG,KAAKnX,SAAS,EAAE;UACrB,OAAOmX,GAAG;QACZ;MACF;MAEAH,OAAO,GAAGA,OAAO,CAACnZ,MAAM;MACxB,IAAIlF,EAAE,CAACoV,oBAAoB,CAACiJ,OAAO,CAAC,EAAE;QACpCA,OAAO,GAAGA,OAAO,CAACnZ,MAAM;MAC1B;IACF;;IAEA;AACJ;AACA;AACA;IACI,IAAIlF,EAAE,CAACkS,gBAAgB,CAACmM,OAAO,CAAC,IAAI,IAAI,CAACL,+CAA+C,CAACK,OAAO,CAAC,EAAE;MACjG,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;IACI,IAAIre,EAAE,CAACoF,kBAAkB,CAACiZ,OAAO,CAAC,EAAE;MAClC,MAAMI,OAAO,GAAGJ,OAAO;MACvB,IAAIre,EAAE,CAAC8M,0BAA0B,CAAC2R,OAAO,CAACva,IAAI,CAAC,EAAE;QAC/C,MAAMwa,cAAc,GAAGD,OAAO,CAACva,IAAI;QACnC,MAAMsE,IAAI,GAAG,IAAI,CAAChF,aAAa,CAACsO,iBAAiB,CAAC4M,cAAc,CAAC/X,UAAU,CAAC;QAC5E,OAAO,IAAI,CAACsO,eAAe,CAACzM,IAAI,CAAC3C,MAAM,CAAC;MAC1C;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAO8Y,cAAcA,CAAC5H,QAAiC,EAAW;IAChE,OACE,CAAC,CAACA,QAAQ,IACV/W,EAAE,CAAC0X,mBAAmB,CAACX,QAAQ,CAAC,IAChC/W,EAAE,CAAC+D,YAAY,CAACgT,QAAQ,CAAC6H,QAAQ,CAAC,IAClC7H,QAAQ,CAAC6H,QAAQ,CAACxF,IAAI,KAAKyF,mBAAS;EAExC;EAEA,OAAOC,aAAaA,CAAC7X,IAAa,EAAW;IAC3C,IAAI8X,GAAG,GAAG9X,IAAI,CAAC/B,MAAM;IACrB,OAAO6Z,GAAG,EAAE;MACV,IAAI/e,EAAE,CAACgf,OAAO,CAACD,GAAG,CAAC,EAAE;QACnB,OAAO,IAAI;MACb;MACAA,GAAG,GAAGA,GAAG,CAAC7Z,MAAM;IAClB;IACA,OAAO,KAAK;EACd;EAEA,OAAO+Z,yBAAyBA,CAACC,OAA6B,EAAW;IACvE,OAAOlf,EAAE,CAACuM,qBAAqB,CAAC2S,OAAO,CAACha,MAAM,CAAC;EACjD;EAEAia,2BAA2BA,CAAClY,IAAa,EAAW;IAClD,IAAIjH,EAAE,CAACoe,wBAAwB,CAACnX,IAAI,CAAC,IAAIjH,EAAE,CAACgW,yBAAyB,CAAC/O,IAAI,CAAC,EAAE;MAC3E,OAAO,KAAK;IACd;IACA,MAAMmY,SAAS,GAAG,IAAI,CAAC5b,aAAa,CAACsO,iBAAiB,CAAC7K,IAAI,CAAC;IAC5D,OAAO3D,OAAO,CAACsI,iBAAiB,CAACwT,SAAS,CAAC,IAAI9b,OAAO,CAAC+b,eAAe,CAACD,SAAS,CAAC;EACnF;EAEAE,8BAA8BA,CAACrY,IAAa,EAA2B;IACrE,MAAMJ,GAAG,GAAG,IAAI,CAACG,oBAAoB,CAACC,IAAI,CAAC;IAC3C,IAAIJ,GAAG,KAAKQ,SAAS,EAAE;MACrB,OAAOA,SAAS;IAClB;IACA,OAAO/D,OAAO,CAACic,4BAA4B,CAAC1Y,GAAG,CAAC;EAClD;EAEA,OAAO0Y,4BAA4BA,CAAC1Y,GAAc,EAA2B;IAC3E,MAAM2Y,IAAI,GAAGlc,OAAO,CAAC8I,cAAc,CAACvF,GAAG,CAAC;IACxC,IAAI,CAAC,CAAC2Y,IAAI,IAAIxf,EAAE,CAACuM,qBAAqB,CAACiT,IAAI,CAAC,EAAE;MAC5C,OAAOA,IAAI,CAAChX,IAAI;IAClB;IACA,OAAOnB,SAAS;EAClB;EAEAoY,eAAeA,CAACxY,IAAa,EAAW;IACtC,MAAM8P,QAAQ,GAAG,IAAI,CAACuI,8BAA8B,CAACrY,IAAI,CAAC;IAC1D,OAAO8P,QAAQ,KAAK1P,SAAS,IAAI/D,OAAO,CAACqb,cAAc,CAAC5H,QAAQ,CAAC;EACnE;EAEA,OAAO2I,qBAAqBA,CAAC7Y,GAAc,EAAW;IACpD,MAAMkQ,QAAQ,GAAGzT,OAAO,CAACic,4BAA4B,CAAC1Y,GAAG,CAAC;IAC1D,OAAOkQ,QAAQ,KAAK1P,SAAS,IAAI/D,OAAO,CAACqb,cAAc,CAAC5H,QAAQ,CAAC;EACnE;EAEA,OAAO4I,gBAAgBA,CAAC9Y,GAAc,EAAW;IAC/C,MAAM2Y,IAAI,GAAGlc,OAAO,CAAC8I,cAAc,CAACvF,GAAG,CAAC;IACxC,OACE,CAAC,CAAC2Y,IAAI,IACNxf,EAAE,CAAC4f,sBAAsB,CAACJ,IAAI,CAAC,IAC/BA,IAAI,CAAC1b,IAAI,CAACE,WAAW,KAAK6a,mBAAS,IACnCW,IAAI,CAAChX,IAAI,CAACjC,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAAC8O,UAAU;EAE/C;EAEA,OAAO8I,eAAeA,CAAC7W,IAAa,EAAW;IAC7C,IAAIA,IAAI,CAAC2L,qBAAqB,CAAC,CAAC,EAAE;MAChC,KAAK,MAAMjD,QAAQ,IAAI1I,IAAI,CAAChE,KAAK,EAAE;QACjC,IAAIlB,OAAO,CAAC+b,eAAe,CAACnO,QAAQ,CAAC,EAAE;UACrC,OAAO,IAAI;QACb;MACF;MACA,OAAO,KAAK;IACd;IAEA,OACE,CAAC1I,IAAI,CAAC/D,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAAC7C,MAAM,MAAM,CAAC,IAAI,CAAE2G,IAAI,CAAmBwB,WAAW,GAAGhK,EAAE,CAACiK,WAAW,CAAC8T,SAAS,MAAM,CAAC;EAEtH;EAEA/I,yBAAyBA,CAACiJ,QAA2B,EAAyB;IAC5E,MAAM9F,SAAS,GAAG,IAAI,CAAC3U,aAAa,CAAC4O,oBAAoB,CAAC6L,QAAQ,CAAC;IACnE,MAAM7F,QAAQ,GAAGD,SAAS,EAAE/L,cAAc,CAAC,CAAC;IAC5C,IAAIgM,QAAQ,EAAEtU,IAAI,EAAE;MAClB,OAAO,IAAI,CAACkD,oBAAoB,CAACoR,QAAQ,CAACtU,IAAI,CAAC;IACjD;IACA,OAAOuD,SAAS;EAClB;EAEA,OAAOmK,gBAAgBA,CAAChJ,IAAa,EAAW;IAC9C,IACE,CAACA,IAAI,CAAC/D,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAAC7C,MAAM,MAAM,CAAC,IACxC,CAAE2G,IAAI,CAAmBwB,WAAW,GAAGhK,EAAE,CAACiK,WAAW,CAAC8T,SAAS,MAAM,CAAC,EACtE;MACA,OAAO,KAAK;IACd;IACA,OAAOvV,IAAI,CAAC3C,MAAM,IAAI,CAAC2C,IAAI,CAAC3C,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAAC4C,KAAK,MAAM,CAAC;EACxE;EAEA+W,uBAAuBA,CAAC1B,IAAmB,EAAW;IACpD,IAAI,CAAC7a,OAAO,CAACkO,gBAAgB,CAAC,IAAI,CAAChO,aAAa,CAACsO,iBAAiB,CAACqM,IAAI,CAAC,CAAC,EAAE;MACzE,OAAO,KAAK;IACd;IACA,MAAMtY,MAAM,GAAG,IAAI,CAACmB,oBAAoB,CAACmX,IAAI,CAAC;IAC9C,OAAO,CAACtY,MAAM,IAAI,CAACA,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAAC4C,KAAK,MAAM,CAAC;EAC/D;EAEAgX,qBAAqBA,CAAC3B,IAAmB,EAAW;IAClD,MAAMtX,GAAG,GAAG,IAAI,CAACG,oBAAoB,CAACmX,IAAI,CAAC;IAC3C,OAAOtX,GAAG,KAAKQ,SAAS,IAAI,CAACR,GAAG,CAACpC,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAAC4C,KAAK,MAAM,CAAC;EACtE;EAEAiX,2BAA2BA,CAACC,QAA+B,EAAW;IAAA,IAAAC,MAAA;IACpE,IAAI,CAACD,QAAQ,CAAClc,IAAI,EAAE;MAClB,OAAO,KAAK;IACd;IAEA,MAAM+C,GAAG,GAAG,IAAI,CAACrD,aAAa,CAAC8D,mBAAmB,CAAC0Y,QAAQ,CAAClc,IAAI,CAAC;IACjE,IAAI,CAAC+C,GAAG,EAAE;MACR,OAAO,KAAK;IACd;IAEA,IAAIqZ,KAAK,GAAG,KAAK;IACjB,MAAMC,QAAQ,GAAG,SAAAA,SAAClZ,IAAa,EAAW;MAAA5E,cAAA,OAAA4d,MAAA;MACxC,IAAIjgB,EAAE,CAACkS,gBAAgB,CAACjL,IAAI,CAAC,IAAIjH,EAAE,CAAC+D,YAAY,CAACkD,IAAI,CAACN,UAAU,CAAC,EAAE;QACjE,MAAMyZ,OAAO,GAAG,IAAI,CAAC5c,aAAa,CAAC8D,mBAAmB,CAACL,IAAI,CAACN,UAAU,CAAC;QACvE,IAAIyZ,OAAO,IAAIA,OAAO,KAAKvZ,GAAG,EAAE;UAC9BqZ,KAAK,GAAG,IAAI;QACd;MACF;IACF,CAAC,CAAAnN,IAAA;IAED,MAAMsN,aAAa,GAAG,SAAAA,cAACpZ,IAAa,EAAc;MAAA5E,cAAA,OAAA4d,MAAA;MAChD,KAAKhZ,IAAI;MACT,OAAOiZ,KAAK;IACd,CAAC,CAAAnN,IAAA;IAED,IAAAuN,0CAAoB,EAACN,QAAQ,EAAEG,QAAQ,EAAEE,aAAa,CAAC;IACvD,OAAOH,KAAK;EACd;EAEAK,iCAAiCA,CAACpC,IAAmB,EAAW;IAC9D,MAAM3V,IAAI,GAAG,IAAI,CAAChF,aAAa,CAACsO,iBAAiB,CAACqM,IAAI,CAAC;IACvD,IAAI3V,IAAI,CAACgY,eAAe,CAAC,CAAC,EAAE;MAC1B,MAAMC,UAAU,GAAGjY,IAAI,CAACkY,aAAa,CAAC,CAAC;MACvC,IAAID,UAAU,EAAE;QACd,OAAOA,UAAU;MACnB;IACF;IACA,OAAOjY,IAAI;EACb;EAEQ+I,wBAAwBA,CAACR,OAAgB,EAAEC,OAAgB,EAAW;IAC5E,OACE,CAAC,IAAI,CAAC2P,iBAAiB,CAAC5P,OAAO,CAAC,IAAIzN,OAAO,CAACsd,gBAAgB,CAAC7P,OAAO,CAAC,MACpE,IAAI,CAAC4P,iBAAiB,CAAC3P,OAAO,CAAC,IAAI1N,OAAO,CAACsd,gBAAgB,CAAC5P,OAAO,CAAC,CAAC;EAE1E;EAEA,OAAe4P,gBAAgBA,CAACpY,IAAa,EAAW;IACtD,MAAMqY,SAAS,GAAGrY,IAAI,CAACsY,iBAAiB,CAAC,CAAC;IAC1C,OAAOD,SAAS,IAAIA,SAAS,CAAC1X,MAAM,GAAG,CAAC;EAC1C;EAEQwX,iBAAiBA,CAACnY,IAAa,EAAW;IAChD,MAAM3B,GAAG,GAAG2B,IAAI,CAACc,SAAS,CAAC,CAAC;IAC5B,OAAO,CAAC,CAACzC,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,UAAU,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EAC1E;EAEAka,eAAeA,CAACvY,IAAa,EAAW;IACtC,MAAM3B,GAAG,GAAG2B,IAAI,CAAC3C,MAAM;IACvB,OAAO,CAAC,CAACgB,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,QAAQ,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EACxE;EAEAma,eAAeA,CAACxY,IAAa,EAAW;IACtC,MAAM3B,GAAG,GAAG2B,IAAI,CAAC3C,MAAM;IACvB,OAAO,CAAC,CAACgB,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,QAAQ,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EACxE;EAEAoa,gBAAgBA,CAACzY,IAAa,EAAW;IACvC,MAAM3B,GAAG,GAAG2B,IAAI,CAAC3C,MAAM;IACvB,OAAO,CAAC,CAACgB,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,SAAS,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EACzE;EAEAqa,mBAAmBA,CAAC/C,IAAmB,EAAW;IAChD,MAAMtY,MAAM,GAAG,IAAI,CAACmB,oBAAoB,CAACmX,IAAI,CAAC;IAC9C,MAAMgD,YAAY,GAAG,CAAC,CAACtb,MAAM,IAAI,CAAC,EAAEA,MAAM,CAACpB,KAAK,GAAGzE,EAAE,CAACkG,WAAW,CAACqI,UAAU,CAAC;IAC7E,MAAM/F,IAAI,GAAG,IAAI,CAAChF,aAAa,CAACsO,iBAAiB,CAACqM,IAAI,CAAC;IACvD,MAAMiD,mBAAmB,GAAG9d,OAAO,CAACqC,UAAU,CAAC6C,IAAI,CAAC,IAAI,CAAC,EAAEA,IAAI,CAAC/D,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACoJ,aAAa,CAAC;IACnG,OAAOqT,YAAY,IAAIC,mBAAmB;EAC5C;EAEAjL,2BAA2BA,CAACkL,gBAAyC,EAAEC,yBAAyB,GAAG,KAAK,EAAW;IACjH,MAAMnD,IAAI,GAAGkD,gBAAgB,CAAC1a,UAAU;IACxC,IAAI,CAAC2a,yBAAyB,EAAE;MAC9B,MAAMzb,MAAM,GAAG,IAAI,CAACmB,oBAAoB,CAACmX,IAAI,CAAC;MAC9C,IAAI,CAAC,CAACtY,MAAM,IAAI,IAAI,CAACkT,gBAAgB,CAAClT,MAAM,CAAC,EAAE;QAC7C,OAAO,IAAI;MACb;IACF;IACA;IACA,OAAO7F,EAAE,CAACuhB,mBAAmB,CAACpD,IAAI,CAAC,IAAI,IAAI,CAAC+C,mBAAmB,CAACG,gBAAgB,CAAC1a,UAAU,CAAC;EAC9F;EAEA6a,6BAA6BA,CAC3BhC,IAA4B,EAC5BiC,UAAqC,EACrCC,WAA0C,EACjC;IAAA,IAAAC,MAAA;IACT,IAAI,CAACF,UAAU,EAAE;MACf,OAAO,KAAK;IACd;IAEA,MAAMpE,KAAK,GAAG,IAAI,CAAC1Z,UAAU,GAC3B,CAAC,CAAC+d,WAAW,IAAIA,WAAW,CAACD,UAAU,CAAC,GACxC,IAAAG,4BAAa,EAACH,UAAU,CAAC,KAAKzhB,EAAE,CAAC6hB,UAAU,CAACC,GAAG;IACjD,OACEzE,KAAK,IACLoE,UAAU,CAAClE,iBAAiB,IAC5B,CAAC,CAACiC,IAAI,CAACuC,SAAS,EAAEhF,IAAI,CAAC,UAACiF,CAAC,EAAK;MAAA3f,cAAA,OAAAsf,MAAA;MAC5B,OAAOK,CAAC,CAACzb,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACwa,cAAc;IAChD,CAAC,CAAAlP,IAAA,OAAC;EAEN;EAEAmP,iBAAiBA,CAAC1C,IAAqB,EAAW;IAChD,MAAMuC,SAAS,GAAG/hB,EAAE,CAAC6S,YAAY,CAAC2M,IAAI,CAAC;IACvC,OACE,CAAC,CAACuC,SAAS,KACV,CAAC,IAAI,CAACpe,UAAU,IAAIL,OAAO,CAAC6C,WAAW,CAAC4b,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAACqL,eAAe,CAAC,IAChFxP,OAAO,CAAC6C,WAAW,CAAC4b,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAAC0a,aAAa,CAAC,IAC3D7e,OAAO,CAAC6C,WAAW,CAAC4b,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAAC2a,gBAAgB,CAAC,IAC9D9e,OAAO,CAAC6C,WAAW,CAAC4b,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAACwa,cAAc,CAAC,CAAC;EAEnE;EAEA,OAAOI,WAAWA,CAChBN,SAA6C,EAC7CO,YAA2B,EACF;IAAA,IAAAC,MAAA;IACzB,IAAI,CAACR,SAAS,EAAE;MACd,OAAO1a,SAAS;IAClB;IACA,OAAO0a,SAAS,CAACS,IAAI,CAAC,UAACC,CAAC,EAAK;MAAApgB,cAAA,OAAAkgB,MAAA;MAC3B,OAAOE,CAAC,CAAClc,IAAI,KAAK+b,YAAY;IAChC,CAAC,CAAAvP,IAAA,OAAC;EACJ;EAEA,OAAO2P,iBAAiBA,CAACX,SAA6C,EAA2B;IAC/F,OACEze,OAAO,CAAC+e,WAAW,CAACN,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAAC0a,aAAa,CAAC,IAC3D7e,OAAO,CAAC+e,WAAW,CAACN,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAAC2a,gBAAgB,CAAC,IAC9D9e,OAAO,CAAC+e,WAAW,CAACN,SAAS,EAAE/hB,EAAE,CAACyH,UAAU,CAACwa,cAAc,CAAC;EAEhE;EAEA,OAAOU,gBAAgBA,CAACna,IAAa,EAAgC;IACnE,MAAMoa,SAAS,GAAGpa,IAAI,CAACqa,YAAY,CAAC,CAAC;IACrC,IAAID,SAAS,EAAE;MACb,KAAK,MAAM/Q,QAAQ,IAAI+Q,SAAS,EAAE;QAChC,IAAI/Q,QAAQ,CAACnB,OAAO,CAAC,CAAC,EAAE;UACtB,OAAOmB,QAAQ;QACjB;MACF;IACF;IAEA,OAAOxK,SAAS;EAClB;EAEA,OAAOyb,wCAAwCA,CAAC7b,IAA0B,EAAW;IAAA,IAAA8b,MAAA;IACnF,IAAI/iB,EAAE,CAACoe,wBAAwB,CAACnX,IAAI,CAAC,EAAE;MACrC,OAAOA,IAAI,CAACmQ,QAAQ,CAAC2F,IAAI,CAAC,UAAC0F,CAAC,EAAK;QAAApgB,cAAA,OAAA0gB,MAAA;QAC/B,IAAI/iB,EAAE,CAACgjB,eAAe,CAACP,CAAC,CAAC,EAAE;UACzB,OAAO,IAAI;QACb;QACA,IAAIziB,EAAE,CAACgW,yBAAyB,CAACyM,CAAC,CAAC,IAAIziB,EAAE,CAACoe,wBAAwB,CAACqE,CAAC,CAAC,EAAE;UACrE,OAAOnf,OAAO,CAACwf,wCAAwC,CAACL,CAAC,CAAC;QAC5D;QACA,OAAO,KAAK;MACd,CAAC,CAAA1P,IAAA,OAAC;IACJ;IAEA,OAAO9L,IAAI,CAAC2M,UAAU,CAACmJ,IAAI,CAAC,UAAC0F,CAAC,EAAK;MAAApgB,cAAA,OAAA0gB,MAAA;MACjC,IAAI/iB,EAAE,CAACijB,kBAAkB,CAACR,CAAC,CAAC,EAAE;QAC5B,OAAO,IAAI;MACb;MACA,IACEziB,EAAE,CAACoV,oBAAoB,CAACqN,CAAC,CAAC,KACzBziB,EAAE,CAACgW,yBAAyB,CAACyM,CAAC,CAAC/c,WAAW,CAAC,IAAI1F,EAAE,CAACoe,wBAAwB,CAACqE,CAAC,CAAC/c,WAAW,CAAC,CAAC,EAC3F;QACA,OAAOpC,OAAO,CAACwf,wCAAwC,CAACL,CAAC,CAAC/c,WAAW,CAAC;MACxE;MACA,OAAO,KAAK;IACd,CAAC,CAAAqN,IAAA,OAAC;EACJ;EAEA,OAAOmQ,yCAAyCA,CAACjc,IAAuB,EAAW;IAAA,IAAAkc,MAAA;IACjF,OAAOlc,IAAI,CAACmQ,QAAQ,CAAC2F,IAAI,CAAC,UAAC0F,CAAC,EAAK;MAAApgB,cAAA,OAAA8gB,MAAA;MAC/B,IAAInjB,EAAE,CAACojB,gBAAgB,CAACX,CAAC,CAAC,EAAE;QAC1B,IAAIA,CAAC,CAACY,cAAc,EAAE;UACpB,OAAO,IAAI;QACb;QACA,IAAIrjB,EAAE,CAACsjB,qBAAqB,CAACb,CAAC,CAAC3e,IAAI,CAAC,IAAI9D,EAAE,CAACujB,sBAAsB,CAACd,CAAC,CAAC3e,IAAI,CAAC,EAAE;UACzE,OAAOR,OAAO,CAAC4f,yCAAyC,CAACT,CAAC,CAAC3e,IAAI,CAAC;QAClE;MACF;MACA,OAAO,KAAK;IACd,CAAC,CAAAiP,IAAA,OAAC;EACJ;EAEA,OAAOyQ,4BAA4BA,CAACvc,IAAwC,EAAW;IAAA,IAAAwc,MAAA;IACrF,IAAIzjB,EAAE,CAACoe,wBAAwB,CAACnX,IAAI,CAAC,EAAE;MACrC,OAAOA,IAAI,CAACmQ,QAAQ,CAAC2F,IAAI,CAAC,UAAC0F,CAAC,EAAK;QAAApgB,cAAA,OAAAohB,MAAA;QAC/B,MAAMtM,IAAI,GAAGnX,EAAE,CAACgjB,eAAe,CAACP,CAAC,CAAC,GAAGA,CAAC,CAAC9b,UAAU,GAAG8b,CAAC;QACrD,IAAIziB,EAAE,CAACoe,wBAAwB,CAACjH,IAAI,CAAC,EAAE;UACrC,OAAO7T,OAAO,CAACkgB,4BAA4B,CAACrM,IAAI,CAAC;QACnD;QACA,OAAOnX,EAAE,CAACgW,yBAAyB,CAACmB,IAAI,CAAC;MAC3C,CAAC,CAAApE,IAAA,OAAC;IACJ;IAEA,OAAO9L,IAAI,CAACmQ,QAAQ,CAAC2F,IAAI,CAAC,UAAC0F,CAAC,EAAK;MAAApgB,cAAA,OAAAohB,MAAA;MAC/B,IAAIzjB,EAAE,CAACojB,gBAAgB,CAACX,CAAC,CAAC,EAAE;QAC1B,IAAIziB,EAAE,CAACsjB,qBAAqB,CAACb,CAAC,CAAC3e,IAAI,CAAC,EAAE;UACpC,OAAOR,OAAO,CAACkgB,4BAA4B,CAACf,CAAC,CAAC3e,IAAI,CAAC;QACrD;QACA,OAAO9D,EAAE,CAACujB,sBAAsB,CAACd,CAAC,CAAC3e,IAAI,CAAC;MAC1C;MACA,OAAO,KAAK;IACd,CAAC,CAAAiP,IAAA,OAAC;EACJ;EAEA,OAAO2Q,gBAAgBA,CAACC,SAAuB,EAAU;IACvD,IAAIC,aAAa,GAAG,EAAE;IACtB,IAAI5jB,EAAE,CAAC+D,YAAY,CAAC4f,SAAS,CAAChd,UAAU,CAAC,EAAE;MACzCid,aAAa,GAAGD,SAAS,CAAChd,UAAU,CAACyS,IAAI;IAC3C,CAAC,MAAM,IAAIpZ,EAAE,CAACkS,gBAAgB,CAACyR,SAAS,CAAChd,UAAU,CAAC,IAAI3G,EAAE,CAAC+D,YAAY,CAAC4f,SAAS,CAAChd,UAAU,CAACA,UAAU,CAAC,EAAE;MACxGid,aAAa,GAAGD,SAAS,CAAChd,UAAU,CAACA,UAAU,CAACyS,IAAI;IACtD;IACA,OAAOwK,aAAa;EACtB;EAEA,OAAOC,2BAA2BA,CAAC9M,QAAqB,EAAe;IACrE,IAAI+M,iBAAiB,GAAG/M,QAAQ;IAChC,OAAO/W,EAAE,CAACuX,uBAAuB,CAACuM,iBAAiB,CAAC,EAAE;MACpDA,iBAAiB,GAAGA,iBAAiB,CAACtb,IAAI;IAC5C;IAEA,OAAOsb,iBAAiB;EAC1B;EAEAC,kBAAkBA,CAAChN,QAAqB,EAAW;IAAA,IAAAiN,OAAA;IAEjD;AACJ;AACA;AACA;AACA;AACA;;IAEIjN,QAAQ,GAAGzT,OAAO,CAACugB,2BAA2B,CAAC9M,QAAQ,CAAC;;IAExD;IACA,IAAI/W,EAAE,CAAC4X,eAAe,CAACb,QAAQ,CAAC,EAAE;MAChC,OAAOA,QAAQ,CAACvS,KAAK,CAACyf,KAAK,CAAC,UAAC7P,QAAQ,EAAK;QAAA/R,cAAA,OAAA2hB,OAAA;QACxC,OAAO,IAAI,CAACD,kBAAkB,CAAC3P,QAAQ,CAAC;MAC1C,CAAC,CAAArB,IAAA,OAAC;IACJ;IAEA,MAAMlM,GAAG,GAAG7G,EAAE,CAAC0X,mBAAmB,CAACX,QAAQ,CAAC,GAAG,IAAI,CAAC/P,oBAAoB,CAAC+P,QAAQ,CAAC6H,QAAQ,CAAC,GAAGvX,SAAS;IAEvG,IAAIR,GAAG,IAAIA,GAAG,CAACjC,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAACkG,WAAW,CAACge,SAAS,EAAE;MACpD,MAAMC,QAAQ,GAAG7gB,OAAO,CAAC8I,cAAc,CAACvF,GAAG,CAAC;MAC5C,IAAIsd,QAAQ,IAAInkB,EAAE,CAAC4f,sBAAsB,CAACuE,QAAQ,CAAC,EAAE;QACnD,OAAO,IAAI,CAACJ,kBAAkB,CAACI,QAAQ,CAAC3b,IAAI,CAAC;MAC/C;IACF;;IAEA;IACA,IAAIlF,OAAO,CAAC8gB,WAAW,CAACvd,GAAG,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb;IAEA,OAAO,IAAI,CAACwd,cAAc,CAAC,IAAI,CAAC7gB,aAAa,CAAC8gB,mBAAmB,CAACvN,QAAQ,CAAC,CAAC;EAC9E;EAEAsN,cAAcA,CAAC7b,IAAa,EAAW;IACrC,IACE,CAACA,IAAI,CAAC/D,KAAK,IACRzE,EAAE,CAAC0E,SAAS,CAACgE,OAAO,GACnB1I,EAAE,CAAC0E,SAAS,CAACzB,MAAM,GACnBjD,EAAE,CAAC0E,SAAS,CAAC1B,MAAM,GACnBhD,EAAE,CAAC0E,SAAS,CAAC6f,MAAM,GACnBvkB,EAAE,CAAC0E,SAAS,CAACsH,IAAI,GACjBhM,EAAE,CAAC0E,SAAS,CAACqH,SAAS,GACtB/L,EAAE,CAAC0E,SAAS,CAAC8f,aAAa,CAAC,MAC/B,CAAC,EACD;MACA,OAAO,IAAI;IACb;IAEA,OAAO,IAAI,CAACC,0BAA0B,CAACjc,IAAI,CAAC;EAC9C;EAEAkc,eAAeA,CAACrgB,MAAe,EAAW;IAAA,IAAAsgB,OAAA;IACxC,MAAM9d,GAAG,GAAGxC,MAAM,CAACiF,SAAS,CAAC,CAAC;IAC9B,IAAIhG,OAAO,CAAC8gB,WAAW,CAACvd,GAAG,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb;IAEA,IAAIxC,MAAM,CAACC,OAAO,CAAC,CAAC,EAAE;MACpB,OAAOD,MAAM,CAACG,KAAK,CAACyf,KAAK,CAAC,UAAC7P,QAAQ,EAAK;QAAA/R,cAAA,OAAAsiB,OAAA;QACtC,OAAO,IAAI,CAACD,eAAe,CAACtQ,QAAQ,CAAC;MACvC,CAAC,CAAArB,IAAA,OAAC;IACJ;IAEA,OAAO,IAAI,CAACsR,cAAc,CAAChgB,MAAM,CAAC;EACpC;EAEAogB,0BAA0BA,CAACjc,IAAa,EAAW;IACjD,MAAM3B,GAAG,GAAG2B,IAAI,CAACc,SAAS,CAAC,CAAC;IAC5B,IAAI,CAACzC,GAAG,EAAE;MACR,OAAO,KAAK;IACd;IAEA,MAAM+d,UAAU,GAAGthB,OAAO,CAACgH,eAAe,CAAC9B,IAAI,CAAC;;IAEhD;IACA,IAAIoc,UAAU,CAAClU,OAAO,CAAC,CAAC,EAAE;MACxB,IAAI7J,GAAG,CAAC0D,YAAY,EAAEpB,MAAM,EAAE;QAC5B,MAAMqW,IAAI,GAAG3Y,GAAG,CAAC0D,YAAY,CAAC,CAAC,CAAC;QAChC,IAAIvK,EAAE,CAAC4K,kBAAkB,CAAC4U,IAAI,CAAC,EAAE;UAC/B,OAAOlc,OAAO,CAACkN,oBAAoB,CAACgP,IAAI,CAAC;QAC3C;MACF;IACF;IACA;IACA,OAAO,IAAI,CAACrV,eAAe,CAAC3B,IAAI,EAAElF,OAAO,CAACgN,oBAAoB,CAAC;EACjE;EAEAuU,oCAAoCA,CAACrc,IAAa,EAAW;IAAA,IAAAsc,OAAA;IAC3D;IACA,IAAI,CAACtc,IAAI,CAAC/D,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACqgB,KAAK,MAAM,CAAC,EAAE;MAC3C,OAAO,CAAC,CAAEvc,IAAI,EAAmBhE,KAAK,EAAEuY,IAAI,CAAC,UAACvU,IAAI,EAAK;QAAAnG,cAAA,OAAAyiB,OAAA;QACrD,OAAO,IAAI,CAACD,oCAAoC,CAACrc,IAAI,CAAC;MACxD,CAAC,CAAAuK,IAAA,OAAC;IACJ;IAEA,OAAO,IAAI,CAAC0R,0BAA0B,CAACjc,IAAI,CAAC;EAC9C;EAEA,OAAO4b,WAAWA,CAACvd,GAA0B,EAAW;IACtD,OAAO,CAAC,CAACA,GAAG,IAAIA,GAAG,CAACpC,KAAK,KAAKzE,EAAE,CAACkG,WAAW,CAAC8e,SAAS;EACxD;EAEAC,mBAAmBA,CAACzc,IAAkB,EAAW;IAAA,IAAA0c,OAAA;IAC/C,MAAM1gB,KAAK,GAAGgE,IAAI,EAAEhE,KAAK;IACzB,IAAI,CAACA,KAAK,EAAE;MACV,OAAO,KAAK;IACd;IAEA,OAAOA,KAAK,CAACyf,KAAK,CAAC,UAACzb,IAAI,EAAK;MAAAnG,cAAA,OAAA6iB,OAAA;MAC3B,OAAO,IAAI,CAACb,cAAc,CAAC7b,IAAI,CAAC;IAClC,CAAC,CAAAuK,IAAA,OAAC;EACJ;EAEA,OAAOvC,oBAAoBA,CAACgP,IAAyB,EAAW;IAAA,IAAA2F,OAAA;IAC9D,MAAMC,UAAU,GAAGplB,EAAE,CAACqlB,aAAa,CAAC7F,IAAI,CAAC;IACzC,OAAO,CAAC,CAAC4F,UAAU,EAAErI,IAAI,CAAC,UAAC0F,CAAC,EAAK;MAAApgB,cAAA,OAAA8iB,OAAA;MAC/B,OAAO7hB,OAAO,CAACogB,gBAAgB,CAACjB,CAAC,CAAC,KAAK6C,+BAAkB;IAC3D,CAAC,CAAAvS,IAAA,OAAC;EACJ;EAEA,OAAOwS,wBAAwBA,CAAC/F,IAAyB,EAA8B;IAAA,IAAAgG,OAAA;IACrF,MAAMJ,UAAU,GAAGplB,EAAE,CAACqlB,aAAa,CAAC7F,IAAI,CAAC;IACzC,OAAO4F,UAAU,EAAEK,MAAM,CAAC,UAAChD,CAAC,EAAK;MAAApgB,cAAA,OAAAmjB,OAAA;MAC/B,OAAOliB,OAAO,CAACogB,gBAAgB,CAACjB,CAAC,CAAC,KAAK6C,+BAAkB;IAC3D,CAAC,CAAAvS,IAAA,OAAC;EACJ;EAEA,OAAO2S,8BAA8BA,CAACrN,WAA6B,EAAuC;IACxG,MAAMsN,SAAS,GAAGriB,OAAO,CAACsiB,2BAA2B,CAACvN,WAAW,CAAC;IAClE,IAAIsN,SAAS,KAAKte,SAAS,IAAI,CAAC/D,OAAO,CAACkN,oBAAoB,CAACmV,SAAS,CAAC,EAAE;MACvE,OAAOte,SAAS;IAClB;IACA,OAAOrH,EAAE,CAACqlB,aAAa,CAAChN,WAAW,CAAC;EACtC;EAEA,OAAeuN,2BAA2BA,CAACvN,WAA6B,EAAmC;IACzG,IAAIA,WAAW,CAAC9R,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACoe,SAAS,EAAE;MAChD,OAAO7lB,EAAE,CAAC4K,kBAAkB,CAACyN,WAAW,CAACnT,MAAM,CAACA,MAAM,CAAC,GAAGmT,WAAW,CAACnT,MAAM,CAACA,MAAM,GAAGmC,SAAS;IACjG;IACA,OAAOrH,EAAE,CAAC4K,kBAAkB,CAACyN,WAAW,CAACnT,MAAM,CAAC,GAAGmT,WAAW,CAACnT,MAAM,GAAGmC,SAAS;EACnF;EAEA,OAAOiJ,oBAAoBA,CAAC9H,IAAa,EAAW;IAClD,MAAM3C,MAAM,GAAG2C,IAAI,CAACyT,WAAW,IAAIzT,IAAI,CAACc,SAAS,CAAC,CAAC;IACnD,IAAIzD,MAAM,EAAE0E,YAAY,KAAKlD,SAAS,IAAIxB,MAAM,CAAC0E,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE;MACxE,OAAO,KAAK;IACd;IAEA,OAAO7F,OAAO,CAACwiB,2BAA2B,CAACjgB,MAAM,CAAC0E,YAAY,CAAC,CAAC,CAAC,CAAC;EACpE;EAEA,OAAeub,2BAA2BA,CAACtG,IAAoB,EAAW;IACxE,IAAI,CAACxf,EAAE,CAAC6K,sBAAsB,CAAC2U,IAAI,CAAC,IAAI,CAACA,IAAI,CAAC1b,IAAI,IAAI0b,IAAI,CAAC1b,IAAI,CAACsV,IAAI,KAAK2M,2CAAc,EAAE;MACvF,OAAO,KAAK;IACd;IAEA,IAAI,CAAC/lB,EAAE,CAACgmB,aAAa,CAACxG,IAAI,CAACta,MAAM,CAAC,IAAIsa,IAAI,CAACta,MAAM,CAACA,MAAM,CAACpB,IAAI,CAACsV,IAAI,KAAK6M,2CAAc,EAAE;MACrF,OAAO,KAAK;IACd;IAEA,IAAIpmB,IAAI,CAACud,QAAQ,CAACoC,IAAI,CAAChD,aAAa,CAAC,CAAC,CAACC,QAAQ,CAAC,CAACG,WAAW,CAAC,CAAC,KAAKsJ,6CAAgB,EAAE;MACnF,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;EAEAC,uBAAuBA,CAAClf,IAAkC,EAAW;IAEnE;AACJ;AACA;AACA;;IAEI,IAAIA,IAAI,CAACoM,UAAU,CAAClK,MAAM,KAAK,CAAC,EAAE;MAChC,OAAO,KAAK;IACd;IAEA,MAAMid,SAAS,GAAG,IAAI,CAAC5iB,aAAa,CAACsO,iBAAiB,CAAC7K,IAAI,CAACoM,UAAU,CAAC,CAAC,CAAC,CAAC;IAC1E,IAAI,CAAC+S,SAAS,CAAC3hB,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACzB,MAAM,MAAM,CAAC,EAAE;MACjD,OAAO,KAAK;IACd;IAEA,OAAO,IAAI,CAACojB,sCAAsC,CAACpf,IAAI,CAAC/B,MAAM,CAAC;EACjE;EAEAohB,+BAA+BA,CAAC9d,IAAa,EAAW;IACtD,MAAM3C,MAAM,GAAG2C,IAAI,CAACyT,WAAW,IAAIzT,IAAI,CAACc,SAAS,CAAC,CAAC;IACnD,IAAIzD,MAAM,EAAE0E,YAAY,KAAKlD,SAAS,IAAIxB,MAAM,CAAC0E,YAAY,CAACpB,MAAM,GAAG,CAAC,EAAE;MACxE,OAAO,KAAK;IACd;IAEA,OAAO,IAAI,CAACkd,sCAAsC,CAACxgB,MAAM,CAAC0E,YAAY,CAAC,CAAC,CAAC,CAAC;EAC5E;EAEQ8b,sCAAsCA,CAAC7G,IAAoB,EAAW;IAC5E,IAAI,CAACxf,EAAE,CAAC4K,kBAAkB,CAAC4U,IAAI,CAAC,IAAI,CAACxf,EAAE,CAAC6K,sBAAsB,CAAC2U,IAAI,CAAC,IAAI,CAACA,IAAI,CAAC1b,IAAI,EAAE;MAClF,OAAO,KAAK;IACd;IAEA,IAAI,CAAC,IAAI,CAACN,aAAa,CAACsO,iBAAiB,CAAC0N,IAAI,CAAC,CAAC+G,kBAAkB,CAAC,CAAC,EAAE;MACpE,OAAO,KAAK;IACd;IAEA,IAAI,CAACvmB,EAAE,CAACgmB,aAAa,CAACxG,IAAI,CAACta,MAAM,CAAC,IAAIsa,IAAI,CAACta,MAAM,CAACA,MAAM,CAACpB,IAAI,CAACsV,IAAI,KAAKoN,kDAAqB,EAAE;MAC5F,OAAO,KAAK;IACd;IAEA,IAAI3mB,IAAI,CAACud,QAAQ,CAACoC,IAAI,CAAChD,aAAa,CAAC,CAAC,CAACC,QAAQ,CAAC,CAACG,WAAW,CAAC,CAAC,KAAK6J,oDAAuB,EAAE;MAC1F,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;EAEQC,6BAA6BA,CACnCC,4BAAqC,EACrCC,YAA6B,EAC7BC,WAA4B,EAC5BC,uBAAgC,EACX;IAAA,IAAAC,OAAA;IACrB,IACEJ,4BAA4B,IAC5B3mB,EAAE,CAACsY,wBAAwB,CAACuO,WAAW,CAAC,IACxCA,WAAW,CAACxT,UAAU,CAAC0J,IAAI,CAAC,UAAC0F,CAAC,EAAK;MAAApgB,cAAA,OAAA0kB,OAAA;MACjC,OACE/mB,EAAE,CAAC+D,YAAY,CAAC0e,CAAC,CAAC3e,IAAI,CAAC,IACvB,IAAI,CAACoe,iBAAiB,CAACO,CAAC,CAAC,IACzB,IAAI,CAACuE,wCAAwC,CAC3CJ,YAAY,CAAC9iB,IAAI,EACjB2e,CAAC,CAAC3e,IAAI,EACNgjB,uBACF,CAAC;IAEL,CAAC,CAAA/T,IAAA,OAAC,EACF;MACA,OAAO,IAAI;IACb;IACA,OAAO1L,SAAS;EAClB;EAEQ4f,gBAAgBA,CACtBL,YAA6B,EAC7BM,SAAkB,EAClBJ,uBAAgC,EACX;IACrB,IAAII,SAAS,EAAE;MACb,MAAMrV,QAAQ,GAAGvO,OAAO,CAACqf,gBAAgB,CAACuE,SAAS,CAAC;MACpD,IAAIrV,QAAQ,EAAE;QACZ,MAAMsV,QAAQ,GAAGtV,QAAQ,CAACvI,SAAS,CAAC,CAAC,EAAE8d,gBAA2C;QAClF,IAAID,QAAQ,EAAE;UACZ,OAAO,IAAI,CAACE,2BAA2B,CAACT,YAAY,EAAEO,QAAQ,EAAEL,uBAAuB,CAAC;QAC1F;MACF;IACF;IACA,OAAOzf,SAAS;EAClB;EAEAggB,2BAA2BA,CACzBT,YAA6B,EAC7BU,eAAwC,EACxCR,uBAAgC,EAChCI,SAAmB,EACV;IAET;AACJ;AACA;AACA;IACI,IAAI,CAAC5jB,OAAO,CAACikB,+BAA+B,CAACX,YAAY,CAAC9iB,IAAI,CAAC,EAAE;MAC/D,OAAO,KAAK;IACd;IAEA,MAAM6iB,4BAA4B,GAAG,IAAI,CAACA,4BAA4B,CAACG,uBAAuB,CAAC;IAC/F,KAAK,MAAMD,WAAW,IAAIS,eAAe,CAAC9U,OAAO,EAAE;MACjD,IAAIoU,YAAY,KAAKC,WAAW,EAAE;QAChC;MACF;;MAEA;MACA,MAAMW,mCAAmC,GAAG,IAAI,CAACd,6BAA6B,CAC5EC,4BAA4B,EAC5BC,YAAY,EACZC,WAAW,EACXC,uBACF,CAAC;MACD,IAAIU,mCAAmC,EAAE;QACvC,OAAOA,mCAAmC;MAC5C;MACA,IAAI,CAAClkB,OAAO,CAACikB,+BAA+B,CAACV,WAAW,CAAC/iB,IAAI,CAAC,EAAE;QAC9D;MACF;MACA,IAAI,IAAI,CAACkjB,wCAAwC,CAACJ,YAAY,CAAC9iB,IAAI,EAAE+iB,WAAW,CAAC/iB,IAAI,EAAEgjB,uBAAuB,CAAC,EAAE;QAC/G,OAAO,IAAI;MACb;IACF;IAEA,IAAIH,4BAA4B,EAAE;MAChCO,SAAS,KAAK,IAAI,CAAC1jB,aAAa,CAACsO,iBAAiB,CAACwV,eAAe,CAAC;MACnE,MAAMG,sBAAsB,GAAG,IAAI,CAACR,gBAAgB,CAACL,YAAY,EAAEM,SAAS,EAAEJ,uBAAuB,CAAC;MACtG,IAAIW,sBAAsB,EAAE;QAC1B,OAAOA,sBAAsB;MAC/B;IACF;IAEA,OAAO,KAAK;EACd;EAEQd,4BAA4BA,CAACG,uBAAgC,EAAW;IAC9E,OAAO,IAAI,CAACnjB,UAAU,IAAImjB,uBAAuB;EACnD;EAEA,OAAeS,+BAA+BA,CAACtgB,IAAsB,EAAgD;IACnH,IAAI,CAACA,IAAI,EAAE;MACT,OAAO,KAAK;IACd;IACA,OAAOjH,EAAE,CAAC+D,YAAY,CAACkD,IAAI,CAAC,IAAIjH,EAAE,CAAC0nB,mBAAmB,CAACzgB,IAAI,CAAC;EAC9D;EAEQ+f,wCAAwCA,CAC9CW,MAA4C,EAC5CC,MAA4C,EAC5Cd,uBAAgC,EACvB;IACT,IAAI9mB,EAAE,CAAC+D,YAAY,CAAC4jB,MAAM,CAAC,IAAI3nB,EAAE,CAAC0nB,mBAAmB,CAACE,MAAM,CAAC,EAAE;MAC7D,OAAOD,MAAM,CAACvO,IAAI,KAAKwO,MAAM,CAACxO,IAAI,CAACT,SAAS,CAAC,CAAC,CAAC;IACjD;IACA,IAAI3Y,EAAE,CAAC+D,YAAY,CAAC6jB,MAAM,CAAC,IAAI5nB,EAAE,CAAC0nB,mBAAmB,CAACC,MAAM,CAAC,EAAE;MAC7D,OAAOC,MAAM,CAACxO,IAAI,KAAKuO,MAAM,CAACvO,IAAI,CAACT,SAAS,CAAC,CAAC,CAAC;IACjD;IACA,IACE,IAAI,CAACgO,4BAA4B,CAACG,uBAAuB,CAAC,IAC1D9mB,EAAE,CAAC0nB,mBAAmB,CAACC,MAAM,CAAC,IAC9B3nB,EAAE,CAAC0nB,mBAAmB,CAACE,MAAM,CAAC,EAC9B;MACA,OAAOD,MAAM,CAACvO,IAAI,CAACT,SAAS,CAAC,CAAC,CAAC,KAAKiP,MAAM,CAACxO,IAAI,CAACT,SAAS,CAAC,CAAC,CAAC;IAC9D;IACA,OAAO,KAAK;EACd;EAEAkP,2BAA2BA,CAAChiB,MAAiB,EAAsB;IACjE,IAAI/B,IAAI,GAAGR,OAAO,CAACwkB,2BAA2B,CAACjiB,MAAM,CAAC/B,IAAI,CAAC;IAC3D,IAAIA,IAAI,KAAKuD,SAAS,IAAIvD,IAAI,KAAK+B,MAAM,CAAC/B,IAAI,EAAE;MAC9C,OAAOA,IAAI;IACb;IAEA,MAAMikB,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAACniB,MAAM,CAAC;IACjD,IAAIkiB,UAAU,KAAK1gB,SAAS,EAAE;MAC5B,OAAOA,SAAS;IAClB;IAEA,OAAO,IAAI,CAAC0M,YAAY,CAACgU,UAAU,EAAEjkB,IAAI,CAAC,KAAKuD,SAAS,EAAE;MACxDvD,IAAI,GAAG,GAAG,GAAGA,IAAI;IACnB;IAEA,OAAOA,IAAI;EACb;EAEA,OAAegkB,2BAA2BA,CAACG,GAAW,EAAsB;IAC1E,IAAIxV,MAAc,GAAG,EAAE;IAEvB,IAAIyV,MAAM,GAAG,CAAC;IACd,OAAOA,MAAM,GAAGD,GAAG,CAAC9e,MAAM,EAAE;MAC1B,MAAMgf,SAAS,GAAGF,GAAG,CAACG,WAAW,CAACF,MAAM,CAAC;MACzC,IAAI,CAACC,SAAS,EAAE;QACd,OAAO9gB,SAAS;MAClB;MAEA,MAAMghB,QAAQ,GAAG/kB,OAAO,CAAC+kB,QAAQ,CAACF,SAAS,CAAC;MAE5C,IAAID,MAAM,KAAK,CAAC,IAAI,CAACloB,EAAE,CAACsoB,iBAAiB,CAACH,SAAS,EAAE9gB,SAAS,CAAC,EAAE;QAC/DoL,MAAM,GAAG,IAAI;MACf;MAEA,IAAI,CAACzS,EAAE,CAACuoB,gBAAgB,CAACJ,SAAS,EAAE9gB,SAAS,CAAC,EAAE;QAC9C,IAAI8gB,SAAS,KAAK,IAAI,EAAE;UACtB1V,MAAM,IAAI,GAAG;QACf,CAAC,MAAM;UACLA,MAAM,IAAI,GAAG,GAAG0V,SAAS,CAAClkB,QAAQ,CAAC,EAAE,CAAC;QACxC;MACF,CAAC,MAAM;QACL,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkmB,QAAQ,EAAElmB,CAAC,EAAE,EAAE;UACjCsQ,MAAM,IAAIwV,GAAG,CAACO,MAAM,CAACN,MAAM,GAAG/lB,CAAC,CAAC;QAClC;MACF;MAEA+lB,MAAM,IAAIG,QAAQ;IACpB;IAEA,OAAO5V,MAAM;EACf;EAEA,OAAe4V,QAAQA,CAACF,SAAiB,EAAU;IACjD,OAAOA,SAAS,IAAI,OAAO,GAAG,CAAC,GAAG,CAAC;EACrC;EAEQH,iBAAiBA,CAACniB,MAAiB,EAAuB;IAChE,IAAIA,MAAM,CAAC0E,YAAY,KAAKlD,SAAS,EAAE;MACrC,OAAOA,SAAS;IAClB;IAEA,KAAK,MAAMohB,QAAQ,IAAI5iB,MAAM,CAAC0E,YAAY,EAAE;MAC1C,IACE,CAACvK,EAAE,CAAC2S,qBAAqB,CAAC8V,QAAQ,CAAC,IACnC,CAACzoB,EAAE,CAACoV,oBAAoB,CAACqT,QAAQ,CAAC,IAClC,CAACzoB,EAAE,CAAC0oB,mBAAmB,CAACD,QAAQ,CAAC,EACjC;QACA,OAAOphB,SAAS;MAClB;MAEA,MAAMmB,IAAI,GAAG,IAAI,CAAChF,aAAa,CAACsO,iBAAiB,CAAC2W,QAAQ,CAACvjB,MAAM,CAAC;MAClE,IAAIsD,IAAI,KAAKnB,SAAS,EAAE;QACtB,OAAOmB,IAAI;MACb;IACF;IAEA,OAAOnB,SAAS;EAClB;EAEA,OAAOshB,oCAAoCA,CAAC9iB,MAAiB,EAAW;IACtE,IAAIA,MAAM,CAAC0E,YAAY,KAAKlD,SAAS,EAAE;MACrC,OAAO,KAAK;IACd;IAEA,KAAK,MAAMohB,QAAQ,IAAI5iB,MAAM,CAAC0E,YAAY,EAAE;MAC1C,IAAI,CAACvK,EAAE,CAAC2S,qBAAqB,CAAC8V,QAAQ,CAAC,IAAI,CAACzoB,EAAE,CAAC0oB,mBAAmB,CAACD,QAAQ,CAAC,EAAE;QAC5E,OAAO,KAAK;MACd;MAEA,IAAI,CAACzoB,EAAE,CAAC4K,kBAAkB,CAAC6d,QAAQ,CAACvjB,MAAM,CAAC,IAAI,CAAClF,EAAE,CAAC6K,sBAAsB,CAAC4d,QAAQ,CAACvjB,MAAM,CAAC,EAAE;QAC1F,OAAO,KAAK;MACd;MAEA,IAAI5B,OAAO,CAAC6C,WAAW,CAACnG,EAAE,CAAC6S,YAAY,CAAC4V,QAAQ,CAACvjB,MAAM,CAAC,EAAElF,EAAE,CAACyH,UAAU,CAACmhB,aAAa,CAAC,EAAE;QACtF,OAAO,KAAK;MACd;IACF;IAEA,OAAO,IAAI;EACb;EAEA,OAAO/K,qBAAqBA,CAACrV,IAAa,EAAW;IACnD,OAAO,CAAC,EAAEA,IAAI,CAAC/D,KAAK,GAAGzE,EAAE,CAAC0E,SAAS,CAACmkB,YAAY,CAAC;EACnD;EAEAC,YAAYA,CAACzkB,MAAe,EAAW;IACrC,IAAI,CAACA,MAAM,CAACO,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC0E,SAAS,CAAC1B,MAAM,MAAM,CAAC,EAAE;MACnD,OAAO,IAAI;IACb;IAEA,IAAI,CAACM,OAAO,CAAC2F,eAAe,CAAC5E,MAAM,CAAC,EAAE;MACpC,OAAO,KAAK;IACd;IAEA,MAAMwB,MAAM,GAAGxB,MAAM,CAACwB,MAAM;IAC5B,MAAM/B,IAAI,GAAG,IAAI,CAACN,aAAa,CAACkG,qBAAqB,CAAC7D,MAAM,CAAC;IAC7D,OAAO/B,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC6F,cAAc,CAAC9D,MAAM,CAAC;EACzD;EAEAkjB,YAAYA,CAACvgB,IAAa,EAAW;IACnC,MAAM3B,GAAG,GAAG2B,IAAI,CAAC3C,MAAM;IACvB,OAAO,CAAC,CAACgB,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAAC,CAAC,KAAK,KAAK,IAAI,IAAI,CAACI,cAAc,CAAC9C,GAAG,CAAC;EACrE;EAEAmiB,uBAAuBA,CAACxgB,IAAa,EAAW;IAAA,IAAAygB,OAAA;IAC9C,IAAIzgB,IAAI,CAAC2L,qBAAqB,CAAC,CAAC,EAAE;MAChC,OAAO3L,IAAI,CAAChE,KAAK,CAACuY,IAAI,CAAC,UAAC0F,CAAC,EAAK;QAAApgB,cAAA,OAAA4mB,OAAA;QAC5B,OAAO,IAAI,CAACD,uBAAuB,CAACvG,CAAC,CAAC;MACxC,CAAC,CAAA1P,IAAA,OAAC;IACJ;IACA,IAAIzP,OAAO,CAAC2F,eAAe,CAACT,IAAI,CAAC,EAAE;MACjC,MAAM0gB,QAAQ,GAAG,IAAI,CAAC1lB,aAAa,CAAC2lB,gBAAgB,CAAC3gB,IAAI,CAAC;MAC1D,OAAO0gB,QAAQ,CAACnM,IAAI,CAAC,UAAC0F,CAAC,EAAK;QAAApgB,cAAA,OAAA4mB,OAAA;QAC1B,OAAO,IAAI,CAACD,uBAAuB,CAACvG,CAAC,CAAC;MACxC,CAAC,CAAA1P,IAAA,OAAC;IACJ;IACA,OAAOvK,IAAI,CAACgY,eAAe,CAAC,CAAC;EAC/B;EAEA,OAAO4I,6BAA6BA,CAACniB,IAAa,EAAuB;IAAA,IAAAoiB,OAAA;IACvE,OAAOrpB,EAAE,CAACspB,YAAY,CAACriB,IAAI,EAAE,UAACsiB,QAAQ,EAAK;MAAAlnB,cAAA,OAAAgnB,OAAA;MACzC,OAAOrpB,EAAE,CAACwpB,YAAY,CAACD,QAAQ,CAACrkB,MAAM,CAAC;IACzC,CAAC,CAAA6N,IAAA,OAAC;EACJ;EAEA,OAAO0W,sBAAsBA,CAACxiB,IAAa,EAAmC;IAC5E,MAAMV,IAAI,GAAGU,IAAI,CAACV,IAAI;IACtB,OACEA,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACyT,mBAAmB,IAC1C3U,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACY,iBAAiB,IACxC9B,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACE,gBAAgB,IACvCpB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACiiB,iBAAiB,IACxCnjB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACI,oBAAoB,IAC3CtB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACG,oBAAoB,IAC3CrB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACC,eAAe,IACtCnB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACkiB,kBAAkB,IACzCpjB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACmiB,uBAAuB,IAC9CrjB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACoiB,iBAAiB,IACxCtjB,IAAI,KAAKvG,EAAE,CAACyH,UAAU,CAACqiB,0BAA0B;EAErD;EAEA,OAAOC,qBAAqBA,CAACxN,OAAsB,EAAEzY,IAAY,EAAW;IAAA,IAAAkmB,OAAA;IAC1E,OAAOzN,OAAO,CAAC0N,UAAU,CAAClN,IAAI,CAAC,UAACmN,IAAI,EAAK;MAAA,IAAAC,OAAA;MAAA9nB,cAAA,OAAA2nB,OAAA;MACvC,IAAIhqB,EAAE,CAACoqB,mBAAmB,CAACF,IAAI,CAAC,EAAE;QAChC,IAAI,CAACA,IAAI,CAACG,YAAY,EAAE;UACtB,OAAO,KAAK;QACd;QACA,IAAIH,IAAI,CAACG,YAAY,CAACC,aAAa,EAAE;UACnC,IAAItqB,EAAE,CAACuqB,iBAAiB,CAACL,IAAI,CAACG,YAAY,CAACC,aAAa,CAAC,EAAE;YACzD,OAAOJ,IAAI,CAACG,YAAY,CAACC,aAAa,CAACxmB,IAAI,CAACsV,IAAI,KAAKtV,IAAI;UAC3D;UACA,OAAOomB,IAAI,CAACG,YAAY,CAACC,aAAa,CAAClT,QAAQ,CAAC2F,IAAI,CAAC,UAAC0F,CAAC,EAAK;YAAApgB,cAAA,OAAA8nB,OAAA;YAC1D,OAAO1H,CAAC,CAAC3e,IAAI,CAACsV,IAAI,KAAKtV,IAAI;UAC7B,CAAC,CAAAiP,IAAA,OAAC;QACJ;QACA,OAAOmX,IAAI,CAACG,YAAY,CAACvmB,IAAI,EAAEsV,IAAI,KAAKtV,IAAI;MAC9C;MAEA,OACER,OAAO,CAACmmB,sBAAsB,CAACS,IAAI,CAAC,IACpCA,IAAI,CAACpmB,IAAI,KAAKuD,SAAS,IACvBrH,EAAE,CAAC+D,YAAY,CAACmmB,IAAI,CAACpmB,IAAI,CAAC,IAC1BomB,IAAI,CAACpmB,IAAI,CAACsV,IAAI,KAAKtV,IAAI;IAE3B,CAAC,CAAAiP,IAAA,OAAC;EACJ;EAEA,OAAOyX,kBAAkBA,CAACC,aAA4B,EAAElO,OAAsB,EAAsB;IAClG,IAAImO,OAA2B;IAE/B,GAAG;MACDA,OAAO,GAAGD,aAAa,CAAClhB,OAAO,CAAC,CAAC;MACjC,IAAImhB,OAAO,KAAKrjB,SAAS,IAAI/D,OAAO,CAACymB,qBAAqB,CAACxN,OAAO,EAAEmO,OAAO,CAAC,EAAE;QAC5E;MACF;MACA;IACF,CAAC,QAAQA,OAAO,KAAKrjB,SAAS;IAE9B,OAAOqjB,OAAO;EAChB;EAEA,OAAOC,cAAcA,CAAClJ,UAAyB,EAAW;IACxD,MAAMwI,UAAU,GAAGxI,UAAU,CAACwI,UAAU;IACxC,KAAK,MAAMvP,SAAS,IAAIuP,UAAU,EAAE;MAClC,IAAIjqB,EAAE,CAACoqB,mBAAmB,CAAC1P,SAAS,CAAC,EAAE;QACrC;MACF;MAEA,OACE1a,EAAE,CAAC4qB,qBAAqB,CAAClQ,SAAS,CAAC,IACnC1a,EAAE,CAACoW,eAAe,CAACsE,SAAS,CAAC/T,UAAU,CAAC,IACxC+T,SAAS,CAAC/T,UAAU,CAACyS,IAAI,KAAKyR,2BAAU;IAE5C;IACA,OAAO,KAAK;EACd;EAEAC,kBAAkBA,CAAC7jB,IAAa,EAA8B;IAC5D,MAAMJ,GAAG,GAAG,IAAI,CAACG,oBAAoB,CAACC,IAAI,CAAC;IAC3C,OAAO3D,OAAO,CAAC8I,cAAc,CAACvF,GAAG,CAAC;EACpC;EAEA,OAAOkkB,yBAAyBA,CAAC9jB,IAAoB,EAAW;IAC9D,OACEjH,EAAE,CAACgrB,qBAAqB,CAAC/jB,IAAI,CAAC,IAC9BjH,EAAE,CAACirB,mBAAmB,CAAChkB,IAAI,CAAC,IAC5BjH,EAAE,CAACkrB,wBAAwB,CAACjkB,IAAI,CAAC,IACjCjH,EAAE,CAACmrB,wBAAwB,CAAClkB,IAAI,CAAC,IACjCjH,EAAE,CAACsY,wBAAwB,CAACrR,IAAI,CAAC,IACjCjH,EAAE,CAACorB,oBAAoB,CAACnkB,IAAI,CAAC,IAC7BjH,EAAE,CAACqrB,eAAe,CAACpkB,IAAI,CAAC;EAE5B;EAEAqkB,iBAAiBA,CAACrkB,IAAa,EAAW;IACxC,MAAMuY,IAAI,GAAG,IAAI,CAACsL,kBAAkB,CAAC7jB,IAAI,CAAC;IAC1C,MAAM8P,QAAQ,GAAIyI,IAAI,EAAUhX,IAAI;IACpC,OAAOuO,QAAQ,IAAI,CAACzT,OAAO,CAACynB,yBAAyB,CAACvL,IAAK,CAAC,GAC1D,IAAI,CAACuE,kBAAkB,CAAChN,QAAQ,CAAC,GACjC,IAAI,CAAC2N,eAAe,CAAC,IAAI,CAAClhB,aAAa,CAACsO,iBAAiB,CAAC0N,IAAI,GAAGA,IAAI,GAAGvY,IAAI,CAAC,CAAC;EAClF;EAEAskB,gCAAgCA,CAACtkB,IAAa,EAAW;IACvD,MAAMuY,IAAI,GAAG,IAAI,CAACsL,kBAAkB,CAAC7jB,IAAI,CAAC;IAC1C,IAAI,CAACuY,IAAI,EAAE;MACT,OAAO,KAAK;IACd;IACA,IAAIxf,EAAE,CAAC4K,kBAAkB,CAAC4U,IAAI,CAAC,EAAE;MAC/B,OAAOlc,OAAO,CAACkN,oBAAoB,CAACgP,IAAI,CAAC;IAC3C;IACA,IAAIxf,EAAE,CAAC6K,sBAAsB,CAAC2U,IAAI,CAAC,EAAE;MACnC,OAAO,IAAI,CAACrV,eAAe,CAAC,IAAI,CAAC3G,aAAa,CAACsO,iBAAiB,CAAC0N,IAAI,CAAC,EAAElc,OAAO,CAACgN,oBAAoB,CAAC;IACvG;IACA,OAAO,KAAK;EACd;EAEA,OAAOkb,mBAAmBA,CAACC,cAAqC,EAAW;IACzE,IACE,CAACA,cAAc,CAACC,gBAAgB,IAChC7rB,IAAI,CAACud,QAAQ,CAACqO,cAAc,CAACC,gBAAgB,CAAC,CAAC9O,WAAW,CAAC,CAAC,KAAKsJ,6CAAgB,IAC/ErmB,IAAI,CAACud,QAAQ,CAACqO,cAAc,CAACC,gBAAgB,CAAC,CAAC9O,WAAW,CAAC,CAAC,KAAK6J,oDAAuB,EAC1F;MACA,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb;EAEAkF,oBAAoBA,CAAC1kB,IAAa,EAAW;IAAA,IAAA2kB,OAAA;IAC3C;IACA,IAAI5rB,EAAE,CAAC4X,eAAe,CAAC3Q,IAAI,CAAC,EAAE;MAC5B,OAAOA,IAAI,CAACzC,KAAK,CAACyf,KAAK,CAAC,UAAC7P,QAAQ,EAAK;QAAA/R,cAAA,OAAAupB,OAAA;QACpC,OAAO,IAAI,CAACC,WAAW,CAACzX,QAAQ,CAAC;MACnC,CAAC,CAAArB,IAAA,OAAC;IACJ;IACA,OAAO,IAAI,CAAC8Y,WAAW,CAAC5kB,IAAI,CAAC;EAC/B;EAEA4kB,WAAWA,CAAC5kB,IAAa,EAAW;IAClC,MAAMuY,IAAI,GAAG,IAAI,CAACsL,kBAAkB,CAAC7jB,IAAI,CAAC;IAC1C,OAAOuY,IAAI,GAAGxf,EAAE,CAAC4K,kBAAkB,CAAC4U,IAAI,CAAC,GAAG,KAAK;EACnD;AACF;AAACrc,OAAA,CAAAG,OAAA,GAAAA,OAAA;AAAAtC,QAAA,GAtzEYsC,OAAO;AAAAf,eAAA,CAAPe,OAAO,4BA4+Bc,IAAIM,GAAG,CAAC,CACtC,CAACkoB,iBAAO,CAACC,cAAc,EAAEzoB,QAAO,CAAC8W,+BAA+B,CAAC,EACjE,CAAC0R,iBAAO,CAACE,wBAAwB,EAAE1oB,QAAO,CAAC+W,yCAAyC,CAAC,EACrF,CAACyR,iBAAO,CAACG,cAAc,EAAE3oB,QAAO,CAACkX,+BAA+B,CAAC,EACjE,CAACsR,iBAAO,CAACI,aAAa,EAAE5oB,QAAO,CAACmX,8BAA8B,CAAC,EAC/D,CAACqR,iBAAO,CAACK,cAAc,EAAE7oB,QAAO,CAACqX,+BAA+B,CAAC,EACjE,CAACmR,iBAAO,CAACM,SAAS,EAAE9oB,QAAO,CAACsX,0BAA0B,CAAC,EACvD,CAACkR,iBAAO,CAACO,qBAAqB,EAAE/oB,QAAO,CAACuX,sCAAsC,CAAC,EAC/E,CAACiR,iBAAO,CAACQ,cAAc,EAAEhpB,QAAO,CAACwX,+BAA+B,CAAC,EACjE,CAACgR,iBAAO,CAACS,0BAA0B,EAAEjpB,QAAO,CAAC0X,2CAA2C,CAAC,EACzF,CAAC8Q,iBAAO,CAACU,aAAa,EAAElpB,QAAO,CAAC8X,8BAA8B,CAAC,EAC/D,CAAC0Q,iBAAO,CAACW,YAAY,EAAEnpB,QAAO,CAAC+X,kCAAkC,CAAC,EAClE,CAACyQ,iBAAO,CAACY,iBAAiB,EAAEppB,QAAO,CAAC+X,kCAAkC,CAAC,EACvE,CAACyQ,iBAAO,CAACa,qBAAqB,EAAErpB,QAAO,CAACiY,sCAAsC,CAAC,EAC/E,CAACuQ,iBAAO,CAACc,0BAA0B,EAAEtpB,QAAO,CAACmY,2CAA2C,CAAC,EACzF,CAACqQ,iBAAO,CAACe,eAAe,EAAEvpB,QAAO,CAACoY,gCAAgC,CAAC,EACnE,CAACoQ,iBAAO,CAACgB,oBAAoB,EAAExpB,QAAO,CAACqY,qCAAqC,CAAC,EAC7E,CAACmQ,iBAAO,CAACiB,mBAAmB,EAAEzpB,QAAO,CAACsY,oCAAoC,CAAC,EAC3E,CAACkQ,iBAAO,CAACkB,0BAA0B,EAAE1pB,QAAO,CAACyY,2CAA2C,CAAC,EACzF,CAAC+P,iBAAO,CAACmB,iBAAiB,EAAE3pB,QAAO,CAACwY,kCAAkC,CAAC,CACxE,CAAC","ignoreList":[]}