{"version":3,"file":"TypeScriptLinter.js","names":["path","_interopRequireWildcard","require","ts","_CookBookMsg","_FaultAttrs","_FaultDesc","_Logger","_ProblemSeverity","_Problems","_TypeScriptLinterConfig","_AutofixTitles","_Autofixer","_TsUtils","_AllowedStdSymbolAPI","_FunctionHasNoReturnErrorCode","_LimitedStandardUtilityTypes","_LimitedStdGlobalFunc","_LimitedStdObjectAPI","_LimitedStdProxyHandlerAPI","_LimitedStdReflectAPI","_NonInitializablePropertyDecorators","_NonReturnFunctionDecorators","_PropertyHasNoInitializerErrorCode","_ForEachNodeInSubtree","_HasPredecessor","_IsStdLibrary","_IsStruct","_LibraryTypeCallDiagnosticChecker","_SupportedStdCallAPI","_identiferUseInValueContext","_isAssignmentOperator","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_newArrowCheck","TypeError","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","String","Number","consoleLog","args","TypeScriptLinter","ideMode","outLine","k","length","Logger","info","initGlobals","filteredDiagnosticMessages","Set","sharedModulesCache","Map","initEtsHandlers","etsComponentExpression","SyntaxKind","EtsComponentExpression","handlersMap","handleEtsComponentExpression","initCounters","FaultID","LAST_ID","nodeCounters","lineCounters","constructor","tsTypeChecker","enableAutofix","useRtLogic","cancellationToken","incrementalLintInfo","tscStrictDiagnostics","reportAutofixCb","isEtsFileCb","ObjectLiteralExpression","handleObjectLiteralExpression","ArrayLiteralExpression","handleArrayLiteralExpression","Parameter","handleParameter","EnumDeclaration","handleEnumDeclaration","InterfaceDeclaration","handleInterfaceDeclaration","ThrowStatement","handleThrowStatement","ImportClause","handleImportClause","ForStatement","handleForStatement","ForInStatement","handleForInStatement","ForOfStatement","handleForOfStatement","ImportDeclaration","handleImportDeclaration","PropertyAccessExpression","handlePropertyAccessExpression","PropertyDeclaration","handlePropertyDeclaration","PropertyAssignment","handlePropertyAssignment","PropertySignature","handlePropertySignature","FunctionExpression","handleFunctionExpression","ArrowFunction","handleArrowFunction","CatchClause","handleCatchClause","FunctionDeclaration","handleFunctionDeclaration","PrefixUnaryExpression","handlePrefixUnaryExpression","BinaryExpression","handleBinaryExpression","VariableDeclarationList","handleVariableDeclarationList","VariableDeclaration","handleVariableDeclaration","ClassDeclaration","handleClassDeclaration","ModuleDeclaration","handleModuleDeclaration","TypeAliasDeclaration","handleTypeAliasDeclaration","ImportSpecifier","handleImportSpecifier","NamespaceImport","handleNamespaceImport","TypeAssertionExpression","handleTypeAssertionExpression","MethodDeclaration","handleMethodDeclaration","MethodSignature","handleMethodSignature","ClassStaticBlockDeclaration","handleClassStaticBlockDeclaration","Identifier","handleIdentifier","ElementAccessExpression","handleElementAccessExpression","EnumMember","handleEnumMember","TypeReference","handleTypeReference","ExportAssignment","handleExportAssignment","CallExpression","handleCallExpression","MetaProperty","handleMetaProperty","NewExpression","handleNewExpression","AsExpression","handleAsExpression","SpreadElement","handleSpreadOp","SpreadAssignment","GetAccessor","handleGetAccessor","SetAccessor","handleSetAccessor","ConstructSignature","handleConstructSignature","ExpressionWithTypeArguments","handleExpressionWithTypeArguments","ComputedPropertyName","handleComputedPropertyName","Constructor","handleConstructorDeclaration","PrivateIdentifier","handlePrivateIdentifier","IndexSignature","handleIndexSignature","TypeLiteral","handleTypeLiteral","ExportKeyword","handleExportKeyword","ExportDeclaration","handleExportDeclaration","tsUtils","TsUtils","testMode","advancedClassChecks","currentErrorLine","currentWarningLine","walkedComments","libraryTypeCallDiagnosticChecker","LibraryTypeCallDiagnosticChecker","supportedStdCallApiChecker","SupportedStdCallApiChecker","getLineAndCharacterOfNode","node","startPos","getStartPos","line","character","sourceFile","getLineAndCharacterOfPosition","incrementCounters","faultId","autofix","incrementCountersIdeMode","faultDescr","faultDesc","faultType","LinterConfig","tsSyntaxKindNames","kind","faultsAttrs","severity","ProblemSeverity","ERROR","totalErrorLines","errorLineNumbersString","WARNING","totalWarningLines","warningLineNumbersString","startOffset","endOffset","getHighlightRange","endPos","cookBookMsgNum","cookBookRef","cookBookTg","cookBookTag","isMsgNumValid","badNodeInfo","column","endLine","endColumn","start","end","type","problem","suggest","cookBookMsg","rule","ruleTag","autofixTitle","undefined","cookBookRefToFixTitle","problemsInfos","push","visitSourceFile","sf","_this","callback","totalVisitedNodes","isStructDeclaration","throwIfCancellationRequested","incrementedType","incrementOnlyTokens","handler","bind","stopCondition","shouldSkipCheck","parent","isConstructorDeclaration","terminalTokens","forEachNodeInSubtree","countInterfaceExtendsDifferentPropertyTypes","prop2type","propName","methodType","getText","propType","IntefaceExtendDifProps","countDeclarationsWithDuplicateName","tsNode","tsDeclNode","tsDeclKind","symbol","getSymbolAtLocation","symbolHasDuplicateName","DeclWithDuplicateName","countClassMembersWithDuplicateName","tsClassDecl","currentMember","members","classMemberHasDuplicateName","isPrototypePropertyAccess","tsPropertyAccess","propAccessSym","baseExprSym","baseExprType","isIdentifier","name","text","curPropAccess","isPropertyAccessExpression","trueSymbolAtLocation","expression","isLibrarySymbol","getTypeAtLocation","isAnyType","isPrototypeSymbol","isTypeSymbol","isFunctionSymbol","baseExprTypeNode","typeToTypeNode","NodeBuilderFlags","None","isFunctionTypeNode","interfaceInheritanceLint","heritageClauses","hClause","token","ExtendsKeyword","tsTypeExpr","types","tsExprType","isClass","InterfaceExtendsClass","isClassOrInterface","lintForInterfaceExtendsDifferentPorpertyTypes","props","getProperties","p","declarations","decl","isPropertyDecl","isPropertySignature","isPropertyDeclaration","isMethodDecl","isMethodSignature","isMethodDeclaration","objectLiteralExpr","isDestructuringAssignmentLHS","objectLiteralType","getContextualType","typeContainsSendableClassOrInterface","SendableObjectInitialization","isStructObjectInitializer","isDynamicLiteralInitializer","isObjectLiteralAssignable","autofixer","fixUntypedObjectLiteral","ObjectLiteralNoContextType","arrayLitNode","noContextTypeForArrayLiteral","arrayLitType","arrayLitElements","elements","element","isObjectLiteralExpression","ArrayLiteralNoContextType","_this2","tsParam","getDecoratorsIfInSendableClass","forEach","decorator","SendableClassDecorator","handleDeclarationDestructuring","handleDeclarationInferredType","enumNode","enumSymbol","enumDecls","getDeclarations","enumDeclCount","enumDeclsInFile","nodeSrcFile","getSourceFile","fixEnumMerging","EnumMerging","interfaceNode","iSymbol","iDecls","iDeclCount","InterfaceMerging","throwStmt","throwExprType","isOrDerivedFrom","isStdErrorType","checkForLoopDestructuring","forInit","isVariableDeclarationList","varDecl","isArrayBindingPattern","isObjectBindingPattern","DestructuringDeclaration","isArrayLiteralExpression","DestructuringAssignment","tsForStmt","tsForInit","initializer","tsForInStmt","tsForInInit","tsForOfStmt","tsForOfInit","importDeclNode","stmt","statements","isImportDeclaration","ImportAfterStatement","expr","moduleSpecifier","StringLiteral","assertClause","ImportAssertion","handleSharedModuleNoSideEffectImport","inSharedModule","importClause","SharedNoSideEffectImport","modulePath","normalize","fileName","isSharedModule","isCallExpression","propertyAccessNode","exprSym","Prototype","isSymbolAPI","ALLOWED_STD_SYMBOL_API","includes","getName","SymbolType","isClassObjectExpression","ClassAsObject","symbolHasEsObjectType","EsObjectType","isNumericLiteral","fixLiteralAsPropertyNamePropertyName","LiteralAsPropertyName","decorators","getDecorators","filterOutDecoratorsDiagnostics","NON_INITIALIZABLE_PROPERTY_DECORATORS","NON_INITIALIZABLE_PROPERTY_DECORATORS_TSC","begin","getStart","PROPERTY_HAS_NO_INITIALIZER_ERROR_CODE","classDecorators","NON_INITIALIZABLE_PROPERTY_CLASS_DECORATORS","handleDefiniteAssignmentAssertion","handleSendableClassProperty","_this3","typeNode","classNode","isClassDeclaration","hasSendableDecorator","isSendableTypeNode","SendablePropType","isRecordObjectInitializer","isLibraryType","isDynamic","checkTypeSet","isStdRecordType","fixLiteralAsPropertyNamePropertyAssignment","handleSendableInterfaceProperty","interfaceNodeType","isInterfaceDeclaration","isSendableClassOrInterface","expectedDecorators","range","code","_this4","some","decoratorName","getDecoratorName","filterOutDiagnostics","_this5","file","tscDiagnostics","filteredDiagnostics","filter","val","checkInRange","rangesToFilter","pos","filterStrictDiagnostics","filters","diagnosticChecker","_this6","checkDiagnostic","checkDiagnosticMessage","messageText","every","isClassLikeOrIface","isClassLike","funcExpr","isGenerator","asteriskToken","hasUnfixableReturnType","newRetTypeNode","handleMissingReturnType","fixFunctionExpression","getModifiers","GeneratorFunction","hasPredecessor","reportThisKeywordsInScope","body","LimitedReturnTypeInference","arrowFunc","contextType","tsFunctionDeclaration","funcDeclParent","isSourceFile","isModuleBlock","fixNestedFunction","LocalFunction","funcLikeDecl","isSignature","isAmbientDeclaration","flags","NodeFlags","Ambient","tryAutofixMissingReturnType","isFuncExpr","isFunctionExpression","hasLimitedRetTypeInference","hasLimitedTypeInferenceFromReturnExpr","tsSignature","getSignatureFromDeclaration","tsRetType","getReturnTypeOfSignature","isUnsupportedType","fixMissingReturnType","funBody","_this7","hasLimitedTypeInference","isReturnStatement","isCallToFunctionWithOmittedReturnType","unwrapParenthesized","isFunctionDeclaration","isAccessor","isArrowFunction","isBlock","tsExpr","isValidTypeForUnaryArithmeticOperator","typeFlags","getFlags","numberLiteralFlags","TypeFlags","BigIntLiteral","NumberLiteral","numberLikeFlags","BigIntLike","NumberLike","isNumberLike","isAllowedNumericType","isStdBigIntType","isStdNumberType","tsUnaryArithm","tsUnaryOp","operator","tsUnaryOperand","operand","PlusToken","MinusToken","TildeToken","tsOperatndType","isTilde","isInvalidTilde","isIntegerConstantValue","UnaryArithmNotNumber","tsBinaryExpr","tsLhsExpr","left","tsRhsExpr","right","isAssignmentOperator","operatorToken","processBinaryAssignment","leftOperandType","rightOperandType","getVariableDeclarationTypeNode","CommaToken","processBinaryComma","InstanceOfKeyword","processBinaryInstanceOf","InKeyword","InOperator","EqualsToken","needToDeduceStructuralIdentity","StructuralIdentity","handleEsObjectAssignment","rhsType","isArrayOrTuple","isArray","isTuple","hasNestedObjectDestructuring","useRelaxedRules","destructuringAssignmentHasSpreadOperator","tsLhsSymbol","tsLhsBaseSymbol","SymbolFlags","Method","MethodReassignment","isMethodAssignment","Function","PropertyDeclOnFunction","tsExprNode","tsParentNode","tsForNode","incrementor","ExpressionStatement","fixCommaOperator","CommaOperator","leftExpr","leftSymbol","ThisKeyword","isPrimitiveType","isTypeNode","InstanceofUnsupported","varDeclFlags","getCombinedNodeFlags","Let","Const","fixVarDeclaration","VarDeclaration","tsVarDecl","isVariableStatement","checkVarDeclForDuplicateNames","tsVarInit","tsVarType","tsInitType","handleEsObjectDelaration","isVariableDeclaration","DestructuringParameter","destructuringDeclarationHasSpreadOperator","tsBindingName","tsBindingElem","isOmittedExpression","isDeclaredESObject","isEsObjectType","initalizerTypeNode","isInitializedWithESObject","isLocal","isInsideBlock","nodeDeclType","isTypeAnnotated","isValueAssignableToESObject","tsCatch","variableDeclaration","dropTypeOnVarDecl","CatchWithUnsupportedType","_this8","isSendableClass","getNonSendableDecorators","typeParameters","typeParamDecl","checkSendableTypeParameter","checkClassDeclarationHeritageClause","classMember","scanCapturedVarsInSendableScope","processClassStaticBlocks","reduceReference","isSendableBaseType","ImplementsKeyword","ImplementsClass","SendableClassInheritance","isValidSendableClassExtends","sym","Class","Alias","realSym","getAliasedSymbol","defaultTypeNode","SendableGenericTypes","classDecl","staticBlocksCntr","staticBlockNodes","isClassStaticBlockDeclaration","fixMultipleStaticBlocks","MultipleStaticBlocks","tsModuleDecl","tsModuleBody","tsModifiers","handleModuleBlock","Namespace","hasModifier","DeclareKeyword","ShorthandAmbientModuleDecl","isStringLiteral","WildcardsInModuleName","moduleBlock","tsModuleStmt","VariableStatement","NonDeclarationInNamespace","tsTypeAlias","tsImportClause","importSpec","tsNamespaceImport","tsTypeAssertion","ConstAssertion","fixTypeAssertion","TypeAssertion","_this9","tsMethodDecl","isStatic","modifiers","mod","StaticKeyword","NON_RETURN_FUNCTION_DECORATORS","parameters","FUNCTION_HAS_NO_RETURN_ERROR_CODE","tsMethodSign","classStaticBlockDecl","tsIdentifier","tsIdentSym","Module","Transient","GlobalThis","handleRestrictedValues","isAllowedClassValueContext","ctx","isQualifiedName","isPropertyAssignment","isNewExpression","callee","isAny","hasLibraryType","illegalValues","ConstEnum","RegularEnum","ValueModule","isStruct","identiferUseInValueContext","NamespaceAsObject","isElementAcessAllowed","argType","isUnion","isArkTSCollectionsArrayLikeType","isNumberLikeType","isStringType","isStdMapType","isIntrinsicObjectType","isEnumType","tsElementAccessExpr","tsElementAccessExprSymbol","tsElemAccessBaseExprType","getNonNullableType","getTypeOrTypeConstraintAtLocation","tsElemAccessArgType","argumentExpression","fixPropertyAccessByIndex","PropertyAccessByIndex","hasEsObjectType","tsEnumMember","tsEnumMemberType","constVal","getConstantValue","isValidEnumMemberInit","EnumMemberNonConstInit","enumDecl","firstEnumMember","firstEnumMemberType","firstElewmVal","exportAssignment","isExportEquals","isShareableEntity","SharedModuleExports","tsCallExpr","calleeSym","callSignature","getResolvedSignature","handleImportCall","handleRequireCall","handleStdlibAPICall","handleFunctionApplyBindPropCall","handleGenericCallWithNoTypeArgs","handleStructIdentAndUndefinedInArgs","handleLibraryTypeCall","ImportKeyword","tsArgs","arguments","tsProp","properties","isShorthandPropertyAssignment","tsType","isInterfaceType","ImportAssignment","callLikeExpr","tsSyntaxKind","signFlags","WriteTypeArgumentsOfSignature","IgnoreErrors","signDecl","signatureToSignatureDeclaration","typeArguments","resolvedTypeArgs","startTypeArg","UnknownKeyword","GenericCallNoTypeArgs","exprName","getFullyQualifiedName","listFunctionApplyCallApis","FunctionApplyCall","listFunctionBindApis","FunctionBind","tsCallOrNewExpr","argIndex","tsArg","tsArgType","paramIndex","tsParamSym","tsParamDecl","valueDeclaration","isParameter","tsParamType","getTypeOfSymbolAtLocation","dotDotDotToken","isGenericArrayType","callExpr","parName","getParentSymbolName","LIMITED_STD_GLOBAL_FUNC","LimitedStdLibApi","escapedName","lookup","LimitedApis","arr","isSupportedStdCallAPI","fault","findNonFilteringRangesFunctionCalls","result","arg","arrowFuncExpr","_this10","calleeType","inLibCall","diagnosticMessages","configure","nonFilteringRanges","rangesSize","hasFiltered","ARGUMENT_OF_TYPE_0_IS_NOT_ASSIGNABLE_TO_PARAMETER_OF_TYPE_1_ERROR_CODE","NO_OVERLOAD_MATCHES_THIS_CALL_ERROR_CODE","TYPE_0_IS_NOT_ASSIGNABLE_TO_TYPE_1_ERROR_CODE","getEnd","OBJECT_IS_POSSIBLY_UNDEFINED_ERROR_CODE","msgChain","add","tsNewExpr","calleeExpr","isClassTypeExrepssion","isStdLibraryType","handleSendableGenericTypes","typeArgs","tsAsExpr","targetType","exprType","isBooleanLikeType","isStdBooleanType","isObject","SendableAsExpr","typeRef","isESObject","isPossiblyValidContext","isEsObjectPossiblyAllowed","typeName","entityNameToString","isStdUtilityType","LIMITED_STANDARD_UTILITY_TYPES","UtilityType","checkPartialType","isClassNodeReference","checkSendableTypeArguments","isStdPartial","hasSingleTypeArgument","firstTypeArg","getTypeFromTypeNode","typeArg","tsMetaProperty","NewTarget","isSpreadElement","spreadExprType","isCallLikeExpression","SpreadOperator","ConstructorType","ConstructorIface","isEsObjectSymbol","computedProperty","isSendableInvalidCompPropName","SendableComputedPropName","isValidComputedPropertyName","compProp","declNode","declNodeType","_this11","_this12","proceedVarPropDeclaration","skipPropertyInferredTypeCheck","AnyType","isCatchClause","validateDeclInferredType","exclamationToken","parentDecl","SendableDefiniteAssignment","DefiniteAssignment","checkAnyOrUnknownChildNode","AnyKeyword","child","getChildren","handleInferredObjectreference","getTypeArguments","haveAnyOrUnknownNodes","aliasSymbol","isObjectType","objectFlags","ObjectFlags","Reference","validatedTypesSet","unionElem","isUnknownType","UnknownType","handleCommentDirectives","pragmas","noCheckPragma","noCheckEntries","Array","entry","processNoCheckEntry","commentDirectives","directive","slice","MultiLineCommentTrivia","SingleLineCommentTrivia","commentRange","ErrorSuppression","scope","_this13","FunctionContainsThis","isClassExpression","isFunctionLike","isModuleDecl","isModuleDeclaration","_this14","ctorDecl","x","hasAccessModifier","paramTypes","collectCtorParamTypes","fixCtorParameterProperties","ParameterProperties","param","paramTypeNode","paramType","isSupportedType","ident","fixPrivateIdentifier","isAllowedIndexSignature","IndexMember","typeLiteral","fixTypeliteral","ObjectTypeLiteral","startNode","_this15","checkNamespaceImportVar","checkLocalDecl","isTypeReferenceNode","trueSym","isConstEnum","checkLocalDeclWithSendableClosure","declPosition","isTopSendableClosure","isEnumDeclaration","SendableCapturedVars","decls","isNamespaceImport","lint","Autofixer","clear","parentNode","isShareableType","declarationList","exportDecl","exportClause","SharedModuleNoWildcardExport","isNamespaceExport","exportSpecifier","exports","LIMITED_STD_OBJECT_API","LIMITED_STD_REFLECT_API","LIMITED_STD_PROXYHANDLER_API","SYMBOL","SYMBOL_CONSTRUCTOR"],"sources":["../../lib/TypeScriptLinter.ts"],"sourcesContent":["/*\n * Copyright (c) 2022-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as path from 'node:path';\nimport * as ts from 'typescript';\nimport { cookBookMsg, cookBookTag } from './CookBookMsg';\nimport { faultsAttrs } from './FaultAttrs';\nimport { faultDesc } from './FaultDesc';\nimport type { IncrementalLintInfo } from './IncrementalLintInfo';\nimport type { IsEtsFileCallback } from './IsEtsFileCallback';\nimport { Logger } from './Logger';\nimport type { ProblemInfo } from './ProblemInfo';\nimport { ProblemSeverity } from './ProblemSeverity';\nimport { FaultID } from './Problems';\nimport { LinterConfig } from './TypeScriptLinterConfig';\nimport { cookBookRefToFixTitle } from './autofixes/AutofixTitles';\nimport type { Autofix } from './autofixes/Autofixer';\nimport { Autofixer } from './autofixes/Autofixer';\nimport type { ReportAutofixCallback } from './autofixes/ReportAutofixCallback';\nimport { SYMBOL, SYMBOL_CONSTRUCTOR, TsUtils } from './utils/TsUtils';\nimport { ALLOWED_STD_SYMBOL_API } from './utils/consts/AllowedStdSymbolAPI';\nimport { FUNCTION_HAS_NO_RETURN_ERROR_CODE } from './utils/consts/FunctionHasNoReturnErrorCode';\nimport { LIMITED_STANDARD_UTILITY_TYPES } from './utils/consts/LimitedStandardUtilityTypes';\nimport { LIMITED_STD_GLOBAL_FUNC } from './utils/consts/LimitedStdGlobalFunc';\nimport { LIMITED_STD_OBJECT_API } from './utils/consts/LimitedStdObjectAPI';\nimport { LIMITED_STD_PROXYHANDLER_API } from './utils/consts/LimitedStdProxyHandlerAPI';\nimport { LIMITED_STD_REFLECT_API } from './utils/consts/LimitedStdReflectAPI';\nimport {\n  NON_INITIALIZABLE_PROPERTY_CLASS_DECORATORS,\n  NON_INITIALIZABLE_PROPERTY_DECORATORS,\n  NON_INITIALIZABLE_PROPERTY_DECORATORS_TSC\n} from './utils/consts/NonInitializablePropertyDecorators';\nimport { NON_RETURN_FUNCTION_DECORATORS } from './utils/consts/NonReturnFunctionDecorators';\nimport { PROPERTY_HAS_NO_INITIALIZER_ERROR_CODE } from './utils/consts/PropertyHasNoInitializerErrorCode';\nimport type { DiagnosticChecker } from './utils/functions/DiagnosticChecker';\nimport { forEachNodeInSubtree } from './utils/functions/ForEachNodeInSubtree';\nimport { hasPredecessor } from './utils/functions/HasPredecessor';\nimport { isStdLibraryType } from './utils/functions/IsStdLibrary';\nimport { isStruct, isStructDeclaration } from './utils/functions/IsStruct';\nimport {\n  ARGUMENT_OF_TYPE_0_IS_NOT_ASSIGNABLE_TO_PARAMETER_OF_TYPE_1_ERROR_CODE,\n  LibraryTypeCallDiagnosticChecker,\n  NO_OVERLOAD_MATCHES_THIS_CALL_ERROR_CODE,\n  OBJECT_IS_POSSIBLY_UNDEFINED_ERROR_CODE,\n  TYPE_0_IS_NOT_ASSIGNABLE_TO_TYPE_1_ERROR_CODE\n} from './utils/functions/LibraryTypeCallDiagnosticChecker';\nimport { SupportedStdCallApiChecker } from './utils/functions/SupportedStdCallAPI';\nimport { identiferUseInValueContext } from './utils/functions/identiferUseInValueContext';\nimport { isAssignmentOperator } from './utils/functions/isAssignmentOperator';\n\nexport function consoleLog(...args: unknown[]): void {\n  if (TypeScriptLinter.ideMode) {\n    return;\n  }\n  let outLine = '';\n  for (let k = 0; k < args.length; k++) {\n    outLine += `${args[k]} `;\n  }\n  Logger.info(outLine);\n}\n\nexport class TypeScriptLinter {\n  totalVisitedNodes: number = 0;\n  nodeCounters: number[] = [];\n  lineCounters: number[] = [];\n\n  totalErrorLines: number = 0;\n  errorLineNumbersString: string = '';\n  totalWarningLines: number = 0;\n  warningLineNumbersString: string = '';\n\n  problemsInfos: ProblemInfo[] = [];\n\n  tsUtils: TsUtils;\n\n  currentErrorLine: number;\n  currentWarningLine: number;\n  walkedComments: Set<number>;\n  libraryTypeCallDiagnosticChecker: LibraryTypeCallDiagnosticChecker;\n  supportedStdCallApiChecker: SupportedStdCallApiChecker;\n\n  autofixer: Autofixer | undefined;\n\n  private sourceFile?: ts.SourceFile;\n  private static sharedModulesCache: Map<string, boolean>;\n  static filteredDiagnosticMessages: Set<ts.DiagnosticMessageChain>;\n  static ideMode: boolean = false;\n  static testMode: boolean = false;\n  static useRelaxedRules = false;\n  static advancedClassChecks = false;\n\n  static initGlobals(): void {\n    TypeScriptLinter.filteredDiagnosticMessages = new Set<ts.DiagnosticMessageChain>();\n    TypeScriptLinter.sharedModulesCache = new Map<string, boolean>();\n  }\n\n  private initEtsHandlers(): void {\n\n    /*\n     * some syntax elements are ArkTs-specific and are only implemented inside patched\n     * compiler, so we initialize those handlers if corresponding properties do exist\n     */\n    const etsComponentExpression: ts.SyntaxKind | undefined = (ts.SyntaxKind as any).EtsComponentExpression;\n    if (etsComponentExpression) {\n      this.handlersMap.set(etsComponentExpression, this.handleEtsComponentExpression);\n    }\n  }\n\n  private initCounters(): void {\n    for (let i = 0; i < FaultID.LAST_ID; i++) {\n      this.nodeCounters[i] = 0;\n      this.lineCounters[i] = 0;\n    }\n  }\n\n  constructor(\n    private readonly tsTypeChecker: ts.TypeChecker,\n    private readonly enableAutofix: boolean,\n    private readonly useRtLogic: boolean,\n    private readonly cancellationToken?: ts.CancellationToken,\n    private readonly incrementalLintInfo?: IncrementalLintInfo,\n    private readonly tscStrictDiagnostics?: Map<string, ts.Diagnostic[]>,\n    private readonly reportAutofixCb?: ReportAutofixCallback,\n    private readonly isEtsFileCb?: IsEtsFileCallback\n  ) {\n    this.tsUtils = new TsUtils(\n      this.tsTypeChecker,\n      TypeScriptLinter.testMode,\n      TypeScriptLinter.advancedClassChecks,\n      useRtLogic\n    );\n    this.currentErrorLine = 0;\n    this.currentWarningLine = 0;\n    this.walkedComments = new Set<number>();\n    this.libraryTypeCallDiagnosticChecker = new LibraryTypeCallDiagnosticChecker(\n      TypeScriptLinter.filteredDiagnosticMessages\n    );\n    this.supportedStdCallApiChecker = new SupportedStdCallApiChecker(this.tsUtils, this.tsTypeChecker);\n\n    this.initEtsHandlers();\n    this.initCounters();\n  }\n\n  readonly handlersMap = new Map([\n    [ts.SyntaxKind.ObjectLiteralExpression, this.handleObjectLiteralExpression],\n    [ts.SyntaxKind.ArrayLiteralExpression, this.handleArrayLiteralExpression],\n    [ts.SyntaxKind.Parameter, this.handleParameter],\n    [ts.SyntaxKind.EnumDeclaration, this.handleEnumDeclaration],\n    [ts.SyntaxKind.InterfaceDeclaration, this.handleInterfaceDeclaration],\n    [ts.SyntaxKind.ThrowStatement, this.handleThrowStatement],\n    [ts.SyntaxKind.ImportClause, this.handleImportClause],\n    [ts.SyntaxKind.ForStatement, this.handleForStatement],\n    [ts.SyntaxKind.ForInStatement, this.handleForInStatement],\n    [ts.SyntaxKind.ForOfStatement, this.handleForOfStatement],\n    [ts.SyntaxKind.ImportDeclaration, this.handleImportDeclaration],\n    [ts.SyntaxKind.PropertyAccessExpression, this.handlePropertyAccessExpression],\n    [ts.SyntaxKind.PropertyDeclaration, this.handlePropertyDeclaration],\n    [ts.SyntaxKind.PropertyAssignment, this.handlePropertyAssignment],\n    [ts.SyntaxKind.PropertySignature, this.handlePropertySignature],\n    [ts.SyntaxKind.FunctionExpression, this.handleFunctionExpression],\n    [ts.SyntaxKind.ArrowFunction, this.handleArrowFunction],\n    [ts.SyntaxKind.CatchClause, this.handleCatchClause],\n    [ts.SyntaxKind.FunctionDeclaration, this.handleFunctionDeclaration],\n    [ts.SyntaxKind.PrefixUnaryExpression, this.handlePrefixUnaryExpression],\n    [ts.SyntaxKind.BinaryExpression, this.handleBinaryExpression],\n    [ts.SyntaxKind.VariableDeclarationList, this.handleVariableDeclarationList],\n    [ts.SyntaxKind.VariableDeclaration, this.handleVariableDeclaration],\n    [ts.SyntaxKind.ClassDeclaration, this.handleClassDeclaration],\n    [ts.SyntaxKind.ModuleDeclaration, this.handleModuleDeclaration],\n    [ts.SyntaxKind.TypeAliasDeclaration, this.handleTypeAliasDeclaration],\n    [ts.SyntaxKind.ImportSpecifier, this.handleImportSpecifier],\n    [ts.SyntaxKind.NamespaceImport, this.handleNamespaceImport],\n    [ts.SyntaxKind.TypeAssertionExpression, this.handleTypeAssertionExpression],\n    [ts.SyntaxKind.MethodDeclaration, this.handleMethodDeclaration],\n    [ts.SyntaxKind.MethodSignature, this.handleMethodSignature],\n    [ts.SyntaxKind.ClassStaticBlockDeclaration, this.handleClassStaticBlockDeclaration],\n    [ts.SyntaxKind.Identifier, this.handleIdentifier],\n    [ts.SyntaxKind.ElementAccessExpression, this.handleElementAccessExpression],\n    [ts.SyntaxKind.EnumMember, this.handleEnumMember],\n    [ts.SyntaxKind.TypeReference, this.handleTypeReference],\n    [ts.SyntaxKind.ExportAssignment, this.handleExportAssignment],\n    [ts.SyntaxKind.CallExpression, this.handleCallExpression],\n    [ts.SyntaxKind.MetaProperty, this.handleMetaProperty],\n    [ts.SyntaxKind.NewExpression, this.handleNewExpression],\n    [ts.SyntaxKind.AsExpression, this.handleAsExpression],\n    [ts.SyntaxKind.SpreadElement, this.handleSpreadOp],\n    [ts.SyntaxKind.SpreadAssignment, this.handleSpreadOp],\n    [ts.SyntaxKind.GetAccessor, this.handleGetAccessor],\n    [ts.SyntaxKind.SetAccessor, this.handleSetAccessor],\n    [ts.SyntaxKind.ConstructSignature, this.handleConstructSignature],\n    [ts.SyntaxKind.ExpressionWithTypeArguments, this.handleExpressionWithTypeArguments],\n    [ts.SyntaxKind.ComputedPropertyName, this.handleComputedPropertyName],\n    [ts.SyntaxKind.Constructor, this.handleConstructorDeclaration],\n    [ts.SyntaxKind.PrivateIdentifier, this.handlePrivateIdentifier],\n    [ts.SyntaxKind.IndexSignature, this.handleIndexSignature],\n    [ts.SyntaxKind.TypeLiteral, this.handleTypeLiteral],\n    [ts.SyntaxKind.ExportKeyword, this.handleExportKeyword],\n    [ts.SyntaxKind.ExportDeclaration, this.handleExportDeclaration]\n  ]);\n\n  private getLineAndCharacterOfNode(node: ts.Node | ts.CommentRange): ts.LineAndCharacter {\n    const startPos = TsUtils.getStartPos(node);\n    const { line, character } = this.sourceFile!.getLineAndCharacterOfPosition(startPos);\n    // TSC counts lines and columns from zero\n    return { line: line + 1, character: character + 1 };\n  }\n\n  incrementCounters(node: ts.Node | ts.CommentRange, faultId: number, autofix?: Autofix[]): void {\n    this.nodeCounters[faultId]++;\n    const { line, character } = this.getLineAndCharacterOfNode(node);\n    if (TypeScriptLinter.ideMode) {\n      this.incrementCountersIdeMode(node, faultId, autofix);\n    } else {\n      const faultDescr = faultDesc[faultId];\n      const faultType = LinterConfig.tsSyntaxKindNames[node.kind];\n      // Logger.info(\n      //   `Warning: ${this.sourceFile!.fileName} (${line}, ${character}): ${faultDescr ? faultDescr : faultType}`\n      // );\n    }\n    this.lineCounters[faultId]++;\n    switch (faultsAttrs[faultId].severity) {\n      case ProblemSeverity.ERROR: {\n        this.currentErrorLine = line;\n        ++this.totalErrorLines;\n        this.errorLineNumbersString += line + ', ';\n        break;\n      }\n      case ProblemSeverity.WARNING: {\n        if (line === this.currentWarningLine) {\n          break;\n        }\n        this.currentWarningLine = line;\n        ++this.totalWarningLines;\n        this.warningLineNumbersString += line + ', ';\n        break;\n      }\n    }\n  }\n\n  private incrementCountersIdeMode(node: ts.Node | ts.CommentRange, faultId: number, autofix?: Autofix[]): void {\n    if (!TypeScriptLinter.ideMode) {\n      return;\n    }\n    const [startOffset, endOffset] = TsUtils.getHighlightRange(node, faultId);\n    const startPos = this.sourceFile!.getLineAndCharacterOfPosition(startOffset);\n    const endPos = this.sourceFile!.getLineAndCharacterOfPosition(endOffset);\n\n    const faultDescr = faultDesc[faultId];\n    const faultType = LinterConfig.tsSyntaxKindNames[node.kind];\n\n    const cookBookMsgNum = faultsAttrs[faultId] ? faultsAttrs[faultId].cookBookRef : 0;\n    const cookBookTg = cookBookTag[cookBookMsgNum];\n    const severity = faultsAttrs[faultId]?.severity ?? ProblemSeverity.ERROR;\n    const isMsgNumValid = cookBookMsgNum > 0;\n    const badNodeInfo: ProblemInfo = {\n      line: startPos.line + 1,\n      column: startPos.character + 1,\n      endLine: endPos.line + 1,\n      endColumn: endPos.character + 1,\n      start: startOffset,\n      end: endOffset,\n      type: faultType,\n      severity: severity,\n      problem: FaultID[faultId],\n      suggest: isMsgNumValid ? cookBookMsg[cookBookMsgNum] : '',\n      rule: isMsgNumValid && cookBookTg !== '' ? cookBookTg : faultDescr ? faultDescr : faultType,\n      ruleTag: cookBookMsgNum,\n      autofix: autofix,\n      autofixTitle: isMsgNumValid && autofix !== undefined ? cookBookRefToFixTitle.get(cookBookMsgNum) : undefined\n    };\n    this.problemsInfos.push(badNodeInfo);\n    // problems with autofixes might be collected separately\n    if (this.reportAutofixCb && badNodeInfo.autofix) {\n      this.reportAutofixCb(badNodeInfo);\n    }\n  }\n\n  private visitSourceFile(sf: ts.SourceFile): void {\n    const callback = (node: ts.Node): void => {\n      this.totalVisitedNodes++;\n      if (isStructDeclaration(node)) {\n        // early exit via exception if cancellation was requested\n        this.cancellationToken?.throwIfCancellationRequested();\n      }\n      const incrementedType = LinterConfig.incrementOnlyTokens.get(node.kind);\n      if (incrementedType !== undefined) {\n        this.incrementCounters(node, incrementedType);\n      } else {\n        const handler = this.handlersMap.get(node.kind);\n        if (handler !== undefined) {\n\n          /*\n           * possibly requested cancellation will be checked in a limited number of handlers\n           * checked nodes are selected as construct nodes, similar to how TSC does\n           */\n          handler.call(this, node);\n        }\n      }\n    };\n    const stopCondition = (node: ts.Node): boolean => {\n      if (!node) {\n        return true;\n      }\n      if (this.incrementalLintInfo?.shouldSkipCheck(node)) {\n        return true;\n      }\n      // Skip synthetic constructor in Struct declaration.\n      if (node.parent && isStructDeclaration(node.parent) && ts.isConstructorDeclaration(node)) {\n        return true;\n      }\n      if (LinterConfig.terminalTokens.has(node.kind)) {\n        return true;\n      }\n      return false;\n    };\n    forEachNodeInSubtree(sf, callback, stopCondition);\n  }\n\n  private countInterfaceExtendsDifferentPropertyTypes(\n    node: ts.Node,\n    prop2type: Map<string, string>,\n    propName: string,\n    type: ts.TypeNode | undefined\n  ): void {\n    if (type) {\n      const methodType = type.getText();\n      const propType = prop2type.get(propName);\n      if (!propType) {\n        prop2type.set(propName, methodType);\n      } else if (propType !== methodType) {\n        this.incrementCounters(node, FaultID.IntefaceExtendDifProps);\n      }\n    }\n  }\n\n  private countDeclarationsWithDuplicateName(tsNode: ts.Node, tsDeclNode: ts.Node, tsDeclKind?: ts.SyntaxKind): void {\n    const symbol = this.tsTypeChecker.getSymbolAtLocation(tsNode);\n\n    /*\n     * If specific declaration kind is provided, check against it.\n     * Otherwise, use syntax kind of corresponding declaration node.\n     */\n    if (!!symbol && TsUtils.symbolHasDuplicateName(symbol, tsDeclKind ?? tsDeclNode.kind)) {\n      this.incrementCounters(tsDeclNode, FaultID.DeclWithDuplicateName);\n    }\n  }\n\n  private countClassMembersWithDuplicateName(tsClassDecl: ts.ClassDeclaration): void {\n    for (const currentMember of tsClassDecl.members) {\n      if (this.tsUtils.classMemberHasDuplicateName(currentMember, tsClassDecl, false)) {\n        this.incrementCounters(currentMember, FaultID.DeclWithDuplicateName);\n      }\n    }\n  }\n\n  private isPrototypePropertyAccess(\n    tsPropertyAccess: ts.PropertyAccessExpression,\n    propAccessSym: ts.Symbol | undefined,\n    baseExprSym: ts.Symbol | undefined,\n    baseExprType: ts.Type\n  ): boolean {\n    if (!(ts.isIdentifier(tsPropertyAccess.name) && tsPropertyAccess.name.text === 'prototype')) {\n      return false;\n    }\n\n    // #13600: Relax prototype check when expression comes from interop.\n    let curPropAccess: ts.Node = tsPropertyAccess;\n    while (curPropAccess && ts.isPropertyAccessExpression(curPropAccess)) {\n      const baseExprSym = this.tsUtils.trueSymbolAtLocation(curPropAccess.expression);\n      if (this.tsUtils.isLibrarySymbol(baseExprSym)) {\n        return false;\n      }\n      curPropAccess = curPropAccess.expression;\n    }\n\n    if (ts.isIdentifier(curPropAccess) && curPropAccess.text !== 'prototype') {\n      const type = this.tsTypeChecker.getTypeAtLocation(curPropAccess);\n      if (TsUtils.isAnyType(type)) {\n        return false;\n      }\n    }\n\n    // Check if property symbol is 'Prototype'\n    if (TsUtils.isPrototypeSymbol(propAccessSym)) {\n      return true;\n    }\n    // Check if symbol of LHS-expression is Class or Function.\n    if (TsUtils.isTypeSymbol(baseExprSym) || TsUtils.isFunctionSymbol(baseExprSym)) {\n      return true;\n    }\n\n    /*\n     * Check if type of LHS expression Function type or Any type.\n     * The latter check is to cover cases with multiple prototype\n     * chain (as the 'Prototype' property should be 'Any' type):\n     *      X.prototype.prototype.prototype = ...\n     */\n    const baseExprTypeNode = this.tsTypeChecker.typeToTypeNode(baseExprType, undefined, ts.NodeBuilderFlags.None);\n    return baseExprTypeNode && ts.isFunctionTypeNode(baseExprTypeNode) || TsUtils.isAnyType(baseExprType);\n  }\n\n  private interfaceInheritanceLint(node: ts.Node, heritageClauses: ts.NodeArray<ts.HeritageClause>): void {\n    for (const hClause of heritageClauses) {\n      if (hClause.token !== ts.SyntaxKind.ExtendsKeyword) {\n        continue;\n      }\n      const prop2type = new Map<string, string>();\n      for (const tsTypeExpr of hClause.types) {\n        const tsExprType = this.tsTypeChecker.getTypeAtLocation(tsTypeExpr.expression);\n        if (tsExprType.isClass()) {\n          this.incrementCounters(tsTypeExpr, FaultID.InterfaceExtendsClass);\n        } else if (tsExprType.isClassOrInterface()) {\n          this.lintForInterfaceExtendsDifferentPorpertyTypes(node, tsExprType, prop2type);\n        }\n      }\n    }\n  }\n\n  private lintForInterfaceExtendsDifferentPorpertyTypes(\n    node: ts.Node,\n    tsExprType: ts.Type,\n    prop2type: Map<string, string>\n  ): void {\n    const props = tsExprType.getProperties();\n    for (const p of props) {\n      if (!p.declarations) {\n        continue;\n      }\n      const decl: ts.Declaration = p.declarations[0];\n      const isPropertyDecl = ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl);\n      const isMethodDecl = ts.isMethodSignature(decl) || ts.isMethodDeclaration(decl);\n      if (isMethodDecl || isPropertyDecl) {\n        this.countInterfaceExtendsDifferentPropertyTypes(node, prop2type, p.name, decl.type);\n      }\n    }\n  }\n\n  private handleObjectLiteralExpression(node: ts.Node): void {\n    const objectLiteralExpr = node as ts.ObjectLiteralExpression;\n    // If object literal is a part of destructuring assignment, then don't process it further.\n    if (TsUtils.isDestructuringAssignmentLHS(objectLiteralExpr)) {\n      return;\n    }\n\n    const objectLiteralType = this.tsTypeChecker.getContextualType(objectLiteralExpr);\n    if (objectLiteralType && this.tsUtils.typeContainsSendableClassOrInterface(objectLiteralType)) {\n      this.incrementCounters(node, FaultID.SendableObjectInitialization);\n    } else if (\n      // issue 13082: Allow initializing struct instances with object literal.\n      !this.tsUtils.isStructObjectInitializer(objectLiteralExpr) &&\n      !this.tsUtils.isDynamicLiteralInitializer(objectLiteralExpr) &&\n      !this.tsUtils.isObjectLiteralAssignable(objectLiteralType, objectLiteralExpr)\n    ) {\n      const autofix = this.autofixer?.fixUntypedObjectLiteral(objectLiteralExpr, objectLiteralType);\n      this.incrementCounters(node, FaultID.ObjectLiteralNoContextType, autofix);\n    }\n  }\n\n  private handleArrayLiteralExpression(node: ts.Node): void {\n\n    /*\n     * If array literal is a part of destructuring assignment, then\n     * don't process it further.\n     */\n    if (TsUtils.isDestructuringAssignmentLHS(node as ts.ArrayLiteralExpression)) {\n      return;\n    }\n    const arrayLitNode = node as ts.ArrayLiteralExpression;\n    let noContextTypeForArrayLiteral = false;\n\n    const arrayLitType = this.tsTypeChecker.getContextualType(arrayLitNode);\n    if (arrayLitType && this.tsUtils.typeContainsSendableClassOrInterface(arrayLitType)) {\n      this.incrementCounters(node, FaultID.SendableObjectInitialization);\n      return;\n    }\n\n    /*\n     * check that array literal consists of inferrable types\n     * e.g. there is no element which is untyped object literals\n     */\n    const arrayLitElements = arrayLitNode.elements;\n    for (const element of arrayLitElements) {\n      if (ts.isObjectLiteralExpression(element)) {\n        const objectLiteralType = this.tsTypeChecker.getContextualType(element);\n        if (\n          !this.tsUtils.isDynamicLiteralInitializer(arrayLitNode) &&\n          !this.tsUtils.isObjectLiteralAssignable(objectLiteralType, element)\n        ) {\n          noContextTypeForArrayLiteral = true;\n          break;\n        }\n      }\n    }\n    if (noContextTypeForArrayLiteral) {\n      this.incrementCounters(node, FaultID.ArrayLiteralNoContextType);\n    }\n  }\n\n  private handleParameter(node: ts.Node): void {\n    const tsParam = node as ts.ParameterDeclaration;\n    TsUtils.getDecoratorsIfInSendableClass(tsParam)?.forEach((decorator) => {\n      this.incrementCounters(decorator, FaultID.SendableClassDecorator);\n    });\n    this.handleDeclarationDestructuring(tsParam);\n    this.handleDeclarationInferredType(tsParam);\n  }\n\n  private handleEnumDeclaration(node: ts.Node): void {\n    const enumNode = node as ts.EnumDeclaration;\n    this.countDeclarationsWithDuplicateName(enumNode.name, enumNode);\n    const enumSymbol = this.tsUtils.trueSymbolAtLocation(enumNode.name);\n    if (!enumSymbol) {\n      return;\n    }\n    const enumDecls = enumSymbol.getDeclarations();\n    if (!enumDecls) {\n      return;\n    }\n\n    /*\n     * Since type checker merges all declarations with the same name\n     * into one symbol, we need to check that there's more than one\n     * enum declaration related to that specific symbol.\n     * See 'countDeclarationsWithDuplicateName' method for details.\n     */\n    let enumDeclCount = 0;\n    const enumDeclsInFile: ts.Declaration[] = [];\n    const nodeSrcFile = enumNode.getSourceFile();\n    for (const decl of enumDecls) {\n      if (decl.kind === ts.SyntaxKind.EnumDeclaration) {\n        if (nodeSrcFile === decl.getSourceFile()) {\n          enumDeclsInFile.push(decl);\n        }\n        enumDeclCount++;\n      }\n    }\n\n    if (enumDeclCount > 1) {\n      const autofix = this.autofixer?.fixEnumMerging(enumSymbol, enumDeclsInFile);\n      this.incrementCounters(node, FaultID.EnumMerging, autofix);\n    }\n  }\n\n  private handleInterfaceDeclaration(node: ts.Node): void {\n    // early exit via exception if cancellation was requested\n    this.cancellationToken?.throwIfCancellationRequested();\n\n    const interfaceNode = node as ts.InterfaceDeclaration;\n    const iSymbol = this.tsUtils.trueSymbolAtLocation(interfaceNode.name);\n    const iDecls = iSymbol ? iSymbol.getDeclarations() : null;\n    if (iDecls) {\n\n      /*\n       * Since type checker merges all declarations with the same name\n       * into one symbol, we need to check that there's more than one\n       * interface declaration related to that specific symbol.\n       * See 'countDeclarationsWithDuplicateName' method for details.\n       */\n      let iDeclCount = 0;\n      for (const decl of iDecls) {\n        if (decl.kind === ts.SyntaxKind.InterfaceDeclaration) {\n          iDeclCount++;\n        }\n      }\n      if (iDeclCount > 1) {\n        this.incrementCounters(node, FaultID.InterfaceMerging);\n      }\n    }\n    if (interfaceNode.heritageClauses) {\n      this.interfaceInheritanceLint(node, interfaceNode.heritageClauses);\n    }\n    this.countDeclarationsWithDuplicateName(interfaceNode.name, interfaceNode);\n  }\n\n  private handleThrowStatement(node: ts.Node): void {\n    const throwStmt = node as ts.ThrowStatement;\n    const throwExprType = this.tsTypeChecker.getTypeAtLocation(throwStmt.expression);\n    if (\n      !throwExprType.isClassOrInterface() ||\n      !this.tsUtils.isOrDerivedFrom(throwExprType, this.tsUtils.isStdErrorType)\n    ) {\n      this.incrementCounters(node, FaultID.ThrowStatement);\n    }\n  }\n\n  private checkForLoopDestructuring(forInit: ts.ForInitializer): void {\n    if (ts.isVariableDeclarationList(forInit) && forInit.declarations.length === 1) {\n      const varDecl = forInit.declarations[0];\n      if (this.useRtLogic && (ts.isArrayBindingPattern(varDecl.name) || ts.isObjectBindingPattern(varDecl.name))) {\n        this.incrementCounters(varDecl, FaultID.DestructuringDeclaration);\n      }\n    }\n    if (ts.isArrayLiteralExpression(forInit) || ts.isObjectLiteralExpression(forInit)) {\n      this.incrementCounters(forInit, FaultID.DestructuringAssignment);\n    }\n  }\n\n  private handleForStatement(node: ts.Node): void {\n    const tsForStmt = node as ts.ForStatement;\n    const tsForInit = tsForStmt.initializer;\n    if (tsForInit) {\n      this.checkForLoopDestructuring(tsForInit);\n    }\n  }\n\n  private handleForInStatement(node: ts.Node): void {\n    const tsForInStmt = node as ts.ForInStatement;\n    const tsForInInit = tsForInStmt.initializer;\n    this.checkForLoopDestructuring(tsForInInit);\n    this.incrementCounters(node, FaultID.ForInStatement);\n  }\n\n  private handleForOfStatement(node: ts.Node): void {\n    const tsForOfStmt = node as ts.ForOfStatement;\n    const tsForOfInit = tsForOfStmt.initializer;\n    this.checkForLoopDestructuring(tsForOfInit);\n  }\n\n  private handleImportDeclaration(node: ts.Node): void {\n    // early exit via exception if cancellation was requested\n    this.cancellationToken?.throwIfCancellationRequested();\n\n    const importDeclNode = node as ts.ImportDeclaration;\n    for (const stmt of importDeclNode.parent.statements) {\n      if (stmt === importDeclNode) {\n        break;\n      }\n      if (!ts.isImportDeclaration(stmt)) {\n        this.incrementCounters(node, FaultID.ImportAfterStatement);\n        break;\n      }\n    }\n\n    const expr = importDeclNode.moduleSpecifier;\n    if (expr.kind === ts.SyntaxKind.StringLiteral) {\n      if (importDeclNode.assertClause) {\n        this.incrementCounters(importDeclNode.assertClause, FaultID.ImportAssertion);\n      }\n    }\n\n    // handle no side effect import in sendable module\n    this.handleSharedModuleNoSideEffectImport(importDeclNode);\n  }\n\n  private handleSharedModuleNoSideEffectImport(node: ts.ImportDeclaration): void {\n    // check 'use shared'\n    if (TypeScriptLinter.inSharedModule(node) && !node.importClause) {\n      this.incrementCounters(node, FaultID.SharedNoSideEffectImport);\n    }\n  }\n\n  private static inSharedModule(node: ts.Node): boolean {\n    const sourceFile: ts.SourceFile = node.getSourceFile();\n    const modulePath = path.normalize(sourceFile.fileName);\n    if (TypeScriptLinter.sharedModulesCache.has(modulePath)) {\n      return TypeScriptLinter.sharedModulesCache.get(modulePath)!;\n    }\n    const isSharedModule: boolean = TsUtils.isSharedModule(sourceFile);\n    TypeScriptLinter.sharedModulesCache.set(modulePath, isSharedModule);\n    return isSharedModule;\n  }\n\n  private handlePropertyAccessExpression(node: ts.Node): void {\n    if (ts.isCallExpression(node.parent) && node === node.parent.expression) {\n      return;\n    }\n\n    const propertyAccessNode = node as ts.PropertyAccessExpression;\n    const exprSym = this.tsUtils.trueSymbolAtLocation(propertyAccessNode);\n    const baseExprSym = this.tsUtils.trueSymbolAtLocation(propertyAccessNode.expression);\n    const baseExprType = this.tsTypeChecker.getTypeAtLocation(propertyAccessNode.expression);\n\n    if (this.isPrototypePropertyAccess(propertyAccessNode, exprSym, baseExprSym, baseExprType)) {\n      this.incrementCounters(propertyAccessNode.name, FaultID.Prototype);\n    }\n\n    if (!!exprSym && this.tsUtils.isSymbolAPI(exprSym) && !ALLOWED_STD_SYMBOL_API.includes(exprSym.getName())) {\n      this.incrementCounters(propertyAccessNode, FaultID.SymbolType);\n    }\n    if (TypeScriptLinter.advancedClassChecks && this.tsUtils.isClassObjectExpression(propertyAccessNode.expression)) {\n      // missing exact rule\n      this.incrementCounters(propertyAccessNode.expression, FaultID.ClassAsObject);\n    }\n\n    if (!!baseExprSym && TsUtils.symbolHasEsObjectType(baseExprSym)) {\n      this.incrementCounters(propertyAccessNode, FaultID.EsObjectType);\n    }\n  }\n\n  private handlePropertyDeclaration(node: ts.PropertyDeclaration): void {\n    const propName = node.name;\n    if (!!propName && ts.isNumericLiteral(propName)) {\n      const autofix = this.autofixer?.fixLiteralAsPropertyNamePropertyName(propName);\n      this.incrementCounters(node, FaultID.LiteralAsPropertyName, autofix);\n    }\n\n    const decorators = ts.getDecorators(node);\n    this.filterOutDecoratorsDiagnostics(\n      decorators,\n      this.useRtLogic ? NON_INITIALIZABLE_PROPERTY_DECORATORS : NON_INITIALIZABLE_PROPERTY_DECORATORS_TSC,\n      { begin: propName.getStart(), end: propName.getStart() },\n      PROPERTY_HAS_NO_INITIALIZER_ERROR_CODE\n    );\n    const classDecorators = ts.getDecorators(node.parent);\n    const propType = node.type?.getText();\n    this.filterOutDecoratorsDiagnostics(\n      classDecorators,\n      NON_INITIALIZABLE_PROPERTY_CLASS_DECORATORS,\n      { begin: propName.getStart(), end: propName.getStart() },\n      PROPERTY_HAS_NO_INITIALIZER_ERROR_CODE,\n      propType\n    );\n    this.handleDeclarationInferredType(node);\n    this.handleDefiniteAssignmentAssertion(node);\n    this.handleSendableClassProperty(node);\n  }\n\n  private handleSendableClassProperty(node: ts.PropertyDeclaration): void {\n    const typeNode = node.type;\n    if (!typeNode) {\n      return;\n    }\n    const classNode = node.parent;\n    if (!ts.isClassDeclaration(classNode) || !TsUtils.hasSendableDecorator(classNode)) {\n      return;\n    }\n    TsUtils.getDecoratorsIfInSendableClass(node)?.forEach((decorator) => {\n      this.incrementCounters(decorator, FaultID.SendableClassDecorator);\n    });\n    if (!this.tsUtils.isSendableTypeNode(typeNode)) {\n      this.incrementCounters(node, FaultID.SendablePropType);\n    }\n  }\n\n  private handlePropertyAssignment(node: ts.PropertyAssignment): void {\n    const propName = node.name;\n    if (!(!!propName && ts.isNumericLiteral(propName))) {\n      return;\n    }\n\n    /*\n     * We can use literals as property names only when creating Record or any interop instances.\n     * We can also initialize with constant string literals.\n     * Assignment with string enum values is handled in handleComputedPropertyName\n     */\n    let isRecordObjectInitializer = false;\n    let isLibraryType = false;\n    let isDynamic = false;\n    const objectLiteralType = this.tsTypeChecker.getContextualType(node.parent);\n    if (objectLiteralType) {\n      isRecordObjectInitializer = this.tsUtils.checkTypeSet(objectLiteralType, this.tsUtils.isStdRecordType);\n      isLibraryType = this.tsUtils.isLibraryType(objectLiteralType);\n    }\n\n    isDynamic = isLibraryType || this.tsUtils.isDynamicLiteralInitializer(node.parent);\n    if (!isRecordObjectInitializer && !isDynamic) {\n      const autofix = this.autofixer?.fixLiteralAsPropertyNamePropertyAssignment(node);\n      this.incrementCounters(node, FaultID.LiteralAsPropertyName, autofix);\n    }\n  }\n\n  private handlePropertySignature(node: ts.PropertySignature): void {\n    const propName = node.name;\n    if (!!propName && ts.isNumericLiteral(propName)) {\n      const autofix = this.autofixer?.fixLiteralAsPropertyNamePropertyName(propName);\n      this.incrementCounters(node, FaultID.LiteralAsPropertyName, autofix);\n    }\n    this.handleSendableInterfaceProperty(node);\n  }\n\n  private handleSendableInterfaceProperty(node: ts.PropertySignature): void {\n    const typeNode = node.type;\n    if (!typeNode) {\n      return;\n    }\n    const interfaceNode = node.parent;\n    const interfaceNodeType = this.tsTypeChecker.getTypeAtLocation(interfaceNode);\n    if (!ts.isInterfaceDeclaration(interfaceNode) || !this.tsUtils.isSendableClassOrInterface(interfaceNodeType)) {\n      return;\n    }\n    if (!this.tsUtils.isSendableTypeNode(typeNode)) {\n      this.incrementCounters(node, FaultID.SendablePropType);\n    }\n  }\n\n  private filterOutDecoratorsDiagnostics(\n    decorators: readonly ts.Decorator[] | undefined,\n    expectedDecorators: readonly string[],\n    range: { begin: number; end: number },\n    code: number,\n    propType?: string\n  ): void {\n    // Filter out non-initializable property decorators from strict diagnostics.\n    if (this.tscStrictDiagnostics && this.sourceFile) {\n      if (\n        decorators?.some((decorator) => {\n          const decoratorName = TsUtils.getDecoratorName(decorator);\n          // special case for property of type CustomDialogController of the @CustomDialog-decorated class\n          if (expectedDecorators.includes(NON_INITIALIZABLE_PROPERTY_CLASS_DECORATORS[0])) {\n            return expectedDecorators.includes(decoratorName) && propType === 'CustomDialogController';\n          }\n          return expectedDecorators.includes(decoratorName);\n        })\n      ) {\n        this.filterOutDiagnostics(range, code);\n      }\n    }\n  }\n\n  private filterOutDiagnostics(range: { begin: number; end: number }, code: number): void {\n    // Filter out strict diagnostics within the given range with the given code.\n    if (!this.tscStrictDiagnostics || !this.sourceFile) {\n      return;\n    }\n    const file = path.normalize(this.sourceFile.fileName);\n    const tscDiagnostics = this.tscStrictDiagnostics.get(file);\n    if (tscDiagnostics) {\n      const filteredDiagnostics = tscDiagnostics.filter((val) => {\n        if (val.code !== code) {\n          return true;\n        }\n        if (val.start === undefined) {\n          return true;\n        }\n        if (val.start < range.begin) {\n          return true;\n        }\n        if (val.start > range.end) {\n          return true;\n        }\n        return false;\n      });\n      this.tscStrictDiagnostics.set(file, filteredDiagnostics);\n    }\n  }\n\n  private static checkInRange(rangesToFilter: { begin: number; end: number }[], pos: number): boolean {\n    for (let i = 0; i < rangesToFilter.length; i++) {\n      if (pos >= rangesToFilter[i].begin && pos < rangesToFilter[i].end) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private filterStrictDiagnostics(\n    filters: { [code: number]: (pos: number) => boolean },\n    diagnosticChecker: DiagnosticChecker\n  ): boolean {\n    if (!this.tscStrictDiagnostics || !this.sourceFile) {\n      return false;\n    }\n    const file = path.normalize(this.sourceFile.fileName);\n    const tscDiagnostics = this.tscStrictDiagnostics.get(file);\n    if (!tscDiagnostics) {\n      return false;\n    }\n\n    const checkDiagnostic = (val: ts.Diagnostic): boolean => {\n      const checkInRange = filters[val.code];\n      if (!checkInRange) {\n        return true;\n      }\n      if (val.start === undefined || checkInRange(val.start)) {\n        return true;\n      }\n      return diagnosticChecker.checkDiagnosticMessage(val.messageText);\n    };\n\n    if (tscDiagnostics.every(checkDiagnostic)) {\n      return false;\n    }\n    this.tscStrictDiagnostics.set(file, tscDiagnostics.filter(checkDiagnostic));\n    return true;\n  }\n\n  private static isClassLikeOrIface(node: ts.Node): boolean {\n    return ts.isClassLike(node) || ts.isInterfaceDeclaration(node);\n  }\n\n  private handleFunctionExpression(node: ts.Node): void {\n    const funcExpr = node as ts.FunctionExpression;\n    const isGenerator = funcExpr.asteriskToken !== undefined;\n    const [hasUnfixableReturnType, newRetTypeNode] = this.handleMissingReturnType(funcExpr);\n    const autofix = this.autofixer?.fixFunctionExpression(\n      funcExpr,\n      newRetTypeNode,\n      ts.getModifiers(funcExpr),\n      isGenerator,\n      hasUnfixableReturnType\n    );\n    this.incrementCounters(funcExpr, FaultID.FunctionExpression, autofix);\n    if (isGenerator) {\n      this.incrementCounters(funcExpr, FaultID.GeneratorFunction);\n    }\n    if (!hasPredecessor(funcExpr, TypeScriptLinter.isClassLikeOrIface)) {\n      this.reportThisKeywordsInScope(funcExpr.body);\n    }\n    if (hasUnfixableReturnType) {\n      this.incrementCounters(funcExpr, FaultID.LimitedReturnTypeInference);\n    }\n  }\n\n  private handleArrowFunction(node: ts.Node): void {\n    const arrowFunc = node as ts.ArrowFunction;\n    if (!hasPredecessor(arrowFunc, TypeScriptLinter.isClassLikeOrIface)) {\n      this.reportThisKeywordsInScope(arrowFunc.body);\n    }\n    const contextType = this.tsTypeChecker.getContextualType(arrowFunc);\n    if (!(contextType && this.tsUtils.isLibraryType(contextType))) {\n      if (!arrowFunc.type) {\n        this.handleMissingReturnType(arrowFunc);\n      }\n    }\n  }\n\n  private handleFunctionDeclaration(node: ts.Node): void {\n    // early exit via exception if cancellation was requested\n    this.cancellationToken?.throwIfCancellationRequested();\n\n    const tsFunctionDeclaration = node as ts.FunctionDeclaration;\n    if (!tsFunctionDeclaration.type) {\n      this.handleMissingReturnType(tsFunctionDeclaration);\n    }\n    if (tsFunctionDeclaration.name) {\n      this.countDeclarationsWithDuplicateName(tsFunctionDeclaration.name, tsFunctionDeclaration);\n    }\n    if (tsFunctionDeclaration.body) {\n      this.reportThisKeywordsInScope(tsFunctionDeclaration.body);\n    }\n    const funcDeclParent = tsFunctionDeclaration.parent;\n    if (!ts.isSourceFile(funcDeclParent) && !ts.isModuleBlock(funcDeclParent)) {\n      const autofix = this.autofixer?.fixNestedFunction(tsFunctionDeclaration);\n      this.incrementCounters(tsFunctionDeclaration, FaultID.LocalFunction, autofix);\n    }\n    if (tsFunctionDeclaration.asteriskToken) {\n      this.incrementCounters(node, FaultID.GeneratorFunction);\n    }\n  }\n\n  private handleMissingReturnType(\n    funcLikeDecl: ts.FunctionLikeDeclaration | ts.MethodSignature\n  ): [boolean, ts.TypeNode | undefined] {\n    if (this.useRtLogic && funcLikeDecl.type) {\n      return [false, funcLikeDecl.type];\n    }\n\n    // Note: Return type can't be inferred for function without body.\n    const isSignature = ts.isMethodSignature(funcLikeDecl);\n    if (isSignature || !funcLikeDecl.body) {\n      // Ambient flag is not exposed, so we apply dirty hack to make it visible\n      const isAmbientDeclaration = !!(funcLikeDecl.flags & (ts.NodeFlags as any).Ambient);\n      if ((isSignature || isAmbientDeclaration) && !funcLikeDecl.type) {\n        this.incrementCounters(funcLikeDecl, FaultID.LimitedReturnTypeInference);\n      }\n      return [false, undefined];\n    }\n\n    return this.tryAutofixMissingReturnType(funcLikeDecl);\n  }\n\n  private tryAutofixMissingReturnType(funcLikeDecl: ts.FunctionLikeDeclaration): [boolean, ts.TypeNode | undefined] {\n    if (!funcLikeDecl.body) {\n      return [false, undefined];\n    }\n\n    let autofix: Autofix[] | undefined;\n    let newRetTypeNode: ts.TypeNode | undefined;\n    const isFuncExpr = ts.isFunctionExpression(funcLikeDecl);\n\n    /*\n     * Currently, ArkTS can't infer return type of function, when expression\n     * in the return statement is a call to a function or method whose return\n     * value type is omitted. In that case, we attempt to prepare an autofix.\n     */\n    let hasLimitedRetTypeInference = this.hasLimitedTypeInferenceFromReturnExpr(funcLikeDecl.body);\n    const tsSignature = this.tsTypeChecker.getSignatureFromDeclaration(funcLikeDecl);\n    if (tsSignature) {\n      const tsRetType = this.tsTypeChecker.getReturnTypeOfSignature(tsSignature);\n      if (!tsRetType || TsUtils.isUnsupportedType(tsRetType)) {\n        hasLimitedRetTypeInference = true;\n      } else if (hasLimitedRetTypeInference) {\n        newRetTypeNode = this.tsTypeChecker.typeToTypeNode(tsRetType, funcLikeDecl, ts.NodeBuilderFlags.None);\n        if (this.autofixer !== undefined && newRetTypeNode && !isFuncExpr) {\n          autofix = this.autofixer.fixMissingReturnType(funcLikeDecl, newRetTypeNode);\n        }\n      }\n    }\n\n    /*\n     * Don't report here if in function expression context.\n     * See handleFunctionExpression for details.\n     */\n    if (hasLimitedRetTypeInference && !isFuncExpr) {\n      this.incrementCounters(funcLikeDecl, FaultID.LimitedReturnTypeInference, autofix);\n    }\n\n    return [hasLimitedRetTypeInference && !newRetTypeNode, newRetTypeNode];\n  }\n\n  private hasLimitedTypeInferenceFromReturnExpr(funBody: ts.ConciseBody): boolean {\n    let hasLimitedTypeInference = false;\n    const callback = (node: ts.Node): void => {\n      if (hasLimitedTypeInference) {\n        return;\n      }\n      if (\n        ts.isReturnStatement(node) &&\n        node.expression &&\n        this.tsUtils.isCallToFunctionWithOmittedReturnType(TsUtils.unwrapParenthesized(node.expression))\n      ) {\n        hasLimitedTypeInference = true;\n      }\n    };\n    // Don't traverse other nested function-like declarations.\n    const stopCondition = (node: ts.Node): boolean => {\n      return (\n        ts.isFunctionDeclaration(node) ||\n        ts.isFunctionExpression(node) ||\n        ts.isMethodDeclaration(node) ||\n        ts.isAccessor(node) ||\n        ts.isArrowFunction(node)\n      );\n    };\n    if (ts.isBlock(funBody)) {\n      forEachNodeInSubtree(funBody, callback, stopCondition);\n    } else {\n      const tsExpr = TsUtils.unwrapParenthesized(funBody);\n      hasLimitedTypeInference = this.tsUtils.isCallToFunctionWithOmittedReturnType(tsExpr);\n    }\n    return hasLimitedTypeInference;\n  }\n\n  private isValidTypeForUnaryArithmeticOperator(type: ts.Type): boolean {\n    const typeFlags = type.getFlags();\n    const numberLiteralFlags = ts.TypeFlags.BigIntLiteral | ts.TypeFlags.NumberLiteral;\n    const numberLikeFlags = ts.TypeFlags.BigIntLike | ts.TypeFlags.NumberLike;\n    const isNumberLike = !!(typeFlags & (numberLiteralFlags | numberLikeFlags));\n\n    const isAllowedNumericType = this.tsUtils.isStdBigIntType(type) || this.tsUtils.isStdNumberType(type);\n\n    return isNumberLike || isAllowedNumericType;\n  }\n\n  private handlePrefixUnaryExpression(node: ts.Node): void {\n    const tsUnaryArithm = node as ts.PrefixUnaryExpression;\n    const tsUnaryOp = tsUnaryArithm.operator;\n    const tsUnaryOperand = tsUnaryArithm.operand;\n    if (\n      tsUnaryOp === ts.SyntaxKind.PlusToken ||\n      tsUnaryOp === ts.SyntaxKind.MinusToken ||\n      tsUnaryOp === ts.SyntaxKind.TildeToken\n    ) {\n      const tsOperatndType = this.tsTypeChecker.getTypeAtLocation(tsUnaryOperand);\n      const isTilde = tsUnaryOp === ts.SyntaxKind.TildeToken;\n      const isInvalidTilde =\n        isTilde && ts.isNumericLiteral(tsUnaryOperand) && !this.tsUtils.isIntegerConstantValue(tsUnaryOperand);\n      if (!this.isValidTypeForUnaryArithmeticOperator(tsOperatndType) || isInvalidTilde) {\n        this.incrementCounters(node, FaultID.UnaryArithmNotNumber);\n      }\n    }\n  }\n\n  private handleBinaryExpression(node: ts.Node): void {\n    const tsBinaryExpr = node as ts.BinaryExpression;\n    const tsLhsExpr = tsBinaryExpr.left;\n    const tsRhsExpr = tsBinaryExpr.right;\n    if (isAssignmentOperator(tsBinaryExpr.operatorToken)) {\n      this.processBinaryAssignment(node, tsLhsExpr, tsRhsExpr);\n    }\n    const leftOperandType = this.tsTypeChecker.getTypeAtLocation(tsLhsExpr);\n    const rightOperandType = this.tsTypeChecker.getTypeAtLocation(tsRhsExpr);\n    const typeNode = this.tsUtils.getVariableDeclarationTypeNode(tsLhsExpr);\n    switch (tsBinaryExpr.operatorToken.kind) {\n      // FaultID.BitOpWithWrongType - removed as rule #61\n      case ts.SyntaxKind.CommaToken:\n        this.processBinaryComma(tsBinaryExpr);\n        break;\n      case ts.SyntaxKind.InstanceOfKeyword:\n        this.processBinaryInstanceOf(node, tsLhsExpr, leftOperandType);\n        break;\n      case ts.SyntaxKind.InKeyword:\n        this.incrementCounters(tsBinaryExpr.operatorToken, FaultID.InOperator);\n        break;\n      case ts.SyntaxKind.EqualsToken:\n        if (this.tsUtils.needToDeduceStructuralIdentity(leftOperandType, rightOperandType, tsRhsExpr)) {\n          this.incrementCounters(tsBinaryExpr, FaultID.StructuralIdentity);\n        }\n        this.handleEsObjectAssignment(tsBinaryExpr, typeNode, tsRhsExpr);\n        break;\n      default:\n    }\n  }\n\n  private processBinaryAssignment(node: ts.Node, tsLhsExpr: ts.Expression, tsRhsExpr: ts.Expression): void {\n    if (ts.isObjectLiteralExpression(tsLhsExpr)) {\n      this.incrementCounters(node, FaultID.DestructuringAssignment);\n    } else if (ts.isArrayLiteralExpression(tsLhsExpr)) {\n      // Array destructuring is allowed only for Arrays/Tuples and without spread operator.\n      const rhsType = this.tsTypeChecker.getTypeAtLocation(tsRhsExpr);\n      const isArrayOrTuple =\n        this.tsUtils.isOrDerivedFrom(rhsType, this.tsUtils.isArray) ||\n        this.tsUtils.isOrDerivedFrom(rhsType, TsUtils.isTuple);\n      const hasNestedObjectDestructuring = TsUtils.hasNestedObjectDestructuring(tsLhsExpr);\n\n      if (\n        !TypeScriptLinter.useRelaxedRules ||\n        !isArrayOrTuple ||\n        hasNestedObjectDestructuring ||\n        TsUtils.destructuringAssignmentHasSpreadOperator(tsLhsExpr)\n      ) {\n        this.incrementCounters(node, FaultID.DestructuringAssignment);\n      }\n    }\n\n    if (ts.isPropertyAccessExpression(tsLhsExpr)) {\n      const tsLhsSymbol = this.tsUtils.trueSymbolAtLocation(tsLhsExpr);\n      const tsLhsBaseSymbol = this.tsUtils.trueSymbolAtLocation(tsLhsExpr.expression);\n      if (tsLhsSymbol && tsLhsSymbol.flags & ts.SymbolFlags.Method) {\n        this.incrementCounters(tsLhsExpr, FaultID.MethodReassignment);\n      }\n      if (\n        TsUtils.isMethodAssignment(tsLhsSymbol) &&\n        tsLhsBaseSymbol &&\n        (tsLhsBaseSymbol.flags & ts.SymbolFlags.Function) !== 0\n      ) {\n        this.incrementCounters(tsLhsExpr, FaultID.PropertyDeclOnFunction);\n      }\n    }\n  }\n\n  private processBinaryComma(tsBinaryExpr: ts.BinaryExpression): void {\n    // CommaOpertor is allowed in 'for' statement initalizer and incrementor\n    let tsExprNode: ts.Node = tsBinaryExpr;\n    let tsParentNode = tsExprNode.parent;\n    while (tsParentNode && tsParentNode.kind === ts.SyntaxKind.BinaryExpression) {\n      tsExprNode = tsParentNode;\n      tsParentNode = tsExprNode.parent;\n      if ((tsExprNode as ts.BinaryExpression).operatorToken.kind === ts.SyntaxKind.CommaToken) {\n        // Need to return if one comma enclosed in expression with another comma to avoid multiple reports on one line\n        return;\n      }\n    }\n    if (tsParentNode && tsParentNode.kind === ts.SyntaxKind.ForStatement) {\n      const tsForNode = tsParentNode as ts.ForStatement;\n      if (tsExprNode === tsForNode.initializer || tsExprNode === tsForNode.incrementor) {\n        return;\n      }\n    }\n    if (tsParentNode && tsParentNode.kind === ts.SyntaxKind.ExpressionStatement) {\n      const autofix = this.autofixer?.fixCommaOperator(tsExprNode);\n      this.incrementCounters(tsExprNode, FaultID.CommaOperator, autofix);\n      return;\n    }\n\n    this.incrementCounters(tsBinaryExpr as ts.Node, FaultID.CommaOperator);\n  }\n\n  private processBinaryInstanceOf(node: ts.Node, tsLhsExpr: ts.Expression, leftOperandType: ts.Type): void {\n    const leftExpr = TsUtils.unwrapParenthesized(tsLhsExpr);\n    const leftSymbol = this.tsUtils.trueSymbolAtLocation(leftExpr);\n\n    /*\n     * In STS, the left-hand side expression may be of any reference type, otherwise\n     * a compile-time error occurs. In addition, the left operand in STS cannot be a type.\n     */\n    if (tsLhsExpr.kind === ts.SyntaxKind.ThisKeyword) {\n      return;\n    }\n\n    if (TsUtils.isPrimitiveType(leftOperandType) || ts.isTypeNode(leftExpr) || TsUtils.isTypeSymbol(leftSymbol)) {\n      this.incrementCounters(node, FaultID.InstanceofUnsupported);\n    }\n  }\n\n  private handleVariableDeclarationList(node: ts.Node): void {\n    const varDeclFlags = ts.getCombinedNodeFlags(node);\n    if (!(varDeclFlags & (ts.NodeFlags.Let | ts.NodeFlags.Const))) {\n      const autofix = this.autofixer?.fixVarDeclaration(node as ts.VariableDeclarationList);\n      this.incrementCounters(node, FaultID.VarDeclaration, autofix);\n    }\n  }\n\n  private handleVariableDeclaration(node: ts.Node): void {\n    const tsVarDecl = node as ts.VariableDeclaration;\n    if (\n      !this.useRtLogic ||\n      ts.isVariableDeclarationList(tsVarDecl.parent) && ts.isVariableStatement(tsVarDecl.parent.parent)\n    ) {\n      this.handleDeclarationDestructuring(tsVarDecl);\n    }\n\n    // Check variable declaration for duplicate name.\n    this.checkVarDeclForDuplicateNames(tsVarDecl.name);\n\n    if (tsVarDecl.type && tsVarDecl.initializer) {\n      const tsVarInit = tsVarDecl.initializer;\n      const tsVarType = this.tsTypeChecker.getTypeAtLocation(tsVarDecl.type);\n      const tsInitType = this.tsTypeChecker.getTypeAtLocation(tsVarInit);\n      if (this.tsUtils.needToDeduceStructuralIdentity(tsVarType, tsInitType, tsVarInit)) {\n        this.incrementCounters(tsVarDecl, FaultID.StructuralIdentity);\n      }\n    }\n    this.handleEsObjectDelaration(tsVarDecl);\n    this.handleDeclarationInferredType(tsVarDecl);\n    this.handleDefiniteAssignmentAssertion(tsVarDecl);\n  }\n\n  private handleDeclarationDestructuring(decl: ts.VariableDeclaration | ts.ParameterDeclaration): void {\n    const faultId = ts.isVariableDeclaration(decl) ? FaultID.DestructuringDeclaration : FaultID.DestructuringParameter;\n    if (ts.isObjectBindingPattern(decl.name)) {\n      this.incrementCounters(decl, faultId);\n    } else if (ts.isArrayBindingPattern(decl.name)) {\n      if (!TypeScriptLinter.useRelaxedRules) {\n        this.incrementCounters(decl, faultId);\n        return;\n      }\n\n      // Array destructuring is allowed only for Arrays/Tuples and without spread operator.\n      const rhsType = this.tsTypeChecker.getTypeAtLocation(decl.initializer ?? decl.name);\n      const isArrayOrTuple =\n        rhsType &&\n        (this.tsUtils.isOrDerivedFrom(rhsType, this.tsUtils.isArray) ||\n          this.tsUtils.isOrDerivedFrom(rhsType, TsUtils.isTuple));\n      const hasNestedObjectDestructuring = TsUtils.hasNestedObjectDestructuring(decl.name);\n\n      if (\n        !isArrayOrTuple ||\n        hasNestedObjectDestructuring ||\n        TsUtils.destructuringDeclarationHasSpreadOperator(decl.name)\n      ) {\n        this.incrementCounters(decl, faultId);\n      }\n    }\n  }\n\n  private checkVarDeclForDuplicateNames(tsBindingName: ts.BindingName): void {\n    if (ts.isIdentifier(tsBindingName)) {\n      // The syntax kind of the declaration is defined here by the parent of 'BindingName' node.\n      this.countDeclarationsWithDuplicateName(tsBindingName, tsBindingName, tsBindingName.parent.kind);\n      return;\n    }\n    for (const tsBindingElem of tsBindingName.elements) {\n      if (ts.isOmittedExpression(tsBindingElem)) {\n        continue;\n      }\n\n      this.checkVarDeclForDuplicateNames(tsBindingElem.name);\n    }\n  }\n\n  private handleEsObjectDelaration(node: ts.VariableDeclaration): void {\n    const isDeclaredESObject = !!node.type && TsUtils.isEsObjectType(node.type);\n    const initalizerTypeNode = node.initializer && this.tsUtils.getVariableDeclarationTypeNode(node.initializer);\n    const isInitializedWithESObject = !!initalizerTypeNode && TsUtils.isEsObjectType(initalizerTypeNode);\n    const isLocal = TsUtils.isInsideBlock(node);\n    if ((isDeclaredESObject || isInitializedWithESObject) && !isLocal) {\n      this.incrementCounters(node, FaultID.EsObjectType);\n      return;\n    }\n\n    if (node.initializer) {\n      this.handleEsObjectAssignment(node, node.type, node.initializer);\n    }\n  }\n\n  private handleEsObjectAssignment(node: ts.Node, nodeDeclType: ts.TypeNode | undefined, initializer: ts.Node): void {\n    const isTypeAnnotated = !!nodeDeclType;\n    const isDeclaredESObject = isTypeAnnotated && TsUtils.isEsObjectType(nodeDeclType);\n    const initalizerTypeNode = this.tsUtils.getVariableDeclarationTypeNode(initializer);\n    const isInitializedWithESObject = !!initalizerTypeNode && TsUtils.isEsObjectType(initalizerTypeNode);\n    if (isTypeAnnotated && !isDeclaredESObject && isInitializedWithESObject) {\n      this.incrementCounters(node, FaultID.EsObjectType);\n      return;\n    }\n\n    if (isDeclaredESObject && !this.tsUtils.isValueAssignableToESObject(initializer)) {\n      this.incrementCounters(node, FaultID.EsObjectType);\n    }\n  }\n\n  private handleCatchClause(node: ts.Node): void {\n    const tsCatch = node as ts.CatchClause;\n\n    /*\n     * In TS catch clause doesn't permit specification of the exception varible type except 'any' or 'unknown'.\n     * It is not compatible with STS 'catch' where the exception variable has to be of type\n     * Error or derived from it.\n     * So each 'catch' which has explicit type for the exception object goes to problems.\n     */\n    if (tsCatch.variableDeclaration?.type) {\n      const autofix = this.autofixer?.dropTypeOnVarDecl(tsCatch.variableDeclaration);\n      this.incrementCounters(node, FaultID.CatchWithUnsupportedType, autofix);\n    }\n  }\n\n  private handleClassDeclaration(node: ts.Node): void {\n    // early exit via exception if cancellation was requested\n    this.cancellationToken?.throwIfCancellationRequested();\n\n    const tsClassDecl = node as ts.ClassDeclaration;\n    if (tsClassDecl.name) {\n      this.countDeclarationsWithDuplicateName(tsClassDecl.name, tsClassDecl);\n    }\n    this.countClassMembersWithDuplicateName(tsClassDecl);\n\n    const isSendableClass = TsUtils.hasSendableDecorator(tsClassDecl);\n    if (isSendableClass) {\n      TsUtils.getNonSendableDecorators(tsClassDecl)?.forEach((decorator) => {\n        this.incrementCounters(decorator, FaultID.SendableClassDecorator);\n      });\n      tsClassDecl.typeParameters?.forEach((typeParamDecl) => {\n        this.checkSendableTypeParameter(typeParamDecl);\n      });\n    }\n\n    if (tsClassDecl.heritageClauses) {\n      for (const hClause of tsClassDecl.heritageClauses) {\n        if (!hClause) {\n          continue;\n        }\n        this.checkClassDeclarationHeritageClause(hClause, isSendableClass);\n      }\n    }\n\n    // Check captured variables for sendable class\n    if (isSendableClass) {\n      tsClassDecl.members.forEach((classMember) => {\n        this.scanCapturedVarsInSendableScope(classMember, tsClassDecl);\n      });\n    }\n\n    this.processClassStaticBlocks(tsClassDecl);\n  }\n\n  private checkClassDeclarationHeritageClause(hClause: ts.HeritageClause, isSendableClass: boolean): void {\n    for (const tsTypeExpr of hClause.types) {\n\n      /*\n       * Always resolve type from 'tsTypeExpr' node, not from 'tsTypeExpr.expression' node,\n       * as for the latter, type checker will return incorrect type result for classes in\n       * 'extends' clause. Additionally, reduce reference, as mostly type checker returns\n       * the TypeReference type objects for classes and interfaces.\n       */\n      const tsExprType = TsUtils.reduceReference(this.tsTypeChecker.getTypeAtLocation(tsTypeExpr));\n      const isSendableBaseType = this.tsUtils.isSendableClassOrInterface(tsExprType);\n      if (tsExprType.isClass() && hClause.token === ts.SyntaxKind.ImplementsKeyword) {\n        this.incrementCounters(tsTypeExpr, FaultID.ImplementsClass);\n      }\n      if (!isSendableClass) {\n        // Non-Sendable class can not implements sendable interface / extends sendable class\n        if (isSendableBaseType) {\n          this.incrementCounters(tsTypeExpr, FaultID.SendableClassInheritance);\n        }\n        continue;\n      }\n\n      /*\n       * Sendable class can implements any interface / extends only sendable class\n       * Sendable class can not extends sendable class variable(local / import)\n       */\n      if (hClause.token === ts.SyntaxKind.ExtendsKeyword) {\n        if (!isSendableBaseType) {\n          this.incrementCounters(tsTypeExpr, FaultID.SendableClassInheritance);\n          continue;\n        }\n        if (!this.isValidSendableClassExtends(tsTypeExpr)) {\n          this.incrementCounters(tsTypeExpr, FaultID.SendableClassInheritance);\n        }\n      }\n    }\n  }\n\n  private isValidSendableClassExtends(tsTypeExpr: ts.ExpressionWithTypeArguments): boolean {\n    const expr = tsTypeExpr.expression;\n    const sym = this.tsTypeChecker.getSymbolAtLocation(expr);\n    if (sym && (sym.flags & ts.SymbolFlags.Class) === 0) {\n      // handle non-class situation(local / import)\n      if ((sym.flags & ts.SymbolFlags.Alias) !== 0) {\n\n        /*\n         * Sendable class can not extends imported sendable class variable\n         * Sendable class can extends imported sendable class\n         */\n        const realSym = this.tsTypeChecker.getAliasedSymbol(sym);\n        if (realSym && (realSym.flags & ts.SymbolFlags.Class) === 0) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  private checkSendableTypeParameter(typeParamDecl: ts.TypeParameterDeclaration): void {\n    const defaultTypeNode = typeParamDecl.default;\n    if (defaultTypeNode) {\n      if (!this.tsUtils.isSendableTypeNode(defaultTypeNode)) {\n        this.incrementCounters(defaultTypeNode, FaultID.SendableGenericTypes);\n      }\n    }\n  }\n\n  private processClassStaticBlocks(classDecl: ts.ClassDeclaration): void {\n    let staticBlocksCntr = 0;\n    const staticBlockNodes: ts.Node[] = [];\n    for (const element of classDecl.members) {\n      if (ts.isClassStaticBlockDeclaration(element)) {\n        staticBlockNodes[staticBlocksCntr] = element;\n        staticBlocksCntr++;\n      }\n    }\n    if (staticBlocksCntr > 1) {\n      const autofix = this.autofixer?.fixMultipleStaticBlocks(staticBlockNodes);\n      // autofixes for all additional static blocks are the same\n      for (let i = 1; i < staticBlocksCntr; i++) {\n        this.incrementCounters(staticBlockNodes[i], FaultID.MultipleStaticBlocks, autofix);\n      }\n    }\n  }\n\n  private handleModuleDeclaration(node: ts.Node): void {\n    // early exit via exception if cancellation was requested\n    this.cancellationToken?.throwIfCancellationRequested();\n\n    const tsModuleDecl = node as ts.ModuleDeclaration;\n\n    this.countDeclarationsWithDuplicateName(tsModuleDecl.name, tsModuleDecl);\n\n    const tsModuleBody = tsModuleDecl.body;\n    const tsModifiers = ts.getModifiers(tsModuleDecl);\n    if (tsModuleBody) {\n      if (ts.isModuleBlock(tsModuleBody)) {\n        this.handleModuleBlock(tsModuleBody);\n      }\n    }\n\n    if (\n      !(tsModuleDecl.flags & ts.NodeFlags.Namespace) &&\n      TsUtils.hasModifier(tsModifiers, ts.SyntaxKind.DeclareKeyword)\n    ) {\n      this.incrementCounters(tsModuleDecl, FaultID.ShorthandAmbientModuleDecl);\n    }\n\n    if (ts.isStringLiteral(tsModuleDecl.name) && tsModuleDecl.name.text.includes('*')) {\n      this.incrementCounters(tsModuleDecl, FaultID.WildcardsInModuleName);\n    }\n  }\n\n  private handleModuleBlock(moduleBlock: ts.ModuleBlock): void {\n    for (const tsModuleStmt of moduleBlock.statements) {\n      switch (tsModuleStmt.kind) {\n        case ts.SyntaxKind.VariableStatement:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n        case ts.SyntaxKind.EnumDeclaration:\n        case ts.SyntaxKind.ExportDeclaration:\n          break;\n\n        /*\n         * Nested namespace declarations are prohibited\n         * but there is no cookbook recipe for it!\n         */\n        case ts.SyntaxKind.ModuleDeclaration:\n          break;\n        default:\n          this.incrementCounters(tsModuleStmt, FaultID.NonDeclarationInNamespace);\n          break;\n      }\n    }\n  }\n\n  private handleTypeAliasDeclaration(node: ts.Node): void {\n    const tsTypeAlias = node as ts.TypeAliasDeclaration;\n    this.countDeclarationsWithDuplicateName(tsTypeAlias.name, tsTypeAlias);\n  }\n\n  private handleImportClause(node: ts.Node): void {\n    const tsImportClause = node as ts.ImportClause;\n    if (tsImportClause.name) {\n      this.countDeclarationsWithDuplicateName(tsImportClause.name, tsImportClause);\n    }\n  }\n\n  private handleImportSpecifier(node: ts.Node): void {\n    const importSpec = node as ts.ImportSpecifier;\n    this.countDeclarationsWithDuplicateName(importSpec.name, importSpec);\n  }\n\n  private handleNamespaceImport(node: ts.Node): void {\n    const tsNamespaceImport = node as ts.NamespaceImport;\n    this.countDeclarationsWithDuplicateName(tsNamespaceImport.name, tsNamespaceImport);\n  }\n\n  private handleTypeAssertionExpression(node: ts.Node): void {\n    const tsTypeAssertion = node as ts.TypeAssertion;\n    if (tsTypeAssertion.type.getText() === 'const') {\n      this.incrementCounters(tsTypeAssertion, FaultID.ConstAssertion);\n    } else {\n      const autofix = this.autofixer?.fixTypeAssertion(tsTypeAssertion);\n      this.incrementCounters(node, FaultID.TypeAssertion, autofix);\n    }\n  }\n\n  private handleMethodDeclaration(node: ts.Node): void {\n    const tsMethodDecl = node as ts.MethodDeclaration;\n    TsUtils.getDecoratorsIfInSendableClass(tsMethodDecl)?.forEach((decorator) => {\n      this.incrementCounters(decorator, FaultID.SendableClassDecorator);\n    });\n    let isStatic = false;\n    if (tsMethodDecl.modifiers) {\n      for (const mod of tsMethodDecl.modifiers) {\n        if (mod.kind === ts.SyntaxKind.StaticKeyword) {\n          isStatic = true;\n          break;\n        }\n      }\n    }\n    if (tsMethodDecl.body && isStatic) {\n      this.reportThisKeywordsInScope(tsMethodDecl.body);\n    }\n    if (!tsMethodDecl.type) {\n      this.handleMissingReturnType(tsMethodDecl);\n    }\n    if (tsMethodDecl.asteriskToken) {\n      this.incrementCounters(node, FaultID.GeneratorFunction);\n    }\n    this.filterOutDecoratorsDiagnostics(\n      ts.getDecorators(tsMethodDecl),\n      NON_RETURN_FUNCTION_DECORATORS,\n      { begin: tsMethodDecl.parameters.end, end: tsMethodDecl.body?.getStart() ?? tsMethodDecl.parameters.end },\n      FUNCTION_HAS_NO_RETURN_ERROR_CODE\n    );\n  }\n\n  private handleMethodSignature(node: ts.MethodSignature): void {\n    const tsMethodSign = node;\n    if (!tsMethodSign.type) {\n      this.handleMissingReturnType(tsMethodSign);\n    }\n  }\n\n  private handleClassStaticBlockDeclaration(node: ts.Node): void {\n    const classStaticBlockDecl = node as ts.ClassStaticBlockDeclaration;\n    if (!ts.isClassDeclaration(classStaticBlockDecl.parent)) {\n      return;\n    }\n    this.reportThisKeywordsInScope(classStaticBlockDecl.body);\n  }\n\n  private handleIdentifier(node: ts.Node): void {\n    const tsIdentifier = node as ts.Identifier;\n    const tsIdentSym = this.tsUtils.trueSymbolAtLocation(tsIdentifier);\n    if (!tsIdentSym) {\n      return;\n    }\n    if (\n      (tsIdentSym.flags & ts.SymbolFlags.Module) !== 0 &&\n      (tsIdentSym.flags & ts.SymbolFlags.Transient) !== 0 &&\n      tsIdentifier.text === 'globalThis'\n    ) {\n      this.incrementCounters(node, FaultID.GlobalThis);\n    } else {\n      this.handleRestrictedValues(tsIdentifier, tsIdentSym);\n    }\n  }\n\n  // hard-coded alternative to TypeScriptLinter.advancedClassChecks\n  private isAllowedClassValueContext(tsIdentifier: ts.Identifier): boolean {\n    let ctx: ts.Node = tsIdentifier;\n    while (ts.isPropertyAccessExpression(ctx.parent) || ts.isQualifiedName(ctx.parent)) {\n      ctx = ctx.parent;\n    }\n    if (ts.isPropertyAssignment(ctx.parent) && ts.isObjectLiteralExpression(ctx.parent.parent)) {\n      ctx = ctx.parent.parent;\n    }\n    if (ts.isArrowFunction(ctx.parent) && ctx.parent.body === ctx) {\n      ctx = ctx.parent;\n    }\n\n    if (ts.isCallExpression(ctx.parent) || ts.isNewExpression(ctx.parent)) {\n      const callee = ctx.parent.expression;\n      const isAny = TsUtils.isAnyType(this.tsTypeChecker.getTypeAtLocation(callee));\n      const isDynamic = isAny || this.tsUtils.hasLibraryType(callee);\n      if (callee !== ctx && isDynamic) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private handleRestrictedValues(tsIdentifier: ts.Identifier, tsIdentSym: ts.Symbol): void {\n    const illegalValues =\n      ts.SymbolFlags.ConstEnum |\n      ts.SymbolFlags.RegularEnum |\n      ts.SymbolFlags.ValueModule |\n      (TypeScriptLinter.advancedClassChecks ? 0 : ts.SymbolFlags.Class);\n\n    /*\n     * If module name is duplicated by another declaration, this increases the possibility\n     * of finding a lot of false positives. Thus, do not check further in that case.\n     */\n    if ((tsIdentSym.flags & ts.SymbolFlags.ValueModule) !== 0) {\n      if (!!tsIdentSym && TsUtils.symbolHasDuplicateName(tsIdentSym, ts.SyntaxKind.ModuleDeclaration)) {\n        return;\n      }\n    }\n\n    if (\n      (tsIdentSym.flags & illegalValues) === 0 ||\n      isStruct(tsIdentSym) ||\n      !identiferUseInValueContext(tsIdentifier, tsIdentSym)\n    ) {\n      return;\n    }\n\n    if ((tsIdentSym.flags & ts.SymbolFlags.Class) !== 0) {\n      if (!TypeScriptLinter.advancedClassChecks && this.isAllowedClassValueContext(tsIdentifier)) {\n        return;\n      }\n    }\n\n    if (tsIdentSym.flags & ts.SymbolFlags.ValueModule) {\n      this.incrementCounters(tsIdentifier, FaultID.NamespaceAsObject);\n    } else {\n      // missing EnumAsObject\n      this.incrementCounters(tsIdentifier, FaultID.ClassAsObject);\n    }\n  }\n\n  private isElementAcessAllowed(type: ts.Type, argType: ts.Type): boolean {\n    if (type.isUnion()) {\n      for (const t of type.types) {\n        if (!this.isElementAcessAllowed(t, argType)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    const typeNode = this.tsTypeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n\n    if (this.tsUtils.isArkTSCollectionsArrayLikeType(type)) {\n      return this.tsUtils.isNumberLikeType(argType);\n    }\n\n    return (\n      this.tsUtils.isLibraryType(type) ||\n      TsUtils.isAnyType(type) ||\n      this.tsUtils.isOrDerivedFrom(type, this.tsUtils.isArray) ||\n      this.tsUtils.isOrDerivedFrom(type, TsUtils.isTuple) ||\n      this.tsUtils.isOrDerivedFrom(type, this.tsUtils.isStdRecordType) ||\n      this.tsUtils.isOrDerivedFrom(type, this.tsUtils.isStringType) ||\n      this.tsUtils.isOrDerivedFrom(type, this.tsUtils.isStdMapType) ||\n      TsUtils.isIntrinsicObjectType(type) ||\n      TsUtils.isEnumType(type) ||\n      // we allow EsObject here beacuse it is reported later using FaultId.EsObjectType\n      TsUtils.isEsObjectType(typeNode)\n    );\n  }\n\n  private handleElementAccessExpression(node: ts.Node): void {\n    const tsElementAccessExpr = node as ts.ElementAccessExpression;\n    const tsElementAccessExprSymbol = this.tsUtils.trueSymbolAtLocation(tsElementAccessExpr.expression);\n    const tsElemAccessBaseExprType = this.tsUtils.getNonNullableType(\n      this.tsUtils.getTypeOrTypeConstraintAtLocation(tsElementAccessExpr.expression)\n    );\n    const tsElemAccessArgType = this.tsTypeChecker.getTypeAtLocation(tsElementAccessExpr.argumentExpression);\n\n    if (\n      // unnamed types do not have symbol, so need to check that explicitly\n      !this.tsUtils.isLibrarySymbol(tsElementAccessExprSymbol) &&\n      !ts.isArrayLiteralExpression(tsElementAccessExpr.expression) &&\n      !this.isElementAcessAllowed(tsElemAccessBaseExprType, tsElemAccessArgType)\n    ) {\n      const autofix = this.autofixer?.fixPropertyAccessByIndex(tsElementAccessExpr);\n      this.incrementCounters(node, FaultID.PropertyAccessByIndex, autofix);\n    }\n\n    if (this.tsUtils.hasEsObjectType(tsElementAccessExpr.expression)) {\n      this.incrementCounters(node, FaultID.EsObjectType);\n    }\n  }\n\n  private handleEnumMember(node: ts.Node): void {\n    const tsEnumMember = node as ts.EnumMember;\n    const tsEnumMemberType = this.tsTypeChecker.getTypeAtLocation(tsEnumMember);\n    const constVal = this.tsTypeChecker.getConstantValue(tsEnumMember);\n    if (tsEnumMember.initializer && !this.tsUtils.isValidEnumMemberInit(tsEnumMember.initializer)) {\n      this.incrementCounters(node, FaultID.EnumMemberNonConstInit);\n    }\n    // check for type - all members should be of same type\n    const enumDecl = tsEnumMember.parent;\n    const firstEnumMember = enumDecl.members[0];\n    const firstEnumMemberType = this.tsTypeChecker.getTypeAtLocation(firstEnumMember);\n    const firstElewmVal = this.tsTypeChecker.getConstantValue(firstEnumMember);\n\n    /*\n     * each string enum member has its own type\n     * so check that value type is string\n     */\n    if (\n      constVal !== undefined &&\n      typeof constVal === 'string' &&\n      firstElewmVal !== undefined &&\n      typeof firstElewmVal === 'string'\n    ) {\n      return;\n    }\n    if (\n      constVal !== undefined &&\n      typeof constVal === 'number' &&\n      firstElewmVal !== undefined &&\n      typeof firstElewmVal === 'number'\n    ) {\n      return;\n    }\n    if (firstEnumMemberType !== tsEnumMemberType) {\n      this.incrementCounters(node, FaultID.EnumMemberNonConstInit);\n    }\n  }\n\n  private handleExportAssignment(node: ts.Node): void {\n    const exportAssignment = node as ts.ExportAssignment;\n    if (exportAssignment.isExportEquals) {\n      this.incrementCounters(node, FaultID.ExportAssignment);\n    }\n\n    if (!TypeScriptLinter.inSharedModule(node)) {\n      return;\n    }\n\n    if (!this.tsUtils.isShareableEntity(exportAssignment.expression)) {\n      this.incrementCounters(exportAssignment.expression, FaultID.SharedModuleExports);\n    }\n  }\n\n  private handleCallExpression(node: ts.Node): void {\n    const tsCallExpr = node as ts.CallExpression;\n\n    const calleeSym = this.tsUtils.trueSymbolAtLocation(tsCallExpr.expression);\n    const callSignature = this.tsTypeChecker.getResolvedSignature(tsCallExpr);\n\n    this.handleImportCall(tsCallExpr);\n    this.handleRequireCall(tsCallExpr);\n    if (calleeSym !== undefined) {\n      this.handleStdlibAPICall(tsCallExpr, calleeSym);\n      this.handleFunctionApplyBindPropCall(tsCallExpr, calleeSym);\n      if (TsUtils.symbolHasEsObjectType(calleeSym)) {\n        this.incrementCounters(tsCallExpr, FaultID.EsObjectType);\n      }\n    }\n    if (callSignature !== undefined && !this.tsUtils.isLibrarySymbol(calleeSym)) {\n      this.handleGenericCallWithNoTypeArgs(tsCallExpr, callSignature);\n      this.handleStructIdentAndUndefinedInArgs(tsCallExpr, callSignature);\n    }\n    this.handleLibraryTypeCall(tsCallExpr);\n\n    if (\n      ts.isPropertyAccessExpression(tsCallExpr.expression) &&\n      this.tsUtils.hasEsObjectType(tsCallExpr.expression.expression)\n    ) {\n      this.incrementCounters(node, FaultID.EsObjectType);\n    }\n  }\n\n  private handleEtsComponentExpression(node: ts.Node): void {\n    // for all the checks we make EtsComponentExpression is compatible with the CallExpression\n    const etsComponentExpression = node as ts.CallExpression;\n    this.handleLibraryTypeCall(etsComponentExpression);\n  }\n\n  private handleImportCall(tsCallExpr: ts.CallExpression): void {\n    if (tsCallExpr.expression.kind === ts.SyntaxKind.ImportKeyword) {\n      // relax rule#133 \"arkts-no-runtime-import\"\n      const tsArgs = tsCallExpr.arguments;\n      if (tsArgs.length > 1 && ts.isObjectLiteralExpression(tsArgs[1])) {\n        for (const tsProp of tsArgs[1].properties) {\n          if (\n            (ts.isPropertyAssignment(tsProp) || ts.isShorthandPropertyAssignment(tsProp)) &&\n            tsProp.name.getText() === 'assert'\n          ) {\n            this.incrementCounters(tsProp, FaultID.ImportAssertion);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  private handleRequireCall(tsCallExpr: ts.CallExpression): void {\n    if (\n      ts.isIdentifier(tsCallExpr.expression) &&\n      tsCallExpr.expression.text === 'require' &&\n      ts.isVariableDeclaration(tsCallExpr.parent)\n    ) {\n      const tsType = this.tsTypeChecker.getTypeAtLocation(tsCallExpr.expression);\n      if (TsUtils.isInterfaceType(tsType) && tsType.symbol.name === 'NodeRequire') {\n        this.incrementCounters(tsCallExpr.parent, FaultID.ImportAssignment);\n      }\n    }\n  }\n\n  private handleGenericCallWithNoTypeArgs(\n    callLikeExpr: ts.CallExpression | ts.NewExpression,\n    callSignature: ts.Signature\n  ): void {\n\n    /*\n     * Note: The PR!716 has led to a significant performance degradation.\n     * Since initial problem was fixed in a more general way, this change\n     * became redundant. Therefore, it was reverted. See #13721 comments\n     * for a detailed analysis.\n     */\n    const tsSyntaxKind = ts.isNewExpression(callLikeExpr) ?\n      ts.SyntaxKind.Constructor :\n      ts.SyntaxKind.FunctionDeclaration;\n    const signFlags = ts.NodeBuilderFlags.WriteTypeArgumentsOfSignature | ts.NodeBuilderFlags.IgnoreErrors;\n\n    const signDecl = this.tsTypeChecker.signatureToSignatureDeclaration(\n      callSignature,\n      tsSyntaxKind,\n      undefined,\n      signFlags\n    );\n    if (!signDecl?.typeArguments) {\n      return;\n    }\n    const resolvedTypeArgs = signDecl.typeArguments;\n    const startTypeArg = callLikeExpr.typeArguments?.length ?? 0;\n    for (let i = startTypeArg; i < resolvedTypeArgs.length; ++i) {\n      const typeNode = resolvedTypeArgs[i];\n\n      /*\n       * if compiler infers 'unknown' type there are 2 possible cases:\n       *   1. Compiler unable to infer type from arguments and use 'unknown'\n       *   2. Compiler infer 'unknown' from arguments\n       * We report error in both cases. It is ok because we cannot use 'unknown'\n       * in ArkTS and already have separate check for it.\n       */\n      if (typeNode.kind === ts.SyntaxKind.UnknownKeyword) {\n        this.incrementCounters(callLikeExpr, FaultID.GenericCallNoTypeArgs);\n        break;\n      }\n    }\n  }\n\n  private static readonly listFunctionApplyCallApis = [\n    'Function.apply',\n    'Function.call',\n    'CallableFunction.apply',\n    'CallableFunction.call'\n  ];\n\n  private static readonly listFunctionBindApis = ['Function.bind', 'CallableFunction.bind'];\n\n  private handleFunctionApplyBindPropCall(tsCallExpr: ts.CallExpression, calleeSym: ts.Symbol): void {\n    const exprName = this.tsTypeChecker.getFullyQualifiedName(calleeSym);\n    if (TypeScriptLinter.listFunctionApplyCallApis.includes(exprName)) {\n      this.incrementCounters(tsCallExpr, FaultID.FunctionApplyCall);\n    }\n    if (TypeScriptLinter.listFunctionBindApis.includes(exprName)) {\n      this.incrementCounters(tsCallExpr, FaultID.FunctionBind);\n    }\n  }\n\n  private handleStructIdentAndUndefinedInArgs(\n    tsCallOrNewExpr: ts.CallExpression | ts.NewExpression,\n    callSignature: ts.Signature\n  ): void {\n    if (!tsCallOrNewExpr.arguments) {\n      return;\n    }\n    for (let argIndex = 0; argIndex < tsCallOrNewExpr.arguments.length; ++argIndex) {\n      const tsArg = tsCallOrNewExpr.arguments[argIndex];\n      const tsArgType = this.tsTypeChecker.getTypeAtLocation(tsArg);\n      if (!tsArgType) {\n        continue;\n      }\n      const paramIndex = argIndex < callSignature.parameters.length ? argIndex : callSignature.parameters.length - 1;\n      const tsParamSym = callSignature.parameters[paramIndex];\n      if (!tsParamSym) {\n        continue;\n      }\n      const tsParamDecl = tsParamSym.valueDeclaration;\n      if (tsParamDecl && ts.isParameter(tsParamDecl)) {\n        let tsParamType = this.tsTypeChecker.getTypeOfSymbolAtLocation(tsParamSym, tsParamDecl);\n        if (tsParamDecl.dotDotDotToken && TsUtils.isGenericArrayType(tsParamType) && tsParamType.typeArguments) {\n          tsParamType = tsParamType.typeArguments[0];\n        }\n        if (!tsParamType) {\n          continue;\n        }\n        if (this.tsUtils.needToDeduceStructuralIdentity(tsParamType, tsArgType, tsArg)) {\n          this.incrementCounters(tsArg, FaultID.StructuralIdentity);\n        }\n      }\n    }\n  }\n\n  private static readonly LimitedApis = new Map<string, { arr: Array<string> | null; fault: FaultID }>([\n    ['global', { arr: LIMITED_STD_GLOBAL_FUNC, fault: FaultID.LimitedStdLibApi }],\n    ['Object', { arr: LIMITED_STD_OBJECT_API, fault: FaultID.LimitedStdLibApi }],\n    ['ObjectConstructor', { arr: LIMITED_STD_OBJECT_API, fault: FaultID.LimitedStdLibApi }],\n    ['Reflect', { arr: LIMITED_STD_REFLECT_API, fault: FaultID.LimitedStdLibApi }],\n    ['ProxyHandler', { arr: LIMITED_STD_PROXYHANDLER_API, fault: FaultID.LimitedStdLibApi }],\n    [SYMBOL, { arr: null, fault: FaultID.SymbolType }],\n    [SYMBOL_CONSTRUCTOR, { arr: null, fault: FaultID.SymbolType }]\n  ]);\n\n  private handleStdlibAPICall(callExpr: ts.CallExpression, calleeSym: ts.Symbol): void {\n    const name = calleeSym.getName();\n    const parName = this.tsUtils.getParentSymbolName(calleeSym);\n    if (parName === undefined) {\n      if (LIMITED_STD_GLOBAL_FUNC.includes(name)) {\n        this.incrementCounters(callExpr, FaultID.LimitedStdLibApi);\n        return;\n      }\n      const escapedName = calleeSym.escapedName;\n      if (escapedName === 'Symbol' || escapedName === 'SymbolConstructor') {\n        this.incrementCounters(callExpr, FaultID.SymbolType);\n      }\n      return;\n    }\n    const lookup = TypeScriptLinter.LimitedApis.get(parName);\n    if (\n      lookup !== undefined &&\n      (lookup.arr === null || lookup.arr.includes(name)) &&\n      (!TypeScriptLinter.useRelaxedRules ||\n        !this.supportedStdCallApiChecker.isSupportedStdCallAPI(callExpr, parName, name))\n    ) {\n      this.incrementCounters(callExpr, lookup.fault);\n    }\n  }\n\n  private static findNonFilteringRangesFunctionCalls(callExpr: ts.CallExpression): { begin: number; end: number }[] {\n    const args = callExpr.arguments;\n    const result: { begin: number; end: number }[] = [];\n    for (const arg of args) {\n      if (ts.isArrowFunction(arg)) {\n        const arrowFuncExpr = arg;\n        result.push({ begin: arrowFuncExpr.body.pos, end: arrowFuncExpr.body.end });\n      } else if (ts.isCallExpression(arg)) {\n        result.push({ begin: arg.arguments.pos, end: arg.arguments.end });\n      }\n      // there may be other cases\n    }\n    return result;\n  }\n\n  private handleLibraryTypeCall(callExpr: ts.CallExpression): void {\n    const calleeType = this.tsTypeChecker.getTypeAtLocation(callExpr.expression);\n    const inLibCall = this.tsUtils.isLibraryType(calleeType);\n    const diagnosticMessages: Array<ts.DiagnosticMessageChain> = [];\n\n    this.libraryTypeCallDiagnosticChecker.configure(inLibCall, diagnosticMessages);\n\n    const nonFilteringRanges = TypeScriptLinter.findNonFilteringRangesFunctionCalls(callExpr);\n    const rangesToFilter: { begin: number; end: number }[] = [];\n    if (nonFilteringRanges.length !== 0) {\n      const rangesSize = nonFilteringRanges.length;\n      rangesToFilter.push({ begin: callExpr.arguments.pos, end: nonFilteringRanges[0].begin });\n      rangesToFilter.push({ begin: nonFilteringRanges[rangesSize - 1].end, end: callExpr.arguments.end });\n      for (let i = 0; i < rangesSize - 1; i++) {\n        rangesToFilter.push({ begin: nonFilteringRanges[i].end, end: nonFilteringRanges[i + 1].begin });\n      }\n    } else {\n      rangesToFilter.push({ begin: callExpr.arguments.pos, end: callExpr.arguments.end });\n    }\n\n    const hasFiltered = this.filterStrictDiagnostics(\n      {\n        [ARGUMENT_OF_TYPE_0_IS_NOT_ASSIGNABLE_TO_PARAMETER_OF_TYPE_1_ERROR_CODE]: (pos: number) => {\n          return TypeScriptLinter.checkInRange(rangesToFilter, pos);\n        },\n        [NO_OVERLOAD_MATCHES_THIS_CALL_ERROR_CODE]: (pos: number) => {\n          return TypeScriptLinter.checkInRange(rangesToFilter, pos);\n        },\n        [TYPE_0_IS_NOT_ASSIGNABLE_TO_TYPE_1_ERROR_CODE]: (pos: number) => {\n          return TypeScriptLinter.checkInRange(rangesToFilter, pos);\n        }\n      },\n      this.libraryTypeCallDiagnosticChecker\n    );\n    if (hasFiltered) {\n      this.filterOutDiagnostics(\n        { begin: callExpr.getStart(), end: callExpr.getEnd() },\n        OBJECT_IS_POSSIBLY_UNDEFINED_ERROR_CODE\n      );\n    }\n\n    for (const msgChain of diagnosticMessages) {\n      TypeScriptLinter.filteredDiagnosticMessages.add(msgChain);\n    }\n  }\n\n  private handleNewExpression(node: ts.Node): void {\n    const tsNewExpr = node as ts.NewExpression;\n\n    if (TypeScriptLinter.advancedClassChecks) {\n      const calleeExpr = tsNewExpr.expression;\n      const calleeType = this.tsTypeChecker.getTypeAtLocation(calleeExpr);\n      if (\n        !this.tsUtils.isClassTypeExrepssion(calleeExpr) &&\n        !isStdLibraryType(calleeType) &&\n        !this.tsUtils.isLibraryType(calleeType) &&\n        !this.tsUtils.hasEsObjectType(calleeExpr)\n      ) {\n        // missing exact rule\n        this.incrementCounters(calleeExpr, FaultID.ClassAsObject);\n      }\n    }\n    const callSignature = this.tsTypeChecker.getResolvedSignature(tsNewExpr);\n    if (callSignature !== undefined) {\n      this.handleStructIdentAndUndefinedInArgs(tsNewExpr, callSignature);\n      this.handleGenericCallWithNoTypeArgs(tsNewExpr, callSignature);\n    }\n    this.handleSendableGenericTypes(tsNewExpr);\n  }\n\n  private handleSendableGenericTypes(node: ts.NewExpression): void {\n    const type = this.tsTypeChecker.getTypeAtLocation(node);\n    if (!this.tsUtils.isSendableClassOrInterface(type)) {\n      return;\n    }\n\n    const typeArgs = node.typeArguments;\n    if (!typeArgs || typeArgs.length === 0) {\n      return;\n    }\n\n    for (const arg of typeArgs) {\n      if (!this.tsUtils.isSendableTypeNode(arg)) {\n        this.incrementCounters(arg, FaultID.SendableGenericTypes);\n      }\n    }\n  }\n\n  private handleAsExpression(node: ts.Node): void {\n    const tsAsExpr = node as ts.AsExpression;\n    if (tsAsExpr.type.getText() === 'const') {\n      this.incrementCounters(node, FaultID.ConstAssertion);\n    }\n    const targetType = this.tsTypeChecker.getTypeAtLocation(tsAsExpr.type).getNonNullableType();\n    const exprType = this.tsTypeChecker.getTypeAtLocation(tsAsExpr.expression).getNonNullableType();\n    // check for rule#65:   'number as Number' and 'boolean as Boolean' are disabled\n    if (\n      this.tsUtils.isNumberLikeType(exprType) && this.tsUtils.isStdNumberType(targetType) ||\n      TsUtils.isBooleanLikeType(exprType) && this.tsUtils.isStdBooleanType(targetType)\n    ) {\n      this.incrementCounters(node, FaultID.TypeAssertion);\n    }\n    if (\n      !this.tsUtils.isSendableClassOrInterface(exprType) &&\n      !this.tsUtils.isObject(exprType) &&\n      !TsUtils.isAnyType(exprType) &&\n      this.tsUtils.isSendableClassOrInterface(targetType)\n    ) {\n      this.incrementCounters(tsAsExpr, FaultID.SendableAsExpr);\n    }\n  }\n\n  private handleTypeReference(node: ts.Node): void {\n    const typeRef = node as ts.TypeReferenceNode;\n\n    const isESObject = TsUtils.isEsObjectType(typeRef);\n    const isPossiblyValidContext = TsUtils.isEsObjectPossiblyAllowed(typeRef);\n    if (isESObject && !isPossiblyValidContext) {\n      this.incrementCounters(node, FaultID.EsObjectType);\n      return;\n    }\n\n    const typeName = this.tsUtils.entityNameToString(typeRef.typeName);\n    const isStdUtilityType = LIMITED_STANDARD_UTILITY_TYPES.includes(typeName);\n    if (isStdUtilityType) {\n      this.incrementCounters(node, FaultID.UtilityType);\n      return;\n    }\n\n    this.checkPartialType(node);\n\n    if (this.tsUtils.isClassNodeReference(typeRef.typeName) && this.tsUtils.isSendableTypeNode(typeRef)) {\n      this.checkSendableTypeArguments(typeRef);\n    }\n  }\n\n  private checkPartialType(node: ts.Node): void {\n    const typeRef = node as ts.TypeReferenceNode;\n    // Using Partial<T> type is allowed only when its argument type is either Class or Interface.\n    const isStdPartial = this.tsUtils.entityNameToString(typeRef.typeName) === 'Partial';\n    if (!isStdPartial) {\n      return;\n    }\n\n    const hasSingleTypeArgument = !!typeRef.typeArguments && typeRef.typeArguments.length === 1;\n    let argType;\n    if (!this.useRtLogic) {\n      const firstTypeArg = !!typeRef.typeArguments && hasSingleTypeArgument && typeRef.typeArguments[0];\n      argType = firstTypeArg && this.tsTypeChecker.getTypeFromTypeNode(firstTypeArg);\n    } else {\n      argType = hasSingleTypeArgument && this.tsTypeChecker.getTypeFromTypeNode(typeRef.typeArguments[0]);\n    }\n\n    if (argType && !argType.isClassOrInterface()) {\n      this.incrementCounters(node, FaultID.UtilityType);\n    }\n  }\n\n  private checkSendableTypeArguments(typeRef: ts.TypeReferenceNode): void {\n    if (typeRef.typeArguments) {\n      for (const typeArg of typeRef.typeArguments) {\n        if (!this.tsUtils.isSendableTypeNode(typeArg)) {\n          this.incrementCounters(typeArg, FaultID.SendableGenericTypes);\n        }\n      }\n    }\n  }\n\n  private handleMetaProperty(node: ts.Node): void {\n    const tsMetaProperty = node as ts.MetaProperty;\n    if (tsMetaProperty.name.text === 'target') {\n      this.incrementCounters(node, FaultID.NewTarget);\n    }\n  }\n\n  private handleSpreadOp(node: ts.Node): void {\n\n    /*\n     * spread assignment is disabled\n     * spread element is allowed only for arrays as rest parameter\n     */\n    if (ts.isSpreadElement(node)) {\n      const spreadExprType = this.tsUtils.getTypeOrTypeConstraintAtLocation(node.expression);\n      if (\n        spreadExprType &&\n        (this.useRtLogic || ts.isCallLikeExpression(node.parent) || ts.isArrayLiteralExpression(node.parent)) &&\n        this.tsUtils.isOrDerivedFrom(spreadExprType, this.tsUtils.isArray)\n      ) {\n        return;\n      }\n    }\n    this.incrementCounters(node, FaultID.SpreadOperator);\n  }\n\n  private handleConstructSignature(node: ts.Node): void {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.TypeLiteral:\n        this.incrementCounters(node, FaultID.ConstructorType);\n        break;\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this.incrementCounters(node, FaultID.ConstructorIface);\n        break;\n      default:\n    }\n  }\n\n  private handleExpressionWithTypeArguments(node: ts.Node): void {\n    const tsTypeExpr = node as ts.ExpressionWithTypeArguments;\n    const symbol = this.tsUtils.trueSymbolAtLocation(tsTypeExpr.expression);\n    if (!!symbol && TsUtils.isEsObjectSymbol(symbol)) {\n      this.incrementCounters(tsTypeExpr, FaultID.EsObjectType);\n    }\n  }\n\n  private handleComputedPropertyName(node: ts.Node): void {\n    const computedProperty = node as ts.ComputedPropertyName;\n    if (this.isSendableInvalidCompPropName(computedProperty)) {\n      this.incrementCounters(node, FaultID.SendableComputedPropName);\n    } else if (!this.tsUtils.isValidComputedPropertyName(computedProperty, false)) {\n      this.incrementCounters(node, FaultID.ComputedPropertyName);\n    }\n  }\n\n  private isSendableInvalidCompPropName(compProp: ts.ComputedPropertyName): boolean {\n    const declNode = compProp.parent?.parent;\n    if (declNode && ts.isClassDeclaration(declNode) && TsUtils.hasSendableDecorator(declNode)) {\n      return true;\n    } else if (declNode && ts.isInterfaceDeclaration(declNode)) {\n      const declNodeType = this.tsTypeChecker.getTypeAtLocation(declNode);\n      if (this.tsUtils.isSendableClassOrInterface(declNodeType)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private handleGetAccessor(node: ts.GetAccessorDeclaration): void {\n    TsUtils.getDecoratorsIfInSendableClass(node)?.forEach((decorator) => {\n      this.incrementCounters(decorator, FaultID.SendableClassDecorator);\n    });\n  }\n\n  private handleSetAccessor(node: ts.SetAccessorDeclaration): void {\n    TsUtils.getDecoratorsIfInSendableClass(node)?.forEach((decorator) => {\n      this.incrementCounters(decorator, FaultID.SendableClassDecorator);\n    });\n  }\n\n  /*\n   * issue 13987:\n   * When variable have no type annotation and no initial value, and 'noImplicitAny'\n   * option is enabled, compiler attempts to infer type from variable references:\n   * see https://github.com/microsoft/TypeScript/pull/11263.\n   * In this case, we still want to report the error, since ArkTS doesn't allow\n   * to omit both type annotation and initializer.\n   */\n  private proceedVarPropDeclaration(\n    decl: ts.VariableDeclaration | ts.PropertyDeclaration | ts.ParameterDeclaration\n  ): boolean | undefined {\n    if (\n      (ts.isVariableDeclaration(decl) && ts.isVariableStatement(decl.parent.parent) ||\n        ts.isPropertyDeclaration(decl)) &&\n      !decl.initializer\n    ) {\n      if (\n        ts.isPropertyDeclaration(decl) &&\n        this.tsUtils.skipPropertyInferredTypeCheck(decl, this.sourceFile, this.isEtsFileCb)\n      ) {\n        return true;\n      }\n\n      this.incrementCounters(decl, FaultID.AnyType);\n      return true;\n    }\n    return undefined;\n  }\n\n  private handleDeclarationInferredType(\n    decl: ts.VariableDeclaration | ts.PropertyDeclaration | ts.ParameterDeclaration\n  ): void {\n    // The type is explicitly specified, no need to check inferred type.\n    if (decl.type) {\n      return;\n    }\n\n    /*\n     * issue 13161:\n     * In TypeScript, the catch clause variable must be 'any' or 'unknown' type. Since\n     * ArkTS doesn't support these types, the type for such variable is simply omitted,\n     * and we don't report it as an error. See TypeScriptLinter.handleCatchClause()\n     * for reference.\n     */\n    if (ts.isCatchClause(decl.parent)) {\n      return;\n    }\n    // Destructuring declarations are not supported, do not process them.\n    if (ts.isArrayBindingPattern(decl.name) || ts.isObjectBindingPattern(decl.name)) {\n      return;\n    }\n\n    if (this.proceedVarPropDeclaration(decl)) {\n      return;\n    }\n\n    const type = this.tsTypeChecker.getTypeAtLocation(decl);\n    if (type) {\n      this.validateDeclInferredType(type, decl);\n    }\n  }\n\n  private handleDefiniteAssignmentAssertion(decl: ts.VariableDeclaration | ts.PropertyDeclaration): void {\n    if (decl.exclamationToken === undefined) {\n      return;\n    }\n\n    if (decl.kind === ts.SyntaxKind.PropertyDeclaration) {\n      const parentDecl = decl.parent;\n      if (parentDecl.kind === ts.SyntaxKind.ClassDeclaration && TsUtils.hasSendableDecorator(parentDecl)) {\n        this.incrementCounters(decl, FaultID.SendableDefiniteAssignment);\n        return;\n      }\n    }\n    this.incrementCounters(decl, FaultID.DefiniteAssignment);\n  }\n\n  private readonly validatedTypesSet = new Set<ts.Type>();\n\n  private checkAnyOrUnknownChildNode(node: ts.Node): boolean {\n    if (node.kind === ts.SyntaxKind.AnyKeyword || node.kind === ts.SyntaxKind.UnknownKeyword) {\n      return true;\n    }\n    for (const child of node.getChildren()) {\n      if (this.checkAnyOrUnknownChildNode(child)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private handleInferredObjectreference(\n    type: ts.Type,\n    decl: ts.VariableDeclaration | ts.PropertyDeclaration | ts.ParameterDeclaration\n  ): void {\n    const typeArgs = this.tsTypeChecker.getTypeArguments(type as ts.TypeReference);\n    if (typeArgs) {\n      const haveAnyOrUnknownNodes = this.checkAnyOrUnknownChildNode(decl);\n      if (!haveAnyOrUnknownNodes) {\n        for (const typeArg of typeArgs) {\n          this.validateDeclInferredType(typeArg, decl);\n        }\n      }\n    }\n  }\n\n  private validateDeclInferredType(\n    type: ts.Type,\n    decl: ts.VariableDeclaration | ts.PropertyDeclaration | ts.ParameterDeclaration\n  ): void {\n    if (type.aliasSymbol !== undefined) {\n      return;\n    }\n    if (TsUtils.isObjectType(type) && !!(type.objectFlags & ts.ObjectFlags.Reference)) {\n      this.handleInferredObjectreference(type, decl);\n      return;\n    }\n    if (this.validatedTypesSet.has(type)) {\n      return;\n    }\n    if (type.isUnion()) {\n      this.validatedTypesSet.add(type);\n      for (const unionElem of type.types) {\n        this.validateDeclInferredType(unionElem, decl);\n      }\n    }\n    if (TsUtils.isAnyType(type)) {\n      this.incrementCounters(decl, FaultID.AnyType);\n    } else if (TsUtils.isUnknownType(type)) {\n      this.incrementCounters(decl, FaultID.UnknownType);\n    }\n  }\n\n  private handleCommentDirectives(sourceFile: ts.SourceFile): void {\n\n    /*\n     * We use a dirty hack to retrieve list of parsed comment directives by accessing\n     * internal properties of SourceFile node.\n     */\n\n    // Handle comment directive '@ts-nocheck'\n    const pragmas = (sourceFile as any).pragmas;\n    if (pragmas && pragmas instanceof Map) {\n      const noCheckPragma = pragmas.get('ts-nocheck');\n      if (noCheckPragma) {\n\n        /*\n         * The value is either a single entry or an array of entries.\n         * Wrap up single entry with array to simplify processing.\n         */\n        const noCheckEntries: any[] = Array.isArray(noCheckPragma) ? noCheckPragma : [noCheckPragma];\n        for (const entry of noCheckEntries) {\n          this.processNoCheckEntry(entry);\n        }\n      }\n    }\n\n    // Handle comment directives '@ts-ignore' and '@ts-expect-error'\n    const commentDirectives = (sourceFile as any).commentDirectives;\n    if (commentDirectives && Array.isArray(commentDirectives)) {\n      for (const directive of commentDirectives) {\n        if (directive.range?.pos === undefined || directive.range?.end === undefined) {\n          continue;\n        }\n\n        const range = directive.range as ts.TextRange;\n        const kind: ts.SyntaxKind =\n          sourceFile.text.slice(range.pos, range.pos + 2) === '/*' ?\n            ts.SyntaxKind.MultiLineCommentTrivia :\n            ts.SyntaxKind.SingleLineCommentTrivia;\n        const commentRange: ts.CommentRange = {\n          pos: range.pos,\n          end: range.end,\n          kind\n        };\n\n        this.incrementCounters(commentRange, FaultID.ErrorSuppression);\n      }\n    }\n  }\n\n  private processNoCheckEntry(entry: any): void {\n    if (entry.range?.kind === undefined || entry.range?.pos === undefined || entry.range?.end === undefined) {\n      return;\n    }\n\n    this.incrementCounters(entry.range as ts.CommentRange, FaultID.ErrorSuppression);\n  }\n\n  private reportThisKeywordsInScope(scope: ts.Block | ts.Expression): void {\n    const callback = (node: ts.Node): void => {\n      if (node.kind === ts.SyntaxKind.ThisKeyword) {\n        this.incrementCounters(node, FaultID.FunctionContainsThis);\n      }\n    };\n    const stopCondition = (node: ts.Node): boolean => {\n      const isClassLike = ts.isClassDeclaration(node) || ts.isClassExpression(node);\n      const isFunctionLike = ts.isFunctionDeclaration(node) || ts.isFunctionExpression(node);\n      const isModuleDecl = ts.isModuleDeclaration(node);\n      return isClassLike || isFunctionLike || isModuleDecl;\n    };\n    forEachNodeInSubtree(scope, callback, stopCondition);\n  }\n\n  private handleConstructorDeclaration(node: ts.Node): void {\n    const ctorDecl = node as ts.ConstructorDeclaration;\n    if (\n      ctorDecl.parameters.some((x) => {\n        return this.tsUtils.hasAccessModifier(x);\n      })\n    ) {\n      let paramTypes: ts.TypeNode[] | undefined;\n      if (ctorDecl.body) {\n        paramTypes = this.collectCtorParamTypes(ctorDecl);\n      }\n\n      const autofix = this.autofixer?.fixCtorParameterProperties(ctorDecl, paramTypes);\n      this.incrementCounters(node, FaultID.ParameterProperties, autofix);\n    }\n  }\n\n  private collectCtorParamTypes(ctorDecl: ts.ConstructorDeclaration): ts.TypeNode[] | undefined {\n    const paramTypes: ts.TypeNode[] = [];\n\n    for (const param of ctorDecl.parameters) {\n      let paramTypeNode = param.type;\n      if (!paramTypeNode) {\n        const paramType = this.tsTypeChecker.getTypeAtLocation(param);\n        paramTypeNode = this.tsTypeChecker.typeToTypeNode(paramType, param, ts.NodeBuilderFlags.None);\n      }\n      if (!paramTypeNode || !this.tsUtils.isSupportedType(paramTypeNode)) {\n        return undefined;\n      }\n      paramTypes.push(paramTypeNode);\n    }\n\n    return paramTypes;\n  }\n\n  private handlePrivateIdentifier(node: ts.Node): void {\n    const ident = node as ts.PrivateIdentifier;\n    const autofix = this.autofixer?.fixPrivateIdentifier(ident);\n    this.incrementCounters(node, FaultID.PrivateIdentifier, autofix);\n  }\n\n  private handleIndexSignature(node: ts.Node): void {\n    if (!this.tsUtils.isAllowedIndexSignature(node as ts.IndexSignatureDeclaration)) {\n      this.incrementCounters(node, FaultID.IndexMember);\n    }\n  }\n\n  private handleTypeLiteral(node: ts.Node): void {\n    const typeLiteral = node as ts.TypeLiteralNode;\n    const autofix = this.autofixer?.fixTypeliteral(typeLiteral);\n    this.incrementCounters(node, FaultID.ObjectTypeLiteral, autofix);\n  }\n\n  private scanCapturedVarsInSendableScope(startNode: ts.Node, scope: ts.Node): void {\n    const callback = (node: ts.Node): void => {\n      // Namespace import will introduce closure in the es2abc compiler stage\n      if (!ts.isIdentifier(node) || this.checkNamespaceImportVar(node)) {\n        return;\n      }\n\n      // The \"b\" of \"A.b\" should not be checked since it's load from object \"A\"\n      const parent: ts.Node = node.parent;\n      if (ts.isPropertyAccessExpression(parent) && parent.name === node) {\n        return;\n      }\n\n      this.checkLocalDecl(node, scope);\n    };\n    // Type nodes should not checked because no closure will be introduced\n    const stopCondition = (node: ts.Node): boolean => {\n      return ts.isTypeReferenceNode(node);\n    };\n    forEachNodeInSubtree(startNode, callback, stopCondition);\n  }\n\n  private checkLocalDecl(node: ts.Identifier, scope: ts.Node): void {\n    const trueSym = this.tsUtils.trueSymbolAtLocation(node);\n    // Sendable decorator should be used in method of Sendable classes\n    if (trueSym === undefined) {\n      return;\n    }\n\n    // Const enum member will be replaced by the exact value of it, no closure will be introduced\n    if (TsUtils.isConstEnum(trueSym)) {\n      return;\n    }\n\n    const declarations = trueSym.getDeclarations();\n    if (declarations?.length) {\n      this.checkLocalDeclWithSendableClosure(node, scope, declarations[0]);\n    }\n  }\n\n  private checkLocalDeclWithSendableClosure(node: ts.Identifier, scope: ts.Node, decl: ts.Declaration): void {\n    const declPosition = decl.getStart();\n    if (\n      decl.getSourceFile().fileName !== node.getSourceFile().fileName ||\n      declPosition !== undefined && declPosition >= scope.getStart() && declPosition < scope.getEnd()\n    ) {\n      return;\n    }\n    if (this.isTopSendableClosure(decl)) {\n      return;\n    }\n\n    /**\n     * The cases in condition will introduce closure if defined in the same file as the Sendable class. The following\n     * cases are excluded because they are not allowed in ArkTS:\n     * 1. ImportEqualDecalration\n     * 2. BindingElement\n     */\n    if (\n      ts.isVariableDeclaration(decl) ||\n      ts.isFunctionDeclaration(decl) ||\n      ts.isClassDeclaration(decl) ||\n      ts.isInterfaceDeclaration(decl) ||\n      ts.isEnumDeclaration(decl) ||\n      ts.isModuleDeclaration(decl) ||\n      ts.isParameter(decl)\n    ) {\n      this.incrementCounters(node, FaultID.SendableCapturedVars);\n    }\n  }\n\n  private isTopSendableClosure(decl: ts.Declaration): boolean {\n    return (\n      ts.isSourceFile(decl.parent) &&\n      ts.isClassDeclaration(decl) &&\n      this.tsUtils.isSendableClassOrInterface(this.tsTypeChecker.getTypeAtLocation(decl))\n    );\n  }\n\n  private checkNamespaceImportVar(node: ts.Node): boolean {\n    // Namespace import cannot be determined by the true symbol\n    const sym = this.tsTypeChecker.getSymbolAtLocation(node);\n    const decls = sym?.getDeclarations();\n    if (decls?.length) {\n      if (ts.isNamespaceImport(decls[0])) {\n        this.incrementCounters(node, FaultID.SendableCapturedVars);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  lint(sourceFile: ts.SourceFile): void {\n    Logger.info(\"lint====this.enableAutofix====\" + !!this.enableAutofix);\n    if (this.enableAutofix) {\n      this.autofixer = new Autofixer(this.tsTypeChecker, this.tsUtils, sourceFile, this.cancellationToken);\n    }\n\n    this.walkedComments.clear();\n    this.sourceFile = sourceFile;\n    this.visitSourceFile(this.sourceFile);\n    this.handleCommentDirectives(this.sourceFile);\n  }\n\n  private handleExportKeyword(node: ts.Node): void {\n    const parentNode = node.parent;\n    if (!TypeScriptLinter.inSharedModule(node) || ts.isModuleBlock(parentNode.parent)) {\n      return;\n    }\n\n    switch (parentNode.kind) {\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.ClassDeclaration:\n        if (!this.tsUtils.isShareableType(this.tsTypeChecker.getTypeAtLocation(parentNode))) {\n          this.incrementCounters((parentNode as ts.NamedDeclaration).name ?? parentNode, FaultID.SharedModuleExports);\n        }\n        return;\n      case ts.SyntaxKind.VariableStatement:\n        for (const variableDeclaration of (parentNode as ts.VariableStatement).declarationList.declarations) {\n          if (!this.tsUtils.isShareableEntity(variableDeclaration.name)) {\n            this.incrementCounters(variableDeclaration.name, FaultID.SharedModuleExports);\n          }\n        }\n        return;\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        return;\n      default:\n        this.incrementCounters(parentNode, FaultID.SharedModuleExports);\n    }\n  }\n\n  private handleExportDeclaration(node: ts.Node): void {\n    if (!TypeScriptLinter.inSharedModule(node) || ts.isModuleBlock(node.parent)) {\n      return;\n    }\n\n    const exportDecl = node as ts.ExportDeclaration;\n    if (exportDecl.exportClause === undefined) {\n      this.incrementCounters(exportDecl, FaultID.SharedModuleNoWildcardExport);\n      return;\n    }\n\n    if (ts.isNamespaceExport(exportDecl.exportClause)) {\n      if (!this.tsUtils.isShareableType(this.tsTypeChecker.getTypeAtLocation(exportDecl.exportClause.name))) {\n        this.incrementCounters(exportDecl.exportClause.name, FaultID.SharedModuleExports);\n      }\n      return;\n    }\n\n    for (const exportSpecifier of exportDecl.exportClause.elements) {\n      if (!this.tsUtils.isShareableEntity(exportSpecifier.name)) {\n        this.incrementCounters(exportSpecifier.name, FaultID.SharedModuleExports);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}