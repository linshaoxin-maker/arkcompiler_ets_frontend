{"version":3,"file":"Autofixer.js","names":["ts","_interopRequireWildcard","require","_TsUtils","_ContainsThis","_ForEachNodeInSubtree","_NameGenerator","_isAssignmentOperator","_SymbolCache","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_newArrowCheck","TypeError","_defineProperty","_toPropertyKey","value","enumerable","configurable","writable","_toPrimitive","Symbol","toPrimitive","String","Number","GENERATED_OBJECT_LITERAL_INTERFACE_NAME","GENERATED_OBJECT_LITERAL_INTERFACE_TRESHOLD","GENERATED_TYPE_LITERAL_INTERFACE_NAME","GENERATED_TYPE_LITERAL_INTERFACE_TRESHOLD","Autofixer","constructor","typeChecker","utils","sourceFile","cancellationToken","Map","createPrinter","omitTrailingSemicolon","removeComments","newLine","NewLineKind","LineFeed","NameGenerator","symbolCache","SymbolCache","fixLiteralAsPropertyNamePropertyAssignment","node","contextualType","getContextualType","parent","undefined","symbol","getPropertySymbol","renameSymbolAsIdentifier","fixLiteralAsPropertyNamePropertyName","getSymbolAtLocation","fixPropertyAccessByIndex","argumentExpression","_this","renameSymbolAsIdentifierCache","TsUtils","isPropertyOfInternalClassOrInterface","newName","findIdentifierNameForSymbol","result","getReferences","forEach","autofix","isPropertyDeclaration","isPropertyAssignment","isPropertySignature","renamePropertyName","name","isElementAccessExpression","renameElementAccessExpression","push","bind","length","isComputedPropertyName","isMemberName","idText","replacementText","start","getStart","end","getEnd","argExprKind","kind","SyntaxKind","NumericLiteral","StringLiteral","expression","getText","fixFunctionExpression","funcExpr","retType","type","modifiers","isGenerator","hasUnfixableReturnType","hasThisKeyword","scopeContainsThis","body","isCalledRecursively","isFunctionCalledRecursively","arrowFunc","factory","createArrowFunction","typeParameters","parameters","createToken","EqualsGreaterThanToken","needsParentheses","createParenthesizedExpression","text","printer","printNode","EmitHint","Unspecified","getSourceFile","isNodeInWhileOrIf","WhileStatement","DoStatement","IfStatement","isNodeInForLoop","ForInStatement","ForOfStatement","ForStatement","parentInFor","parentNode","parentInCaseOrWhile","varDeclList","CaseClause","isFunctionLikeDeclarationKind","FunctionDeclaration","MethodDeclaration","Constructor","GetAccessor","SetAccessor","FunctionExpression","ArrowFunction","findVarScope","Block","SourceFile","varHasScope","scope","varInFunctionForScope","selfDeclared","decl","ident","VariableDeclaration","declName","analizeTDZ","identifiers","pos","analizeScope","analizeFor","forNode","typedForNode","forVarDeclarations","initializer","declarations","forVarDecl","checkVarDeclarations","declLength","getName","canAutofixNoVar","fixVarDeclaration","newNode","createVariableDeclarationList","NodeFlags","Let","getFixReturnTypeArrowFunction","funcLikeDecl","typeNode","fixMissingReturnType","isArrowFunction","startPos","endPos","getReturnTypePosition","dropTypeOnVarDecl","varDecl","newVarDecl","createVariableDeclaration","fixTypeAssertion","typeAssertion","asExpr","createAsExpression","nonCommentPrinter","fixCommaOperator","tsNode","tsExprNode","recursiveCommaOperator","getFullStart","operatorToken","CommaToken","getFullText","left","BinaryExpression","right","leftText","rightText","fixEnumMerging","enumSymbol","enumDeclsInFile","_this2","enumMergingCache","isEnumDeclaration","members","member","fullEnum","createEnumDeclaration","fullText","postParametersPosition","equalsGreaterThanToken","children","getChildren","child","CloseParenToken","isPrefixUnaryExpression","isPostfixUnaryExpression","isPropertyAccessExpression","isTypeOfExpression","isVoidExpression","isAwaitExpression","isCallExpression","isBinaryExpression","isAssignmentOperator","fixCtorParameterProperties","ctorDecl","paramTypes","fieldInitStmts","newFieldPos","autofixes","fixCtorParameterPropertiesProcessParam","newBody","createBlock","concat","statements","newBodyText","param","paramType","isIdentifier","hasAccessModifier","propIdent","createIdentifier","newFieldNode","createPropertyDeclaration","getModifiers","newFieldText","newParamDecl","createParameterDeclaration","questionToken","newParamText","createExpressionStatement","createAssignment","createPropertyAccessExpression","createThis","fixPrivateIdentifier","_this3","classMember","getFlags","SymbolFlags","ClassMember","valueDeclaration","privateIdentifierCache","memberDecl","parentDecl","isClassLike","classMemberHasDuplicateName","isPrivateIdentifier","fixSinglePrivateIdentifier","isFunctionDeclarationFirst","tsFunctionDeclaration","_this4","minPos","fixNestedFunction","asteriskToken","canBeFixed","escapedText","getIllegalDecorators","token","typeDecl","createFunctionTypeNode","declaration","list","statement","createVariableStatement","fixMultipleStaticBlocks","nodes","bodyStatements","statickBlock","createClassStaticBlockDeclaration","isMethodDeclaration","isGetAccessorDeclaration","isSetAccessorDeclaration","mods","newMods","createModifier","PrivateKeyword","mod","slice","newDecl","replacePrivateIdentInDeclarationName","oldDecl","exclamationToken","createMethodDeclaration","createGetAccessorDeclaration","createSetAccessorDeclaration","fixUntypedObjectLiteral","objectLiteralExpr","objectLiteralType","enclosingStmt","getEnclosingTopLevelStatement","newInterfaceProps","getInterfacePropertiesFromObjectLiteral","srcFile","newInterfaceName","generateUniqueName","objectLiteralInterfaceNameGenerator","createNewInterface","fixObjectLiteralExpression","interfaceProps","prop","properties","interfaceProp","getInterfacePropertyFromObjectLiteralElement","propType","getTypeAtLocation","hasGenericTypeParameter","propertyTypeIsCapturedFromEnclosingLocalScope","propTypeNode","typeToTypeNode","NodeBuilderFlags","None","isSupportedType","newProp","createPropertySignature","sym","getSymbol","symNode","getDeclaration","interfaceName","newInterfaceDecl","createInterfaceDeclaration","isVariableDeclaration","isParameter","getDeclarationTypePositionForObjectLiteral","newTypeRef","createTypeReferenceNode","newExpr","createObjectLiteralExpression","isParenthesizedExpression","proceedTypeAliasDeclaration","typeLiteral","isTypeAliasDeclaration","typeAlias","fixTypeliteral","typeAliasAutofix","typeLiteralCapturesTypeFromEnclosingLocalScope","typeLiteralInterfaceNameGenerator","newInterfacePos","interfaceText","_this5","found","callback","stopCondition","forEachNodeInSubtree","exports"],"sources":["../../../lib/autofixes/Autofixer.ts"],"sourcesContent":["/*\n * Copyright (c) 2023-2024 Huawei Device Co., Ltd.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as ts from 'typescript';\nimport { TsUtils } from '../utils/TsUtils';\nimport { scopeContainsThis } from '../utils/functions/ContainsThis';\nimport { forEachNodeInSubtree } from '../utils/functions/ForEachNodeInSubtree';\nimport { NameGenerator } from '../utils/functions/NameGenerator';\nimport { isAssignmentOperator } from '../utils/functions/isAssignmentOperator';\nimport { SymbolCache } from './SymbolCache';\n\nconst GENERATED_OBJECT_LITERAL_INTERFACE_NAME = 'GeneratedObjectLiteralInterface_';\nconst GENERATED_OBJECT_LITERAL_INTERFACE_TRESHOLD = 1000;\n\nconst GENERATED_TYPE_LITERAL_INTERFACE_NAME = 'GeneratedTypeLiteralInterface_';\nconst GENERATED_TYPE_LITERAL_INTERFACE_TRESHOLD = 1000;\n\nexport interface Autofix {\n  replacementText: string;\n  start: number;\n  end: number;\n}\n\nexport class Autofixer {\n  constructor(\n    private readonly typeChecker: ts.TypeChecker,\n    private readonly utils: TsUtils,\n    readonly sourceFile: ts.SourceFile,\n    readonly cancellationToken?: ts.CancellationToken\n  ) {\n    this.symbolCache = new SymbolCache(this.typeChecker, this.utils, sourceFile, cancellationToken);\n  }\n\n  fixLiteralAsPropertyNamePropertyAssignment(node: ts.PropertyAssignment): Autofix[] | undefined {\n    const contextualType = this.typeChecker.getContextualType(node.parent);\n    if (contextualType === undefined) {\n      return undefined;\n    }\n\n    const symbol = this.utils.getPropertySymbol(contextualType, node);\n    if (symbol === undefined) {\n      return undefined;\n    }\n\n    return this.renameSymbolAsIdentifier(symbol);\n  }\n\n  fixLiteralAsPropertyNamePropertyName(node: ts.PropertyName): Autofix[] | undefined {\n    const symbol = this.typeChecker.getSymbolAtLocation(node);\n    if (symbol === undefined) {\n      return undefined;\n    }\n\n    return this.renameSymbolAsIdentifier(symbol);\n  }\n\n  fixPropertyAccessByIndex(node: ts.ElementAccessExpression): Autofix[] | undefined {\n    const symbol = this.typeChecker.getSymbolAtLocation(node.argumentExpression);\n    if (symbol === undefined) {\n      return undefined;\n    }\n\n    return this.renameSymbolAsIdentifier(symbol);\n  }\n\n  private renameSymbolAsIdentifier(symbol: ts.Symbol): Autofix[] | undefined {\n    if (this.renameSymbolAsIdentifierCache.has(symbol)) {\n      return this.renameSymbolAsIdentifierCache.get(symbol);\n    }\n\n    if (!TsUtils.isPropertyOfInternalClassOrInterface(symbol)) {\n      this.renameSymbolAsIdentifierCache.set(symbol, undefined);\n      return undefined;\n    }\n\n    const newName = this.utils.findIdentifierNameForSymbol(symbol);\n    if (newName === undefined) {\n      this.renameSymbolAsIdentifierCache.set(symbol, undefined);\n      return undefined;\n    }\n\n    let result: Autofix[] | undefined = [];\n    this.symbolCache.getReferences(symbol).forEach((node) => {\n      if (result === undefined) {\n        return;\n      }\n\n      let autofix: Autofix[] | undefined;\n      if (ts.isPropertyDeclaration(node) || ts.isPropertyAssignment(node) || ts.isPropertySignature(node)) {\n        autofix = Autofixer.renamePropertyName(node.name, newName);\n      } else if (ts.isElementAccessExpression(node)) {\n        autofix = Autofixer.renameElementAccessExpression(node, newName);\n      }\n\n      if (autofix === undefined) {\n        result = undefined;\n        return;\n      }\n\n      result.push(...autofix);\n    });\n    if (!result?.length) {\n      result = undefined;\n    }\n\n    this.renameSymbolAsIdentifierCache.set(symbol, result);\n    return result;\n  }\n\n  private readonly renameSymbolAsIdentifierCache = new Map<ts.Symbol, Autofix[] | undefined>();\n\n  private static renamePropertyName(node: ts.PropertyName, newName: string): Autofix[] | undefined {\n    if (ts.isComputedPropertyName(node)) {\n      return undefined;\n    }\n\n    if (ts.isMemberName(node)) {\n      if (ts.idText(node) !== newName) {\n        return undefined;\n      }\n\n      return [];\n    }\n\n    return [{ replacementText: newName, start: node.getStart(), end: node.getEnd() }];\n  }\n\n  private static renameElementAccessExpression(\n    node: ts.ElementAccessExpression,\n    newName: string\n  ): Autofix[] | undefined {\n    const argExprKind = node.argumentExpression.kind;\n    if (argExprKind !== ts.SyntaxKind.NumericLiteral && argExprKind !== ts.SyntaxKind.StringLiteral) {\n      return undefined;\n    }\n\n    return [\n      {\n        replacementText: node.expression.getText() + '.' + newName,\n        start: node.getStart(),\n        end: node.getEnd()\n      }\n    ];\n  }\n\n  fixFunctionExpression(\n    funcExpr: ts.FunctionExpression,\n    retType: ts.TypeNode | undefined = funcExpr.type,\n    modifiers: readonly ts.Modifier[] | undefined,\n    isGenerator: boolean,\n    hasUnfixableReturnType: boolean\n  ): Autofix[] | undefined {\n    const hasThisKeyword = scopeContainsThis(funcExpr.body);\n    const isCalledRecursively = this.utils.isFunctionCalledRecursively(funcExpr);\n    if (isGenerator || hasThisKeyword || isCalledRecursively || hasUnfixableReturnType) {\n      return undefined;\n    }\n\n    let arrowFunc: ts.Expression = ts.factory.createArrowFunction(\n      modifiers,\n      funcExpr.typeParameters,\n      funcExpr.parameters,\n      retType,\n      ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      funcExpr.body\n    );\n    if (Autofixer.needsParentheses(funcExpr)) {\n      arrowFunc = ts.factory.createParenthesizedExpression(arrowFunc);\n    }\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, arrowFunc, funcExpr.getSourceFile());\n    return [{ start: funcExpr.getStart(), end: funcExpr.getEnd(), replacementText: text }];\n  }\n\n  private static isNodeInWhileOrIf(node: ts.Node): boolean {\n    return (\n      node.kind === ts.SyntaxKind.WhileStatement ||\n      node.kind === ts.SyntaxKind.DoStatement ||\n      node.kind === ts.SyntaxKind.IfStatement\n    );\n  }\n\n  private static isNodeInForLoop(node: ts.Node): boolean {\n    return (\n      node.kind === ts.SyntaxKind.ForInStatement ||\n      node.kind === ts.SyntaxKind.ForOfStatement ||\n      node.kind === ts.SyntaxKind.ForStatement\n    );\n  }\n\n  private static parentInFor(node: ts.Node): ts.Node | undefined {\n    let parentNode = node.parent;\n    while (parentNode) {\n      if (Autofixer.isNodeInForLoop(parentNode)) {\n        return parentNode;\n      }\n      parentNode = parentNode.parent;\n    }\n    return undefined;\n  }\n\n  private static parentInCaseOrWhile(varDeclList: ts.VariableDeclarationList): boolean {\n    let parentNode: ts.Node = varDeclList.parent;\n    while (parentNode) {\n      if (parentNode.kind === ts.SyntaxKind.CaseClause || Autofixer.isNodeInWhileOrIf(parentNode)) {\n        return false;\n      }\n      parentNode = parentNode.parent;\n    }\n    return true;\n  }\n\n  private static isFunctionLikeDeclarationKind(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n      case ts.SyntaxKind.Constructor:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.ArrowFunction:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  private static findVarScope(node: ts.Node): ts.Node {\n    while (node !== undefined) {\n      if (node.kind === ts.SyntaxKind.Block || node.kind === ts.SyntaxKind.SourceFile) {\n        break;\n      }\n      node = node.parent;\n    }\n    return node;\n  }\n\n  private static varHasScope(node: ts.Node, scope: ts.Node): boolean {\n    while (node !== undefined) {\n      if (node === scope) {\n        return true;\n      }\n      node = node.parent;\n    }\n    return false;\n  }\n\n  private static varInFunctionForScope(node: ts.Node, scope: ts.Node): boolean {\n    while (node !== undefined) {\n      if (Autofixer.isFunctionLikeDeclarationKind(node)) {\n        break;\n      }\n      node = node.parent;\n    }\n    // node now Function like declaration\n\n    // node need to check that function like declaration is in scope\n    if (Autofixer.varHasScope(node, scope)) {\n      // var use is in function scope, which is in for scope\n      return true;\n    }\n    return false;\n  }\n\n  private static selfDeclared(decl: ts.Node, ident: ts.Node): boolean {\n    // Do not check the same node\n    if (ident === decl) {\n      return false;\n    }\n\n    while (ident !== undefined) {\n      if (ident.kind === ts.SyntaxKind.VariableDeclaration) {\n        const declName = (ident as ts.VariableDeclaration).name;\n        if (declName === decl) {\n          return true;\n        }\n      }\n      ident = ident.parent;\n    }\n    return false;\n  }\n\n  private static analizeTDZ(decl: ts.VariableDeclaration, identifiers: ts.Node[]): boolean {\n    for (const ident of identifiers) {\n      if (Autofixer.selfDeclared(decl.name, ident)) {\n        return false;\n      }\n      if (ident.pos < decl.pos) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static analizeScope(decl: ts.VariableDeclaration, identifiers: ts.Node[]): boolean {\n    const scope = Autofixer.findVarScope(decl);\n    if (scope === undefined) {\n      return false;\n    } else if (scope.kind === ts.SyntaxKind.Block) {\n      for (const ident of identifiers) {\n        if (!Autofixer.varHasScope(ident, scope)) {\n          return false;\n        }\n      }\n    } else if (scope.kind === ts.SyntaxKind.SourceFile) {\n      // Do nothing\n    } else {\n      // Unreachable, but check it\n      return false;\n    }\n    return true;\n  }\n\n  private static analizeFor(decl: ts.VariableDeclaration, identifiers: ts.Node[]): boolean {\n    const forNode = Autofixer.parentInFor(decl);\n    if (forNode) {\n      // analize that var is initialized\n      if (forNode.kind === ts.SyntaxKind.ForInStatement || forNode.kind === ts.SyntaxKind.ForOfStatement) {\n        const typedForNode = forNode as ts.ForInOrOfStatement;\n        const forVarDeclarations = (typedForNode.initializer as ts.VariableDeclarationList).declarations;\n        if (forVarDeclarations.length !== 1) {\n          return false;\n        }\n        const forVarDecl = forVarDeclarations[0];\n\n        // our goal to skip declarations in for of/in initializer\n        if (forVarDecl !== decl && decl.initializer === undefined) {\n          return false;\n        }\n      } else if (decl.initializer === undefined) {\n        return false;\n      }\n\n      // analize that var uses are only in function block\n      for (const ident of identifiers) {\n        if (ident !== decl && !Autofixer.varHasScope(ident, forNode)) {\n          return false;\n        }\n      }\n\n      // analize that var is not in function\n      for (const ident of identifiers) {\n        if (ident !== decl && Autofixer.varInFunctionForScope(ident, forNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  private checkVarDeclarations(varDeclList: ts.VariableDeclarationList): boolean {\n    for (const decl of varDeclList.declarations) {\n      const symbol = this.typeChecker.getSymbolAtLocation(decl.name);\n      if (!symbol) {\n        return false;\n      }\n\n      const identifiers = this.symbolCache.getReferences(symbol);\n\n      const declLength = symbol.declarations?.length;\n      if (!declLength || declLength >= 2) {\n        return false;\n      }\n\n      // Check for var use in tdz oe self declaration\n      if (!Autofixer.analizeTDZ(decl, identifiers)) {\n        return false;\n      }\n\n      // Has use outside scope of declaration?\n      if (!Autofixer.analizeScope(decl, identifiers)) {\n        return false;\n      }\n\n      // For analisys\n      if (!Autofixer.analizeFor(decl, identifiers)) {\n        return false;\n      }\n\n      if (symbol.getName() === 'let') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private canAutofixNoVar(varDeclList: ts.VariableDeclarationList): boolean {\n    if (!Autofixer.parentInCaseOrWhile(varDeclList)) {\n      return false;\n    }\n\n    if (!this.checkVarDeclarations(varDeclList)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  fixVarDeclaration(node: ts.VariableDeclarationList): Autofix[] | undefined {\n    const newNode = ts.factory.createVariableDeclarationList(node.declarations, ts.NodeFlags.Let);\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newNode, node.getSourceFile());\n    return this.canAutofixNoVar(node) ?\n      [{ start: node.getStart(), end: node.getEnd(), replacementText: text }] :\n      undefined;\n  }\n\n  private getFixReturnTypeArrowFunction(funcLikeDecl: ts.FunctionLikeDeclaration, typeNode: ts.TypeNode): string {\n    if (!funcLikeDecl.body) {\n      return '';\n    }\n    const node = ts.factory.createArrowFunction(\n      undefined,\n      funcLikeDecl.typeParameters,\n      funcLikeDecl.parameters,\n      typeNode,\n      ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      funcLikeDecl.body\n    );\n    return this.printer.printNode(ts.EmitHint.Unspecified, node, funcLikeDecl.getSourceFile());\n  }\n\n  fixMissingReturnType(funcLikeDecl: ts.FunctionLikeDeclaration, typeNode: ts.TypeNode): Autofix[] {\n    if (ts.isArrowFunction(funcLikeDecl)) {\n      const text = this.getFixReturnTypeArrowFunction(funcLikeDecl, typeNode);\n      const startPos = funcLikeDecl.getStart();\n      const endPos = funcLikeDecl.getEnd();\n      return [{ start: startPos, end: endPos, replacementText: text }];\n    }\n    const text = ': ' + this.printer.printNode(ts.EmitHint.Unspecified, typeNode, funcLikeDecl.getSourceFile());\n    const pos = Autofixer.getReturnTypePosition(funcLikeDecl);\n    return [{ start: pos, end: pos, replacementText: text }];\n  }\n\n  dropTypeOnVarDecl(varDecl: ts.VariableDeclaration): Autofix[] {\n    const newVarDecl = ts.factory.createVariableDeclaration(varDecl.name, undefined, undefined, undefined);\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newVarDecl, varDecl.getSourceFile());\n    return [{ start: varDecl.getStart(), end: varDecl.getEnd(), replacementText: text }];\n  }\n\n  fixTypeAssertion(typeAssertion: ts.TypeAssertion): Autofix[] {\n    const asExpr = ts.factory.createAsExpression(typeAssertion.expression, typeAssertion.type);\n    const text = this.nonCommentPrinter.printNode(ts.EmitHint.Unspecified, asExpr, typeAssertion.getSourceFile());\n    return [{ start: typeAssertion.getStart(), end: typeAssertion.getEnd(), replacementText: text }];\n  }\n\n  fixCommaOperator(tsNode: ts.Node): Autofix[] {\n    const tsExprNode = tsNode as ts.BinaryExpression;\n    const text = this.recursiveCommaOperator(tsExprNode);\n    return [{ start: tsExprNode.parent.getFullStart(), end: tsExprNode.parent.getEnd(), replacementText: text }];\n  }\n\n  private recursiveCommaOperator(tsExprNode: ts.BinaryExpression): string {\n    let text = '';\n    if (tsExprNode.operatorToken.kind !== ts.SyntaxKind.CommaToken) {\n      return tsExprNode.getFullText() + ';';\n    }\n\n    if (tsExprNode.left.kind === ts.SyntaxKind.BinaryExpression) {\n      text += this.recursiveCommaOperator(tsExprNode.left as ts.BinaryExpression);\n      text += '\\n' + tsExprNode.right.getFullText() + ';';\n    } else {\n      const leftText = tsExprNode.left.getFullText();\n      const rightText = tsExprNode.right.getFullText();\n      text = leftText + ';\\n' + rightText + ';';\n    }\n\n    return text;\n  }\n\n  fixEnumMerging(enumSymbol: ts.Symbol, enumDeclsInFile: ts.Declaration[]): Autofix[] | undefined {\n    if (this.enumMergingCache.has(enumSymbol)) {\n      return this.enumMergingCache.get(enumSymbol);\n    }\n\n    if (enumDeclsInFile.length <= 1) {\n      this.enumMergingCache.set(enumSymbol, undefined);\n      return undefined;\n    }\n\n    let result: Autofix[] | undefined = [];\n    this.symbolCache.getReferences(enumSymbol).forEach((node) => {\n      if (result === undefined || !ts.isEnumDeclaration(node)) {\n        return;\n      }\n\n      if (result.length) {\n        result.push({ start: node.getStart(), end: node.getEnd(), replacementText: '' });\n        return;\n      }\n\n      const members: ts.EnumMember[] = [];\n      for (const decl of enumDeclsInFile) {\n        for (const member of (decl as ts.EnumDeclaration).members) {\n          if (\n            member.initializer &&\n            member.initializer.kind !== ts.SyntaxKind.NumericLiteral &&\n            member.initializer.kind !== ts.SyntaxKind.StringLiteral\n          ) {\n            result = undefined;\n            return;\n          }\n        }\n        members.push(...(decl as ts.EnumDeclaration).members);\n      }\n\n      const fullEnum = ts.factory.createEnumDeclaration(node.modifiers, node.name, members);\n      const fullText = this.printer.printNode(ts.EmitHint.Unspecified, fullEnum, node.getSourceFile());\n      result.push({ start: node.getStart(), end: node.getEnd(), replacementText: fullText });\n    });\n    if (!result?.length) {\n      result = undefined;\n    }\n\n    this.enumMergingCache.set(enumSymbol, result);\n    return result;\n  }\n\n  private readonly enumMergingCache = new Map<ts.Symbol, Autofix[] | undefined>();\n\n  private readonly printer: ts.Printer = ts.createPrinter({\n    omitTrailingSemicolon: false,\n    removeComments: false,\n    newLine: ts.NewLineKind.LineFeed\n  });\n\n  private readonly nonCommentPrinter: ts.Printer = ts.createPrinter({\n    omitTrailingSemicolon: false,\n    removeComments: true,\n    newLine: ts.NewLineKind.LineFeed\n  });\n\n  private static getReturnTypePosition(funcLikeDecl: ts.FunctionLikeDeclaration): number {\n    if (funcLikeDecl.body) {\n\n      /*\n       * Find position of the first node or token that follows parameters.\n       * After that, iterate over child nodes in reverse order, until found\n       * first closing parenthesis.\n       */\n      const postParametersPosition = ts.isArrowFunction(funcLikeDecl) ?\n        funcLikeDecl.equalsGreaterThanToken.getStart() :\n        funcLikeDecl.body.getStart();\n\n      const children = funcLikeDecl.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        if (child.kind === ts.SyntaxKind.CloseParenToken && child.getEnd() <= postParametersPosition) {\n          return child.getEnd();\n        }\n      }\n    }\n\n    // Shouldn't get here.\n    return -1;\n  }\n\n  private static needsParentheses(node: ts.FunctionExpression): boolean {\n    const parent = node.parent;\n    return (\n      ts.isPrefixUnaryExpression(parent) ||\n      ts.isPostfixUnaryExpression(parent) ||\n      ts.isPropertyAccessExpression(parent) ||\n      ts.isElementAccessExpression(parent) ||\n      ts.isTypeOfExpression(parent) ||\n      ts.isVoidExpression(parent) ||\n      ts.isAwaitExpression(parent) ||\n      ts.isCallExpression(parent) && node === parent.expression ||\n      ts.isBinaryExpression(parent) && !isAssignmentOperator(parent.operatorToken)\n    );\n  }\n\n  fixCtorParameterProperties(\n    ctorDecl: ts.ConstructorDeclaration,\n    paramTypes: ts.TypeNode[] | undefined\n  ): Autofix[] | undefined {\n    if (paramTypes === undefined) {\n      return undefined;\n    }\n\n    const fieldInitStmts: ts.Statement[] = [];\n    const newFieldPos = ctorDecl.getStart();\n    const autofixes: Autofix[] = [{ start: newFieldPos, end: newFieldPos, replacementText: '' }];\n\n    for (let i = 0; i < ctorDecl.parameters.length; i++) {\n      this.fixCtorParameterPropertiesProcessParam(\n        ctorDecl.parameters[i],\n        paramTypes[i],\n        ctorDecl.getSourceFile(),\n        fieldInitStmts,\n        autofixes\n      );\n    }\n\n    // Note: Bodyless ctors can't have parameter properties.\n    if (ctorDecl.body) {\n      const newBody = ts.factory.createBlock(fieldInitStmts.concat(ctorDecl.body.statements), true);\n      const newBodyText = this.printer.printNode(ts.EmitHint.Unspecified, newBody, ctorDecl.getSourceFile());\n      autofixes.push({ start: ctorDecl.body.getStart(), end: ctorDecl.body.getEnd(), replacementText: newBodyText });\n    }\n\n    return autofixes;\n  }\n\n  private fixCtorParameterPropertiesProcessParam(\n    param: ts.ParameterDeclaration,\n    paramType: ts.TypeNode,\n    sourceFile: ts.SourceFile,\n    fieldInitStmts: ts.Statement[],\n    autofixes: Autofix[]\n  ): void {\n    // Parameter property can not be a destructuring parameter.\n    if (!ts.isIdentifier(param.name)) {\n      return;\n    }\n\n    if (this.utils.hasAccessModifier(param)) {\n      const propIdent = ts.factory.createIdentifier(param.name.text);\n\n      const newFieldNode = ts.factory.createPropertyDeclaration(\n        ts.getModifiers(param),\n        propIdent,\n        undefined,\n        paramType,\n        undefined\n      );\n      const newFieldText = this.printer.printNode(ts.EmitHint.Unspecified, newFieldNode, sourceFile) + '\\n';\n      autofixes[0].replacementText += newFieldText;\n\n      const newParamDecl = ts.factory.createParameterDeclaration(\n        undefined,\n        undefined,\n        param.name,\n        param.questionToken,\n        param.type,\n        param.initializer\n      );\n      const newParamText = this.printer.printNode(ts.EmitHint.Unspecified, newParamDecl, sourceFile);\n      autofixes.push({ start: param.getStart(), end: param.getEnd(), replacementText: newParamText });\n\n      fieldInitStmts.push(\n        ts.factory.createExpressionStatement(\n          ts.factory.createAssignment(\n            ts.factory.createPropertyAccessExpression(ts.factory.createThis(), propIdent),\n            propIdent\n          )\n        )\n      );\n    }\n  }\n\n  fixPrivateIdentifier(node: ts.PrivateIdentifier): Autofix[] | undefined {\n    const classMember = this.typeChecker.getSymbolAtLocation(node);\n    if (!classMember || (classMember.getFlags() & ts.SymbolFlags.ClassMember) === 0 || !classMember.valueDeclaration) {\n      return undefined;\n    }\n\n    if (this.privateIdentifierCache.has(classMember)) {\n      return this.privateIdentifierCache.get(classMember);\n    }\n\n    const memberDecl = classMember.valueDeclaration as ts.ClassElement;\n    const parentDecl = memberDecl.parent;\n    if (!ts.isClassLike(parentDecl) || this.utils.classMemberHasDuplicateName(memberDecl, parentDecl, true)) {\n      this.privateIdentifierCache.set(classMember, undefined);\n      return undefined;\n    }\n\n    let result: Autofix[] | undefined = [];\n    this.symbolCache.getReferences(classMember).forEach((ident) => {\n      if (ts.isPrivateIdentifier(ident)) {\n        result!.push(this.fixSinglePrivateIdentifier(ident));\n      }\n    });\n    if (!result.length) {\n      result = undefined;\n    }\n\n    this.privateIdentifierCache.set(classMember, result);\n    return result;\n  }\n\n  private isFunctionDeclarationFirst(tsFunctionDeclaration: ts.FunctionDeclaration): boolean {\n    if (tsFunctionDeclaration.name === undefined) {\n      return false;\n    }\n\n    const symbol = this.typeChecker.getSymbolAtLocation(tsFunctionDeclaration.name);\n    if (symbol === undefined) {\n      return false;\n    }\n\n    let minPos = tsFunctionDeclaration.pos;\n    this.symbolCache.getReferences(symbol).forEach((ident) => {\n      if (ident.pos < minPos) {\n        minPos = ident.pos;\n      }\n    });\n\n    return minPos >= tsFunctionDeclaration.pos;\n  }\n\n  fixNestedFunction(tsFunctionDeclaration: ts.FunctionDeclaration): Autofix[] | undefined {\n    const isGenerator = tsFunctionDeclaration.asteriskToken !== undefined;\n    const hasThisKeyword =\n      tsFunctionDeclaration.body === undefined ? false : scopeContainsThis(tsFunctionDeclaration.body);\n    const canBeFixed = !isGenerator && !hasThisKeyword;\n    if (!canBeFixed) {\n      return undefined;\n    }\n\n    const name = tsFunctionDeclaration.name?.escapedText;\n    const type = tsFunctionDeclaration.type;\n    const body = tsFunctionDeclaration.body;\n    if (!name || !type || !body) {\n      return undefined;\n    }\n\n    // Check only illegal decorators, cause all decorators for function declaration are illegal\n    if (ts.getIllegalDecorators(tsFunctionDeclaration)) {\n      return undefined;\n    }\n\n    if (!this.isFunctionDeclarationFirst(tsFunctionDeclaration)) {\n      return undefined;\n    }\n\n    const typeParameters = tsFunctionDeclaration.typeParameters;\n    const parameters = tsFunctionDeclaration.parameters;\n    const modifiers = ts.getModifiers(tsFunctionDeclaration);\n\n    const token = ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken);\n    const typeDecl = ts.factory.createFunctionTypeNode(typeParameters, parameters, type);\n    const arrowFunc = ts.factory.createArrowFunction(modifiers, typeParameters, parameters, type, token, body);\n\n    const declaration: ts.VariableDeclaration = ts.factory.createVariableDeclaration(\n      name,\n      undefined,\n      typeDecl,\n      arrowFunc\n    );\n    const list: ts.VariableDeclarationList = ts.factory.createVariableDeclarationList([declaration], ts.NodeFlags.Let);\n\n    const statement = ts.factory.createVariableStatement(modifiers, list);\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, statement, tsFunctionDeclaration.getSourceFile());\n    return [{ start: tsFunctionDeclaration.getStart(), end: tsFunctionDeclaration.getEnd(), replacementText: text }];\n  }\n\n  fixMultipleStaticBlocks(nodes: ts.Node[]): Autofix[] | undefined {\n    const autofix: Autofix[] | undefined = [];\n    let body = (nodes[0] as ts.ClassStaticBlockDeclaration).body;\n    let bodyStatements: ts.Statement[] = [];\n    bodyStatements = bodyStatements.concat(body.statements);\n    for (let i = 1; i < nodes.length; i++) {\n      bodyStatements = bodyStatements.concat((nodes[i] as ts.ClassStaticBlockDeclaration).body.statements);\n      autofix[i] = { start: nodes[i].getFullStart(), end: nodes[i].getEnd(), replacementText: '' };\n    }\n    body = ts.factory.createBlock(bodyStatements, true);\n    // static blocks shouldn't have modifiers\n    const statickBlock = ts.factory.createClassStaticBlockDeclaration(body);\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, statickBlock, nodes[0].getSourceFile());\n    autofix[0] = { start: nodes[0].getStart(), end: nodes[0].getEnd(), replacementText: text };\n    return autofix;\n  }\n\n  private readonly privateIdentifierCache = new Map<ts.Symbol, Autofix[] | undefined>();\n\n  private fixSinglePrivateIdentifier(ident: ts.PrivateIdentifier): Autofix {\n    if (\n      ts.isPropertyDeclaration(ident.parent) ||\n      ts.isMethodDeclaration(ident.parent) ||\n      ts.isGetAccessorDeclaration(ident.parent) ||\n      ts.isSetAccessorDeclaration(ident.parent)\n    ) {\n      // Note: 'private' modifier should always be first.\n      const mods = ts.getModifiers(ident.parent);\n      const newMods: ts.Modifier[] = [ts.factory.createModifier(ts.SyntaxKind.PrivateKeyword)];\n      if (mods) {\n        for (const mod of mods) {\n          newMods.push(ts.factory.createModifier(mod.kind));\n        }\n      }\n\n      const newName = ident.text.slice(1, ident.text.length);\n      const newDecl = Autofixer.replacePrivateIdentInDeclarationName(newMods, newName, ident.parent);\n      const text = this.printer.printNode(ts.EmitHint.Unspecified, newDecl, ident.getSourceFile());\n      return { start: ident.parent.getStart(), end: ident.parent.getEnd(), replacementText: text };\n    }\n\n    return {\n      start: ident.getStart(),\n      end: ident.getEnd(),\n      replacementText: ident.text.slice(1, ident.text.length)\n    };\n  }\n\n  private static replacePrivateIdentInDeclarationName(\n    mods: ts.Modifier[],\n    name: string,\n    oldDecl: ts.PropertyDeclaration | ts.MethodDeclaration | ts.GetAccessorDeclaration | ts.SetAccessorDeclaration\n  ): ts.Declaration {\n    if (ts.isPropertyDeclaration(oldDecl)) {\n      return ts.factory.createPropertyDeclaration(\n        mods,\n        ts.factory.createIdentifier(name),\n        oldDecl.questionToken ?? oldDecl.exclamationToken,\n        oldDecl.type,\n        oldDecl.initializer\n      );\n    } else if (ts.isMethodDeclaration(oldDecl)) {\n      return ts.factory.createMethodDeclaration(\n        mods,\n        oldDecl.asteriskToken,\n        ts.factory.createIdentifier(name),\n        oldDecl.questionToken,\n        oldDecl.typeParameters,\n        oldDecl.parameters,\n        oldDecl.type,\n        oldDecl.body\n      );\n    } else if (ts.isGetAccessorDeclaration(oldDecl)) {\n      return ts.factory.createGetAccessorDeclaration(\n        mods,\n        ts.factory.createIdentifier(name),\n        oldDecl.parameters,\n        oldDecl.type,\n        oldDecl.body\n      );\n    }\n    return ts.factory.createSetAccessorDeclaration(\n      mods,\n      ts.factory.createIdentifier(name),\n      oldDecl.parameters,\n      oldDecl.body\n    );\n  }\n\n  fixUntypedObjectLiteral(\n    objectLiteralExpr: ts.ObjectLiteralExpression,\n    objectLiteralType: ts.Type | undefined\n  ): Autofix[] | undefined {\n    // Can't fix if object literal already has contextual type.\n    if (objectLiteralType) {\n      return undefined;\n    }\n\n    const enclosingStmt = TsUtils.getEnclosingTopLevelStatement(objectLiteralExpr);\n    if (!enclosingStmt) {\n      return undefined;\n    }\n\n    const newInterfaceProps = this.getInterfacePropertiesFromObjectLiteral(objectLiteralExpr, enclosingStmt);\n    if (!newInterfaceProps) {\n      return undefined;\n    }\n\n    const srcFile = objectLiteralExpr.getSourceFile();\n    const newInterfaceName = TsUtils.generateUniqueName(this.objectLiteralInterfaceNameGenerator, srcFile);\n    if (!newInterfaceName) {\n      return undefined;\n    }\n\n    return [\n      this.createNewInterface(srcFile, newInterfaceName, newInterfaceProps, enclosingStmt.getStart()),\n      this.fixObjectLiteralExpression(srcFile, newInterfaceName, objectLiteralExpr)\n    ];\n  }\n\n  private getInterfacePropertiesFromObjectLiteral(\n    objectLiteralExpr: ts.ObjectLiteralExpression,\n    enclosingStmt: ts.Node\n  ): ts.PropertySignature[] | undefined {\n    const interfaceProps: ts.PropertySignature[] = [];\n    for (const prop of objectLiteralExpr.properties) {\n      const interfaceProp = this.getInterfacePropertyFromObjectLiteralElement(prop, enclosingStmt);\n      if (!interfaceProp) {\n        return undefined;\n      }\n      interfaceProps.push(interfaceProp);\n    }\n    return interfaceProps;\n  }\n\n  private getInterfacePropertyFromObjectLiteralElement(\n    prop: ts.ObjectLiteralElementLike,\n    enclosingStmt: ts.Node\n  ): ts.PropertySignature | undefined {\n    // Can't fix if property is not a key-value pair, or the property name is a computed value.\n    if (!ts.isPropertyAssignment(prop) || ts.isComputedPropertyName(prop.name)) {\n      return undefined;\n    }\n\n    const propType = this.typeChecker.getTypeAtLocation(prop);\n\n    // Can't capture generic type parameters of enclosing declarations.\n    if (this.utils.hasGenericTypeParameter(propType)) {\n      return undefined;\n    }\n\n    if (Autofixer.propertyTypeIsCapturedFromEnclosingLocalScope(propType, enclosingStmt)) {\n      return undefined;\n    }\n\n    const propTypeNode = this.typeChecker.typeToTypeNode(propType, undefined, ts.NodeBuilderFlags.None);\n    if (!propTypeNode || !this.utils.isSupportedType(propTypeNode)) {\n      return undefined;\n    }\n\n    const newProp: ts.PropertySignature = ts.factory.createPropertySignature(\n      undefined,\n      prop.name,\n      undefined,\n      propTypeNode\n    );\n    return newProp;\n  }\n\n  private static propertyTypeIsCapturedFromEnclosingLocalScope(type: ts.Type, enclosingStmt: ts.Node): boolean {\n    const sym = type.getSymbol();\n    let symNode: ts.Node | undefined = TsUtils.getDeclaration(sym);\n\n    while (symNode) {\n      if (symNode === enclosingStmt) {\n        return true;\n      }\n      symNode = symNode.parent;\n    }\n\n    return false;\n  }\n\n  private createNewInterface(\n    srcFile: ts.SourceFile,\n    interfaceName: string,\n    members: ts.TypeElement[],\n    pos: number\n  ): Autofix {\n    const newInterfaceDecl = ts.factory.createInterfaceDeclaration(\n      undefined,\n      interfaceName,\n      undefined,\n      undefined,\n      members\n    );\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newInterfaceDecl, srcFile) + '\\n';\n    return { start: pos, end: pos, replacementText: text };\n  }\n\n  private fixObjectLiteralExpression(\n    srcFile: ts.SourceFile,\n    newInterfaceName: string,\n    objectLiteralExpr: ts.ObjectLiteralExpression\n  ): Autofix {\n\n    /*\n     * If object literal is initializing a variable or property,\n     * then simply add new 'contextual' type to the declaration.\n     * Otherwise, cast object literal to newly created interface type.\n     */\n    if (\n      (ts.isVariableDeclaration(objectLiteralExpr.parent) ||\n        ts.isPropertyDeclaration(objectLiteralExpr.parent) ||\n        ts.isParameter(objectLiteralExpr.parent)) &&\n      !objectLiteralExpr.parent.type\n    ) {\n      const text = ': ' + newInterfaceName;\n      const pos = Autofixer.getDeclarationTypePositionForObjectLiteral(objectLiteralExpr.parent);\n      return { start: pos, end: pos, replacementText: text };\n    }\n\n    const newTypeRef = ts.factory.createTypeReferenceNode(newInterfaceName);\n    let newExpr: ts.Expression = ts.factory.createAsExpression(\n      ts.factory.createObjectLiteralExpression(objectLiteralExpr.properties),\n      newTypeRef\n    );\n    if (!ts.isParenthesizedExpression(objectLiteralExpr.parent)) {\n      newExpr = ts.factory.createParenthesizedExpression(newExpr);\n    }\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newExpr, srcFile);\n    return { start: objectLiteralExpr.getStart(), end: objectLiteralExpr.getEnd(), replacementText: text };\n  }\n\n  private static getDeclarationTypePositionForObjectLiteral(\n    decl: ts.VariableDeclaration | ts.PropertyDeclaration | ts.ParameterDeclaration\n  ): number {\n    if (ts.isPropertyDeclaration(decl)) {\n      return (decl.questionToken || decl.exclamationToken || decl.name).getEnd();\n    } else if (ts.isParameter(decl)) {\n      return (decl.questionToken || decl.name).getEnd();\n    }\n    return (decl.exclamationToken || decl.name).getEnd();\n  }\n\n  private readonly objectLiteralInterfaceNameGenerator = new NameGenerator(\n    GENERATED_OBJECT_LITERAL_INTERFACE_NAME,\n    GENERATED_OBJECT_LITERAL_INTERFACE_TRESHOLD\n  );\n\n  /*\n   * In case of type alias initialized with type literal, replace\n   * entire type alias with identical interface declaration.\n   */\n  private proceedTypeAliasDeclaration(typeLiteral: ts.TypeLiteralNode): Autofix[] | undefined {\n    if (ts.isTypeAliasDeclaration(typeLiteral.parent)) {\n      const typeAlias = typeLiteral.parent;\n      const newInterfaceDecl = ts.factory.createInterfaceDeclaration(\n        typeAlias.modifiers,\n        typeAlias.name,\n        typeAlias.typeParameters,\n        undefined,\n        typeLiteral.members\n      );\n      const text = this.printer.printNode(ts.EmitHint.Unspecified, newInterfaceDecl, typeLiteral.getSourceFile());\n      return [{ start: typeAlias.getStart(), end: typeAlias.getEnd(), replacementText: text }];\n    }\n    return undefined;\n  }\n\n  fixTypeliteral(typeLiteral: ts.TypeLiteralNode): Autofix[] | undefined {\n    const typeAliasAutofix = this.proceedTypeAliasDeclaration(typeLiteral);\n    if (typeAliasAutofix) {\n      return typeAliasAutofix;\n    }\n\n    /*\n     * Create new interface declaration with members of type literal\n     * and put the interface name in place of the type literal.\n     */\n    const srcFile = typeLiteral.getSourceFile();\n    const enclosingStmt = TsUtils.getEnclosingTopLevelStatement(typeLiteral);\n    if (!enclosingStmt) {\n      return undefined;\n    }\n\n    if (this.typeLiteralCapturesTypeFromEnclosingLocalScope(typeLiteral, enclosingStmt)) {\n      return undefined;\n    }\n\n    const newInterfaceName = TsUtils.generateUniqueName(this.typeLiteralInterfaceNameGenerator, srcFile);\n    if (!newInterfaceName) {\n      return undefined;\n    }\n    const newInterfacePos = enclosingStmt.getStart();\n    const newInterfaceDecl = ts.factory.createInterfaceDeclaration(\n      undefined,\n      newInterfaceName,\n      undefined,\n      undefined,\n      typeLiteral.members\n    );\n    const interfaceText = this.printer.printNode(ts.EmitHint.Unspecified, newInterfaceDecl, srcFile) + '\\n';\n\n    return [\n      { start: newInterfacePos, end: newInterfacePos, replacementText: interfaceText },\n      { start: typeLiteral.getStart(), end: typeLiteral.getEnd(), replacementText: newInterfaceName }\n    ];\n  }\n\n  typeLiteralCapturesTypeFromEnclosingLocalScope(typeLiteral: ts.TypeLiteralNode, enclosingStmt: ts.Node): boolean {\n    let found = false;\n\n    const callback = (node: ts.Node): void => {\n      if (ts.isIdentifier(node)) {\n        const sym = this.typeChecker.getSymbolAtLocation(node);\n        let symNode: ts.Node | undefined = TsUtils.getDeclaration(sym);\n        while (symNode) {\n          if (symNode === typeLiteral) {\n            return;\n          }\n          if (symNode === enclosingStmt) {\n            found = true;\n            return;\n          }\n          symNode = symNode.parent;\n        }\n      }\n    };\n\n    const stopCondition = (node: ts.Node): boolean => {\n      void node;\n      return found;\n    };\n\n    forEachNodeInSubtree(typeLiteral, callback, stopCondition);\n    return found;\n  }\n\n  private readonly typeLiteralInterfaceNameGenerator = new NameGenerator(\n    GENERATED_TYPE_LITERAL_INTERFACE_NAME,\n    GENERATED_TYPE_LITERAL_INTERFACE_TRESHOLD\n  );\n\n  private readonly symbolCache: SymbolCache;\n}\n"],"mappings":"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","ignoreList":[]}